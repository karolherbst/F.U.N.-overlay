diff --git a/include/GL/internal/dri_interface.h b/include/GL/internal/dri_interface.h
index d3a66c5..97e1a1a 100644
--- a/include/GL/internal/dri_interface.h
+++ b/include/GL/internal/dri_interface.h
@@ -800,8 +800,8 @@ struct __DRIdri2LoaderExtensionRec {
 #define __DRI_DRI2_VERSION 3
 
 #define __DRI_API_OPENGL	0	/**< OpenGL compatibility profile */
-#define __DRI_API_GLES		1
-#define __DRI_API_GLES2		2
+#define __DRI_API_GLES		1	/**< OpenGL ES 1.x */
+#define __DRI_API_GLES2		2	/**< OpenGL ES 2.0 or 3.0 */
 #define __DRI_API_OPENGL_CORE	3	/**< OpenGL 3.2+ core profile */
 
 #define __DRI_CTX_ATTRIB_MAJOR_VERSION		0
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index a78ee8b..423d18d 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -308,7 +308,7 @@ struct dri2_extension_match {
 
 static struct dri2_extension_match dri2_driver_extensions[] = {
    { __DRI_CORE, 1, offsetof(struct dri2_egl_display, core) },
-   { __DRI_DRI2, 1, offsetof(struct dri2_egl_display, dri2) },
+   { __DRI_DRI2, 2, offsetof(struct dri2_egl_display, dri2) },
    { NULL, 0, 0 }
 };
 
@@ -322,12 +322,12 @@ static struct dri2_extension_match dri2_core_extensions[] = {
 static struct dri2_extension_match swrast_driver_extensions[] = {
    { __DRI_CORE, 1, offsetof(struct dri2_egl_display, core) },
    { __DRI_SWRAST, 2, offsetof(struct dri2_egl_display, swrast) },
-   { NULL }
+   { NULL, 0, 0 }
 };
 
 static struct dri2_extension_match swrast_core_extensions[] = {
    { __DRI_TEX_BUFFER, 2, offsetof(struct dri2_egl_display, tex_buffer) },
-   { NULL }
+   { NULL, 0, 0 }
 };
 
 static EGLBoolean
@@ -464,10 +464,7 @@ dri2_setup_screen(_EGLDisplay *disp)
    unsigned int api_mask;
 
    if (dri2_dpy->dri2) {
-      if (dri2_dpy->dri2->base.version >= 2)
-         api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
-      else
-         api_mask = 1 << __DRI_API_OPENGL;
+      api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
    } else {
       assert(dri2_dpy->swrast);
       api_mask = 1 << __DRI_API_OPENGL | 1 << __DRI_API_GLES | 1 << __DRI_API_GLES2;
@@ -481,13 +478,14 @@ dri2_setup_screen(_EGLDisplay *disp)
    if (api_mask & (1 << __DRI_API_GLES2))
       disp->ClientAPIs |= EGL_OPENGL_ES2_BIT;
 
-   if (dri2_dpy->dri2) {
-      if (dri2_dpy->dri2->base.version >= 2) {
-         disp->Extensions.KHR_surfaceless_context = EGL_TRUE;
-      }
-   } else {
-      assert(dri2_dpy->swrast);
-      disp->Extensions.KHR_surfaceless_context = EGL_TRUE;
+   assert(dri2_dpy->dri2 || dri2_dpy->swrast);
+   disp->Extensions.KHR_surfaceless_context = EGL_TRUE;
+
+   if (dri2_dpy->dri2->base.version >= 3) {
+      disp->Extensions.KHR_create_context = EGL_TRUE;
+
+      if (dri2_dpy->robustness)
+         disp->Extensions.EXT_create_context_robustness = EGL_TRUE;
    }
 
    if (dri2_dpy->image) {
@@ -526,8 +524,16 @@ dri2_create_screen(_EGLDisplay *disp)
    extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
    
    if (dri2_dpy->dri2) {
+      unsigned i;
+
       if (!dri2_bind_extensions(dri2_dpy, dri2_core_extensions, extensions))
          goto cleanup_dri_screen;
+
+      for (i = 0; extensions[i]; i++) {
+	 if (strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0) {
+            dri2_dpy->robustness = (__DRIrobustnessExtension *) extensions[i];
+	 }
+      }
    } else {
       assert(dri2_dpy->swrast);
       if (!dri2_bind_extensions(dri2_dpy, swrast_core_extensions, extensions))
@@ -663,11 +669,12 @@ dri2_create_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLConfig *conf,
 
    switch (dri2_ctx->base.ClientAPI) {
    case EGL_OPENGL_ES_API:
-      switch (dri2_ctx->base.ClientVersion) {
+      switch (dri2_ctx->base.ClientMajorVersion) {
       case 1:
          api = __DRI_API_GLES;
          break;
       case 2:
+      case 3:
          api = __DRI_API_GLES2;
          break;
       default:
@@ -676,7 +683,13 @@ dri2_create_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLConfig *conf,
       }
       break;
    case EGL_OPENGL_API:
-      api = __DRI_API_OPENGL;
+      if ((dri2_ctx->base.ClientMajorVersion >= 4
+           || (dri2_ctx->base.ClientMajorVersion == 3
+               && dri2_ctx->base.ClientMinorVersion >= 2))
+          && dri2_ctx->base.Profile == EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR)
+         api = __DRI_API_OPENGL_CORE;
+      else
+         api = __DRI_API_OPENGL;
       break;
    default:
       _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
@@ -706,21 +719,63 @@ dri2_create_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLConfig *conf,
       dri_config = NULL;
 
    if (dri2_dpy->dri2) {
-      if (dri2_dpy->dri2->base.version >= 2) {
+      if (dri2_dpy->dri2->base.version >= 3) {
+         unsigned error;
+         unsigned num_attribs = 0;
+         uint32_t ctx_attribs[8];
+
+         ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
+         ctx_attribs[num_attribs++] = dri2_ctx->base.ClientMajorVersion;
+         ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
+         ctx_attribs[num_attribs++] = dri2_ctx->base.ClientMinorVersion;
+
+         if (dri2_ctx->base.Flags != 0) {
+            /* If the implementation doesn't support the __DRI2_ROBUSTNESS
+             * extension, don't even try to send it the robust-access flag.
+             * It may explode.  Instead, generate the required EGL error here.
+             */
+            if ((dri2_ctx->base.Flags & EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR) != 0
+                && !dri2_dpy->robustness) {
+               _eglError(EGL_BAD_MATCH, "eglCreateContext");
+               goto cleanup;
+            }
+
+            ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_FLAGS;
+            ctx_attribs[num_attribs++] = dri2_ctx->base.Flags;
+         }
+
+         if (dri2_ctx->base.ResetNotificationStrategy != EGL_NO_RESET_NOTIFICATION_KHR) {
+            /* If the implementation doesn't support the __DRI2_ROBUSTNESS
+             * extension, don't even try to send it a reset strategy.  It may
+             * explode.  Instead, generate the required EGL error here.
+             */
+            if (!dri2_dpy->robustness) {
+               _eglError(EGL_BAD_CONFIG, "eglCreateContext");
+               goto cleanup;
+            }
+
+            ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_RESET_STRATEGY;
+            ctx_attribs[num_attribs++] = __DRI_CTX_RESET_LOSE_CONTEXT;
+         }
+
+         assert(num_attribs <= ARRAY_SIZE(ctx_attribs));
+
+	 dri2_ctx->dri_context =
+	    dri2_dpy->dri2->createContextAttribs(dri2_dpy->dri_screen,
+                                                 api,
+                                                 dri_config,
+                                                 shared,
+                                                 num_attribs / 2,
+                                                 ctx_attribs,
+                                                 & error,
+                                                 dri2_ctx);
+      } else {
 	 dri2_ctx->dri_context =
 	    dri2_dpy->dri2->createNewContextForAPI(dri2_dpy->dri_screen,
 						   api,
 						   dri_config,
                                                    shared,
 						   dri2_ctx);
-      } else if (api == __DRI_API_OPENGL) {
-	 dri2_ctx->dri_context =
-	    dri2_dpy->dri2->createNewContext(dri2_dpy->dri_screen,
-					     dri_config,
-                                             shared,
-					     dri2_ctx);
-      } else {
-	 /* fail */
       }
    } else {
       assert(dri2_dpy->swrast);
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index c30e230..81c1354 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -99,6 +99,7 @@ struct dri2_egl_display
    __DRI2flushExtension     *flush;
    __DRItexBufferExtension  *tex_buffer;
    __DRIimageExtension      *image;
+   __DRIrobustnessExtension *robustness;
    int                       fd;
 
    int                       own_device;
diff --git a/src/egl/main/eglcontext.c b/src/egl/main/eglcontext.c
index fa60749..829050d 100644
--- a/src/egl/main/eglcontext.c
+++ b/src/egl/main/eglcontext.c
@@ -49,11 +49,12 @@ _eglGetContextAPIBit(_EGLContext *ctx)
 
    switch (ctx->ClientAPI) {
    case EGL_OPENGL_ES_API:
-      switch (ctx->ClientVersion) {
+      switch (ctx->ClientMajorVersion) {
       case 1:
          bit = EGL_OPENGL_ES_BIT;
          break;
       case 2:
+      case 3:
          bit = EGL_OPENGL_ES2_BIT;
          break;
       default:
@@ -78,7 +79,8 @@ _eglGetContextAPIBit(_EGLContext *ctx)
  * Parse the list of context attributes and return the proper error code.
  */
 static EGLint
-_eglParseContextAttribList(_EGLContext *ctx, const EGLint *attrib_list)
+_eglParseContextAttribList(_EGLContext *ctx, _EGLDisplay *dpy,
+                           const EGLint *attrib_list)
 {
    EGLenum api = ctx->ClientAPI;
    EGLint i, err = EGL_SUCCESS;
@@ -86,22 +88,113 @@ _eglParseContextAttribList(_EGLContext *ctx, const EGLint *attrib_list)
    if (!attrib_list)
       return EGL_SUCCESS;
 
+   if (api == EGL_OPENVG_API && attrib_list[0] != EGL_NONE) {
+      _eglLog(_EGL_DEBUG, "bad context attribute 0x%04x", attrib_list[0]);
+      return EGL_BAD_ATTRIBUTE;
+   }
+
    for (i = 0; attrib_list[i] != EGL_NONE; i++) {
       EGLint attr = attrib_list[i++];
       EGLint val = attrib_list[i];
 
       switch (attr) {
       case EGL_CONTEXT_CLIENT_VERSION:
-         if (api != EGL_OPENGL_ES_API) {
+         ctx->ClientMajorVersion = val;
+         break;
+
+      case EGL_CONTEXT_MINOR_VERSION_KHR:
+         if (!dpy->Extensions.KHR_create_context) {
+            err = EGL_BAD_ATTRIBUTE;
+            break;
+         }
+
+         ctx->ClientMinorVersion = val;
+         break;
+
+      case EGL_CONTEXT_FLAGS_KHR:
+         if (!dpy->Extensions.KHR_create_context) {
+            err = EGL_BAD_ATTRIBUTE;
+            break;
+         }
+
+         /* The EGL_KHR_create_context spec says:
+          *
+          *     "Flags are only defined for OpenGL context creation, and
+          *     specifying a flags value other than zero for other types of
+          *     contexts, including OpenGL ES contexts, will generate an
+          *     error."
+          */
+         if (api != EGL_OPENGL_API && val != 0) {
+            err = EGL_BAD_ATTRIBUTE;
+            break;
+         }
+
+         ctx->Flags = val;
+         break;
+
+      case EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR:
+         if (!dpy->Extensions.KHR_create_context) {
             err = EGL_BAD_ATTRIBUTE;
             break;
          }
-         if (val != 1 && val != 2) {
+
+         /* The EGL_KHR_create_context spec says:
+          *
+          *     "[EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR] is only meaningful for
+          *     OpenGL contexts, and specifying it for other types of
+          *     contexts, including OpenGL ES contexts, will generate an
+          *     error."
+          */
+         if (api != EGL_OPENGL_API) {
+            err = EGL_BAD_ATTRIBUTE;
+            break;
+         }
+
+         ctx->Profile = val;
+         break;
+
+      case EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR:
+         /* The EGL_KHR_create_context spec says:
+          *
+          *     "[EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR] is only
+          *     meaningful for OpenGL contexts, and specifying it for other
+          *     types of contexts, including OpenGL ES contexts, will generate
+          *     an error."
+          */
+           if (!dpy->Extensions.KHR_create_context
+               || api != EGL_OPENGL_API) {
+            err = EGL_BAD_ATTRIBUTE;
+            break;
+         }
+
+         ctx->ResetNotificationStrategy = val;
+         break;
+
+      case EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT:
+         /* The EGL_EXT_create_context_robustness spec says:
+          *
+          *     "[EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT] is only
+          *     meaningful for OpenGL ES contexts, and specifying it for other
+          *     types of contexts will generate an EGL_BAD_ATTRIBUTE error."
+          */
+         if (!dpy->Extensions.EXT_create_context_robustness
+             || api != EGL_OPENGL_ES_API) {
+            err = EGL_BAD_ATTRIBUTE;
+            break;
+         }
+
+         ctx->ResetNotificationStrategy = val;
+         break;
+
+      case EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT:
+         if (!dpy->Extensions.EXT_create_context_robustness) {
             err = EGL_BAD_ATTRIBUTE;
             break;
          }
-         ctx->ClientVersion = val;
+
+         ctx->Flags = EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR;
          break;
+
       default:
          err = EGL_BAD_ATTRIBUTE;
          break;
@@ -113,6 +206,147 @@ _eglParseContextAttribList(_EGLContext *ctx, const EGLint *attrib_list)
       }
    }
 
+   if (api == EGL_OPENGL_API) {
+      /* The EGL_KHR_create_context spec says:
+       *
+       *     "If the requested OpenGL version is less than 3.2,
+       *     EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR is ignored and the
+       *     functionality of the context is determined solely by the
+       *     requested version."
+       *
+       * Since the value is ignored, only validate the setting if the version
+       * is >= 3.2.
+       */
+      if (ctx->ClientMajorVersion >= 4
+          || (ctx->ClientMajorVersion == 3 && ctx->ClientMinorVersion >= 2)) {
+         switch (ctx->Profile) {
+         case EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR:
+         case EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR:
+            break;
+
+         default:
+            /* The EGL_KHR_create_context spec says:
+             *
+             *     "* If an OpenGL context is requested, the requested version
+             *        is greater than 3.2, and the value for attribute
+             *        EGL_CONTEXT_PROFILE_MASK_KHR has no bits set; has any
+             *        bits set other than EGL_CONTEXT_CORE_PROFILE_BIT_KHR and
+             *        EGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_KHR; has more than
+             *        one of these bits set; or if the implementation does not
+             *        support the requested profile, then an
+             *        EGL_BAD_PROFILE_KHR error is generated."
+             *
+             * However, it does not define EGL_BAD_PROFILE_KHR.  For now use
+             * EGL_BAD_ATTRIBUTE.
+             */
+            err = EGL_BAD_ATTRIBUTE;
+            break;
+         }
+      }
+
+      /* The EGL_KHR_create_context spec says:
+       *
+       *     "* If an OpenGL context is requested and the values for
+       *        attributes EGL_CONTEXT_MAJOR_VERSION_KHR and
+       *        EGL_CONTEXT_MINOR_VERSION_KHR, when considered together with
+       *        the value for attribute
+       *        EGL_CONTEXT_FORWARD_COMPATIBLE_BIT_KHR, specify an OpenGL
+       *        version and feature set that are not defined, than an
+       *        EGL_BAD_MATCH error is generated.
+       *
+       *        ... Thus, examples of invalid combinations of attributes
+       *        include:
+       *
+       *          - Major version < 1 or > 4
+       *          - Major version == 1 and minor version < 0 or > 5
+       *          - Major version == 2 and minor version < 0 or > 1
+       *          - Major version == 3 and minor version < 0 or > 2
+       *          - Major version == 4 and minor version < 0 or > 2
+       *          - Forward-compatible flag set and major version < 3"
+       */
+      if (ctx->ClientMajorVersion < 1 || ctx->ClientMinorVersion < 0)
+         err = EGL_BAD_MATCH;
+
+      switch (ctx->ClientMajorVersion) {
+      case 1:
+         if (ctx->ClientMinorVersion > 5
+             || (ctx->Flags & EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR) != 0)
+            err = EGL_BAD_MATCH;
+         break;
+
+      case 2:
+         if (ctx->ClientMinorVersion > 1
+             || (ctx->Flags & EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR) != 0)
+            err = EGL_BAD_MATCH;
+         break;
+
+      case 3:
+         /* Note: The text above is incorrect.  There *is* an OpenGL 3.3!
+          */
+         if (ctx->ClientMinorVersion > 3)
+            err = EGL_BAD_MATCH;
+         break;
+
+      case 4:
+      default:
+         /* Don't put additional version checks here.  We don't know that
+          * there won't be versions > 4.2.
+          */
+         break;
+      }
+   } else if (api == EGL_OPENGL_ES_API) {
+      /* The EGL_KHR_create_context spec says:
+       *
+       *     "* If an OpenGL ES context is requested and the values for
+       *        attributes EGL_CONTEXT_MAJOR_VERSION_KHR and
+       *        EGL_CONTEXT_MINOR_VERSION_KHR specify an OpenGL ES version that
+       *        is not defined, than an EGL_BAD_MATCH error is generated.
+       *
+       *        ... Examples of invalid combinations of attributes include:
+       *
+       *          - Major version < 1 or > 2
+       *          - Major version == 1 and minor version < 0 or > 1
+       *          - Major version == 2 and minor version != 0
+       */
+      if (ctx->ClientMajorVersion < 1 || ctx->ClientMinorVersion < 0)
+         err = EGL_BAD_MATCH;
+
+      switch (ctx->ClientMajorVersion) {
+      case 1:
+         if (ctx->ClientMinorVersion > 1)
+            err = EGL_BAD_MATCH;
+         break;
+
+      case 2:
+         if (ctx->ClientMinorVersion > 0)
+            err = EGL_BAD_MATCH;
+         break;
+
+      case 3:
+      default:
+         /* Don't put additional version checks here.  We don't know that
+          * there won't be versions > 3.0.
+          */
+         break;
+      }
+   }
+
+   switch (ctx->ResetNotificationStrategy) {
+   case EGL_NO_RESET_NOTIFICATION_KHR:
+   case EGL_LOSE_CONTEXT_ON_RESET_KHR:
+      break;
+
+   default:
+      err = EGL_BAD_ATTRIBUTE;
+      break;
+   }
+
+   if ((ctx->Flags & (EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR
+                      | EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR
+                      | EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR)) != 0) {
+      err = EGL_BAD_ATTRIBUTE;
+   }
+
    return err;
 }
 
@@ -137,10 +371,15 @@ _eglInitContext(_EGLContext *ctx, _EGLDisplay *dpy, _EGLConfig *conf,
    ctx->ClientAPI = api;
    ctx->Config = conf;
    ctx->WindowRenderBuffer = EGL_NONE;
+   ctx->Profile = EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;
 
-   ctx->ClientVersion = 1; /* the default, per EGL spec */
+   ctx->ClientMajorVersion = 1; /* the default, per EGL spec */
+   ctx->ClientMinorVersion = 0;
+   ctx->Flags = 0;
+   ctx->Profile = EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;
+   ctx->ResetNotificationStrategy = EGL_NO_RESET_NOTIFICATION_KHR;
 
-   err = _eglParseContextAttribList(ctx, attrib_list);
+   err = _eglParseContextAttribList(ctx, dpy, attrib_list);
    if (err == EGL_SUCCESS && ctx->Config) {
       EGLint api_bit;
 
@@ -191,7 +430,7 @@ _eglQueryContext(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *c,
       *value = c->Config->ConfigID;
       break;
    case EGL_CONTEXT_CLIENT_VERSION:
-      *value = c->ClientVersion;
+      *value = c->ClientMajorVersion;
       break;
    case EGL_CONTEXT_CLIENT_TYPE:
       *value = c->ClientAPI;
diff --git a/src/egl/main/eglcontext.h b/src/egl/main/eglcontext.h
index 0ac8462..7b99ad8 100644
--- a/src/egl/main/eglcontext.h
+++ b/src/egl/main/eglcontext.h
@@ -52,7 +52,11 @@ struct _egl_context
    _EGLConfig *Config;
 
    EGLint ClientAPI; /**< EGL_OPENGL_ES_API, EGL_OPENGL_API, EGL_OPENVG_API */
-   EGLint ClientVersion; /**< 1 = OpenGLES 1.x, 2 = OpenGLES 2.x */
+   EGLint ClientMajorVersion;
+   EGLint ClientMinorVersion;
+   EGLint Flags;
+   EGLint Profile;
+   EGLint ResetNotificationStrategy;
 
    /* The real render buffer when a window surface is bound */
    EGLint WindowRenderBuffer;
diff --git a/src/egl/main/egldisplay.h b/src/egl/main/egldisplay.h
index a1dd279..ccb1fbc 100644
--- a/src/egl/main/egldisplay.h
+++ b/src/egl/main/egldisplay.h
@@ -104,6 +104,7 @@ struct _egl_extensions
    EGLBoolean KHR_fence_sync;
 
    EGLBoolean KHR_surfaceless_context;
+   EGLBoolean KHR_create_context;
 
    EGLBoolean NOK_swap_region;
    EGLBoolean NOK_texture_from_pixmap;
@@ -111,6 +112,8 @@ struct _egl_extensions
    EGLBoolean ANDROID_image_native_buffer;
 
    EGLBoolean NV_post_sub_buffer;
+
+   EGLBoolean EXT_create_context_robustness;
 };
 
 
diff --git a/src/egl/main/eglmisc.c b/src/egl/main/eglmisc.c
index b4f1e71..b7599d0 100644
--- a/src/egl/main/eglmisc.c
+++ b/src/egl/main/eglmisc.c
@@ -108,12 +108,15 @@ _eglUpdateExtensionsString(_EGLDisplay *dpy)
    _EGL_CHECK_EXTENSION(KHR_fence_sync);
 
    _EGL_CHECK_EXTENSION(KHR_surfaceless_context);
+   _EGL_CHECK_EXTENSION(KHR_create_context);
 
    _EGL_CHECK_EXTENSION(NOK_swap_region);
    _EGL_CHECK_EXTENSION(NOK_texture_from_pixmap);
 
    _EGL_CHECK_EXTENSION(ANDROID_image_native_buffer);
 
+   _EGL_CHECK_EXTENSION(EXT_create_context_robustness);
+
    _EGL_CHECK_EXTENSION(NV_post_sub_buffer);
 #undef _EGL_CHECK_EXTENSION
 }
diff --git a/src/gallium/state_trackers/egl/common/egl_g3d_api.c b/src/gallium/state_trackers/egl/common/egl_g3d_api.c
index aaf7b10..30793fa 100644
--- a/src/gallium/state_trackers/egl/common/egl_g3d_api.c
+++ b/src/gallium/state_trackers/egl/common/egl_g3d_api.c
@@ -53,7 +53,7 @@ egl_g3d_choose_st(_EGLDriver *drv, _EGLContext *ctx,
 
    switch (ctx->ClientAPI) {
    case EGL_OPENGL_ES_API:
-      switch (ctx->ClientVersion) {
+      switch (ctx->ClientMajorVersion) {
       case 1:
          api = ST_API_OPENGL;
          *profile = ST_PROFILE_OPENGL_ES1;
@@ -64,7 +64,7 @@ egl_g3d_choose_st(_EGLDriver *drv, _EGLContext *ctx,
          break;
       default:
          _eglLog(_EGL_WARNING, "unknown client version %d",
-               ctx->ClientVersion);
+               ctx->ClientMajorVersion);
          break;
       }
       break;
diff --git a/src/glsl/ast_function.cpp b/src/glsl/ast_function.cpp
index ea3282c..b56a3c7 100644
--- a/src/glsl/ast_function.cpp
+++ b/src/glsl/ast_function.cpp
@@ -275,9 +275,10 @@ generate_call(exec_list *instructions, ir_function_signature *sig,
    /* If the function call is a constant expression, don't generate any
     * instructions; just generate an ir_constant.
     *
-    * Function calls were first allowed to be constant expressions in GLSL 1.20.
+    * Function calls were first allowed to be constant expressions in GLSL
+    * 1.20 and GLSL ES 3.00.
     */
-   if (state->language_version >= 120) {
+   if (state->is_version(120, 300)) {
       ir_constant *value = sig->constant_expression_value(actual_parameters, NULL);
       if (value != NULL) {
 	 return value;
@@ -324,7 +325,8 @@ match_function_by_name(const char *name,
       goto done; /* no match */
 
    /* Is the function hidden by a variable (impossible in 1.10)? */
-   if (state->language_version != 110 && state->symbols->get_variable(name))
+   if (!state->symbols->separate_function_namespace
+       && state->symbols->get_variable(name))
       goto done; /* no match */
 
    if (f != NULL) {
@@ -1242,9 +1244,8 @@ ast_function_expression::hir(exec_list *instructions,
       }
 
       if (constructor_type->is_array()) {
-	 if (state->language_version <= 110) {
-	    _mesa_glsl_error(& loc, state,
-			     "array constructors forbidden in GLSL 1.10");
+         if (!state->check_version(120, 300, &loc,
+                                   "array constructors forbidden")) {
 	    return ir_rvalue::error_value(ctx);
 	 }
 
@@ -1367,11 +1368,11 @@ ast_function_expression::hir(exec_list *instructions,
        *    "It is an error to construct matrices from other matrices. This
        *    is reserved for future use."
        */
-      if (state->language_version == 110 && matrix_parameters > 0
-	  && constructor_type->is_matrix()) {
-	 _mesa_glsl_error(& loc, state, "cannot construct `%s' from a "
-			  "matrix in GLSL 1.10",
-			  constructor_type->name);
+      if (matrix_parameters > 0
+          && constructor_type->is_matrix()
+          && !state->check_version(120, 100, &loc,
+                                   "cannot construct `%s' from a matrix",
+                                   constructor_type->name)) {
 	 return ir_rvalue::error_value(ctx);
       }
 
diff --git a/src/glsl/ast_to_hir.cpp b/src/glsl/ast_to_hir.cpp
index 02fe66b..e44c4e8 100644
--- a/src/glsl/ast_to_hir.cpp
+++ b/src/glsl/ast_to_hir.cpp
@@ -66,7 +66,7 @@ _mesa_ast_to_hir(exec_list *instructions, struct _mesa_glsl_parse_state *state)
 {
    _mesa_glsl_initialize_variables(instructions, state);
 
-   state->symbols->language_version = state->language_version;
+   state->symbols->separate_function_namespace = state->language_version == 110;
 
    state->current_function = NULL;
 
@@ -121,7 +121,7 @@ apply_implicit_conversion(const glsl_type *to, ir_rvalue * &from,
    /* This conversion was added in GLSL 1.20.  If the compilation mode is
     * GLSL 1.10, the conversion is skipped.
     */
-   if (state->language_version < 120)
+   if (!state->is_version(120, 0))
       return false;
 
    /* From page 27 (page 33 of the PDF) of the GLSL 1.50 spec:
@@ -390,8 +390,7 @@ bit_logic_result_type(const struct glsl_type *type_a,
                       ast_operators op,
                       struct _mesa_glsl_parse_state *state, YYLTYPE *loc)
 {
-    if (state->language_version < 130) {
-       _mesa_glsl_error(loc, state, "bit operations require GLSL 1.30");
+    if (!state->check_bitwise_operations_allowed(loc)) {
        return glsl_type::error_type;
     }
 
@@ -446,10 +445,7 @@ modulus_result_type(const struct glsl_type *type_a,
 		    const struct glsl_type *type_b,
 		    struct _mesa_glsl_parse_state *state, YYLTYPE *loc)
 {
-   if (state->language_version < 130) {
-      _mesa_glsl_error(loc, state,
-                       "operator '%%' is reserved in %s",
-                       state->version_string);
+   if (!state->check_version(130, 300, loc, "operator '%%' is reserved")) {
       return glsl_type::error_type;
    }
 
@@ -553,8 +549,7 @@ shift_result_type(const struct glsl_type *type_a,
                   ast_operators op,
                   struct _mesa_glsl_parse_state *state, YYLTYPE *loc)
 {
-   if (state->language_version < 130) {
-      _mesa_glsl_error(loc, state, "bit operations require GLSL 1.30");
+   if (!state->check_bitwise_operations_allowed(loc)) {
       return glsl_type::error_type;
    }
 
@@ -694,15 +689,17 @@ do_assignment(exec_list *instructions, struct _mesa_glsl_parse_state *state,
                           lhs->variable_referenced()->name);
          error_emitted = true;
 
-      } else if (state->language_version <= 110 && lhs->type->is_array()) {
+      } else if (lhs->type->is_array() &&
+                 !state->check_version(120, 300, &lhs_loc,
+                                       "whole array assignment forbidden")) {
 	 /* From page 32 (page 38 of the PDF) of the GLSL 1.10 spec:
 	  *
 	  *    "Other binary or unary expressions, non-dereferenced
 	  *     arrays, function names, swizzles with repeated fields,
 	  *     and constants cannot be l-values."
+          *
+          * The restriction on arrays is lifted in GLSL 1.20 and GLSL ES 3.00.
 	  */
-	 _mesa_glsl_error(&lhs_loc, state, "whole array assignment is not "
-			  "allowed in GLSL 1.10 or GLSL ES 1.00.");
 	 error_emitted = true;
       } else if (!lhs->is_lvalue()) {
 	 _mesa_glsl_error(& lhs_loc, state, "non-lvalue in assignment");
@@ -1099,9 +1096,7 @@ ast_expression::hir(exec_list *instructions,
 
    case ast_lshift:
    case ast_rshift:
-       if (state->language_version < 130) {
-          _mesa_glsl_error(&loc, state, "operator %s requires GLSL 1.30",
-              operator_string(this->oper));
+       if (!state->check_bitwise_operations_allowed(&loc)) {
           error_emitted = true;
        }
 
@@ -1155,10 +1150,9 @@ ast_expression::hir(exec_list *instructions,
 	 _mesa_glsl_error(& loc, state, "operands of `%s' must have the same "
 			  "type", (this->oper == ast_equal) ? "==" : "!=");
 	 error_emitted = true;
-      } else if ((state->language_version <= 110)
-		 && (op[0]->type->is_array() || op[1]->type->is_array())) {
-	 _mesa_glsl_error(& loc, state, "array comparisons forbidden in "
-			  "GLSL 1.10");
+      } else if ((op[0]->type->is_array() || op[1]->type->is_array()) &&
+                 !state->check_version(120, 300, &loc,
+                                       "array comparisons forbidden")) {
 	 error_emitted = true;
       }
 
@@ -1185,8 +1179,7 @@ ast_expression::hir(exec_list *instructions,
    case ast_bit_not:
       op[0] = this->subexpressions[0]->hir(instructions, state);
 
-      if (state->language_version < 130) {
-	 _mesa_glsl_error(&loc, state, "bit-wise operations require GLSL 1.30");
+      if (!state->check_bitwise_operations_allowed(&loc)) {
 	 error_emitted = true;
       }
 
@@ -1424,9 +1417,10 @@ ast_expression::hir(exec_list *instructions,
        *    "The second and third expressions must be the same type, but can
        *    be of any type other than an array."
        */
-      if ((state->language_version <= 110) && type->is_array()) {
-	 _mesa_glsl_error(& loc, state, "Second and third operands of ?: "
-			  "operator must not be arrays.");
+      if (type->is_array() &&
+          !state->check_version(120, 300, &loc,
+                                "Second and third operands of ?: operator "
+                                "cannot be arrays")) {
 	 error_emitted = true;
       }
 
@@ -1660,15 +1654,18 @@ ast_expression::hir(exec_list *instructions,
           array->type->element_type()->is_sampler() &&
           const_index == NULL) {
 
-	 if (state->language_version == 100) {
-	    _mesa_glsl_warning(&loc, state,
-			       "sampler arrays indexed with non-constant "
-			       "expressions is optional in GLSL ES 1.00");
-	 } else if (state->language_version < 130) {
-	    _mesa_glsl_warning(&loc, state,
-			       "sampler arrays indexed with non-constant "
-			       "expressions is forbidden in GLSL 1.30 and "
-			       "later");
+         if (!state->is_version(130, 100)) {
+            if (state->es_shader) {
+               _mesa_glsl_warning(&loc, state,
+                                  "sampler arrays indexed with non-constant "
+                                  "expressions is optional in %s",
+                                  state->get_version_string());
+            } else {
+               _mesa_glsl_warning(&loc, state,
+                                  "sampler arrays indexed with non-constant "
+                                  "expressions will be forbidden in GLSL 1.30 and "
+                                  "later");
+            }
 	 } else {
 	    _mesa_glsl_error(&loc, state,
 			     "sampler arrays indexed with non-constant "
@@ -2273,7 +2270,7 @@ get_variable_being_redeclared(ir_variable *var, ast_declaration *decl,
        *    * gl_Color
        *    * gl_SecondaryColor
        */
-   } else if (state->language_version >= 130
+   } else if (state->is_version(130, 0)
 	      && (strcmp(var->name, "gl_FrontColor") == 0
 		  || strcmp(var->name, "gl_BackColor") == 0
 		  || strcmp(var->name, "gl_FrontSecondaryColor") == 0
@@ -2340,10 +2337,9 @@ process_initializer(ir_variable *var, ast_declaration *decl,
     *    directly by an application via API commands, or indirectly by
     *    OpenGL."
     */
-   if ((state->language_version <= 110)
-       && (var->mode == ir_var_uniform)) {
-      _mesa_glsl_error(& initializer_loc, state,
-		       "cannot initialize uniforms in GLSL 1.10");
+   if (var->mode == ir_var_uniform) {
+      state->check_version(120, 0, &initializer_loc,
+                           "cannot initialize uniforms");
    }
 
    if (var->type->is_sampler()) {
@@ -2593,23 +2589,23 @@ ast_declarator_list::hir(exec_list *instructions,
        *
        *     Local variables can only use the qualifier const."
        *
-       * This is relaxed in GLSL 1.30.  It is also relaxed by any extension
-       * that adds the 'layout' keyword.
+       * This is relaxed in GLSL 1.30 and GLSL ES 3.00.  It is also relaxed by
+       * any extension that adds the 'layout' keyword.
        */
-      if ((state->language_version < 130)
+      if (!state->is_version(130, 300)
 	  && !state->ARB_explicit_attrib_location_enable
 	  && !state->ARB_fragment_coord_conventions_enable) {
 	 if (this->type->qualifier.flags.q.out) {
 	    _mesa_glsl_error(& loc, state,
 			     "`out' qualifier in declaration of `%s' "
 			     "only valid for function parameters in %s.",
-			     decl->identifier, state->version_string);
+			     decl->identifier, state->get_version_string());
 	 }
 	 if (this->type->qualifier.flags.q.in) {
 	    _mesa_glsl_error(& loc, state,
 			     "`in' qualifier in declaration of `%s' "
 			     "only valid for function parameters in %s.",
-			     decl->identifier, state->version_string);
+			     decl->identifier, state->get_version_string());
 	 }
 	 /* FINISHME: Test for other invalid qualifiers. */
       }
@@ -2688,6 +2684,13 @@ ast_declarator_list::hir(exec_list *instructions,
 	     *    "The attribute qualifier can be used only with float,
 	     *    floating-point vectors, and matrices. Attribute variables
 	     *    cannot be declared as arrays or structures."
+             *
+             * From page 33 (page 39 of the PDF) of the GLSL ES 3.00 spec:
+             *
+             *    "Vertex shader inputs can only be float, floating-point
+             *    vectors, matrices, signed and unsigned integers and integer
+             *    vectors. Vertex shader inputs cannot be arrays or
+             *    structures."
 	     */
 	    const glsl_type *check_type = var->type->is_array()
 	       ? var->type->fields.array : var->type;
@@ -2697,7 +2700,7 @@ ast_declarator_list::hir(exec_list *instructions,
 	       break;
 	    case GLSL_TYPE_UINT:
 	    case GLSL_TYPE_INT:
-	       if (state->language_version > 120)
+	       if (state->is_version(120, 300))
 		  break;
 	       /* FALLTHROUGH */
 	    default:
@@ -2709,11 +2712,10 @@ ast_declarator_list::hir(exec_list *instructions,
 	       error_emitted = true;
 	    }
 
-	    if (!error_emitted && (state->language_version <= 130)
-		&& var->type->is_array()) {
-	       _mesa_glsl_error(& loc, state,
-				"vertex shader input / attribute cannot have "
-				"array type");
+	    if (!error_emitted && var->type->is_array() &&
+                !state->check_version(140, 0, &loc,
+                                      "vertex shader input / attribute "
+                                      "cannot have array type")) {
 	       error_emitted = true;
 	    }
 	 }
@@ -2725,8 +2727,16 @@ ast_declarator_list::hir(exec_list *instructions,
        *    "If a vertex output is a signed or unsigned integer or integer
        *    vector, then it must be qualified with the interpolation qualifier
        *    flat."
+       *
+       * From section 4.3.4 of the GLSL 3.00 ES spec:
+       *    "Fragment shader inputs that are signed or unsigned integers or
+       *    integer vectors must be qualified with the interpolation qualifier
+       *    flat."
+       *
+       * Since vertex outputs and fragment inputs must have matching
+       * qualifiers, these two requirements are equivalent.
        */
-      if (state->language_version >= 130
+      if (state->is_version(130, 300)
           && state->target == vertex_shader
           && state->current_function == NULL
           && var->type->is_integer()
@@ -2745,8 +2755,10 @@ ast_declarator_list::hir(exec_list *instructions,
        *    "interpolation qualifiers may only precede the qualifiers in,
        *    centroid in, out, or centroid out in a declaration. They do not apply
        *    to the deprecated storage qualifiers varying or centroid varying."
+       *
+       * These deprecated storage qualifiers do not exist in GLSL ES 3.00.
        */
-      if (state->language_version >= 130
+      if (state->is_version(130, 0)
           && this->type->qualifier.has_interpolation()
           && this->type->qualifier.flags.q.varying) {
 
@@ -2771,8 +2783,14 @@ ast_declarator_list::hir(exec_list *instructions,
        *    "Outputs from a vertex shader (out) and inputs to a fragment
        *    shader (in) can be further qualified with one or more of these
        *    interpolation qualifiers"
+       *
+       * From page 31 (page 37 of the PDF) of the GLSL ES 3.00 spec:
+       *    "These interpolation qualifiers may only precede the qualifiers
+       *    in, centroid in, out, or centroid out in a declaration. They do
+       *    not apply to inputs into a vertex shader or outputs from a
+       *    fragment shader."
        */
-      if (state->language_version >= 130
+      if (state->is_version(130, 300)
           && this->type->qualifier.has_interpolation()) {
 
          const char *i = this->type->qualifier.interpolation_string();
@@ -2801,8 +2819,12 @@ ast_declarator_list::hir(exec_list *instructions,
 
       /* From section 4.3.4 of the GLSL 1.30 spec:
        *    "It is an error to use centroid in in a vertex shader."
+       *
+       * From section 4.3.4 of the GLSL ES 3.00 spec:
+       *    "It is an error to use centroid in or interpolation qualifiers in
+       *    a vertex shader input."
        */
-      if (state->language_version >= 130
+      if (state->is_version(130, 300)
           && this->type->qualifier.flags.q.centroid
           && this->type->qualifier.flags.q.in
           && state->target == vertex_shader) {
@@ -2814,13 +2836,8 @@ ast_declarator_list::hir(exec_list *instructions,
 
       /* Precision qualifiers exists only in GLSL versions 1.00 and >= 1.30.
        */
-      if (this->type->specifier->precision != ast_precision_none
-          && state->language_version != 100
-          && state->language_version < 130) {
-
-         _mesa_glsl_error(&loc, state,
-                          "precision qualifiers are supported only in GLSL ES "
-                          "1.00, and GLSL 1.30 and later");
+      if (this->type->specifier->precision != ast_precision_none) {
+         state->check_precision_qualifiers_allowed(&loc);
       }
 
 
@@ -3062,8 +3079,9 @@ ast_parameter_declarator::hir(exec_list *instructions,
     * allowed.  This restriction is removed in GLSL 1.20, and in GLSL ES.
     */
    if ((var->mode == ir_var_inout || var->mode == ir_var_out)
-       && type->is_array() && state->language_version == 110) {
-      _mesa_glsl_error(&loc, state, "Arrays cannot be out or inout parameters in GLSL 1.10");
+       && type->is_array()
+       && !state->check_version(120, 100, &loc,
+                                "Arrays cannot be out or inout parameters")) {
       type = glsl_type::error_type;
    }
 
@@ -3146,7 +3164,8 @@ ast_function::hir(exec_list *instructions,
     *
     * Note that this language does not appear in GLSL 1.10.
     */
-   if ((state->current_function != NULL) && (state->language_version != 110)) {
+   if ((state->current_function != NULL) &&
+       state->is_version(120, 100)) {
       YYLTYPE loc = this->get_location();
       _mesa_glsl_error(&loc, state,
 		       "declaration of function `%s' not allowed within "
@@ -3857,11 +3876,7 @@ ast_type_specifier::hir(exec_list *instructions,
    YYLTYPE loc = this->get_location();
 
    if (this->precision != ast_precision_none
-       && state->language_version != 100
-       && state->language_version < 130) {
-      _mesa_glsl_error(&loc, state,
-                       "precision qualifiers exist only in "
-                       "GLSL ES 1.00, and GLSL 1.30 and later");
+       && !state->check_precision_qualifiers_allowed(&loc)) {
       return NULL;
    }
    if (this->precision != ast_precision_none
diff --git a/src/glsl/builtin_types.h b/src/glsl/builtin_types.h
index d75c562..c873d2a 100644
--- a/src/glsl/builtin_types.h
+++ b/src/glsl/builtin_types.h
@@ -31,6 +31,11 @@ const glsl_type glsl_type::_sampler3D_type =
    glsl_type(GL_SAMPLER_3D, GLSL_SAMPLER_DIM_3D, 0, 0, GLSL_TYPE_FLOAT,
 	     "sampler3D");
 
+const glsl_type glsl_type::_samplerCubeShadow_type =
+   glsl_type(GL_SAMPLER_CUBE_SHADOW,
+	     GLSL_SAMPLER_DIM_CUBE, 1, 0, GLSL_TYPE_FLOAT,
+             "samplerCubeShadow");
+
 const glsl_type *const glsl_type::error_type = & glsl_type::_error_type;
 const glsl_type *const glsl_type::void_type = & glsl_type::_void_type;
 
diff --git a/src/glsl/builtin_variables.cpp b/src/glsl/builtin_variables.cpp
index 03b64c9..33a8372 100644
--- a/src/glsl/builtin_variables.cpp
+++ b/src/glsl/builtin_variables.cpp
@@ -61,6 +61,17 @@ static const builtin_variable builtin_100ES_fs_variables[] = {
    { ir_var_in,  FRAG_ATTRIB_PNTC,   "vec2",   "gl_PointCoord" },
 };
 
+static const builtin_variable builtin_300ES_vs_variables[] = {
+   { ir_var_system_value,  SYSTEM_VALUE_VERTEX_ID, "int",   "gl_VertexID" },
+};
+
+static const builtin_variable builtin_300ES_fs_variables[] = {
+   { ir_var_in,  FRAG_ATTRIB_WPOS,  "vec4",  "gl_FragCoord" },
+   { ir_var_in,  FRAG_ATTRIB_FACE,  "bool",  "gl_FrontFacing" },
+   { ir_var_out, FRAG_RESULT_DEPTH, "float", "gl_FragDepth" },
+   { ir_var_in,  FRAG_ATTRIB_PNTC,   "vec2",   "gl_PointCoord" },
+};
+
 static const builtin_variable builtin_110_fs_variables[] = {
    { ir_var_out, FRAG_RESULT_DEPTH, "float", "gl_FragDepth" },
 };
@@ -499,12 +510,15 @@ add_builtin_constant(exec_list *instructions, glsl_symbol_table *symtab,
    return var;
 }
 
-/* Several constants in GLSL ES have different names than normal desktop GLSL.
+/**
+ * Uniforms that are common to all GLSL ES implementations.
+ *
+ * Several constants in GLSL ES have different names than normal desktop GLSL.
  * Therefore, this function should only be called on the ES path.
  */
 static void
-generate_100ES_uniforms(exec_list *instructions,
-		     struct _mesa_glsl_parse_state *state)
+generate_common_ES_uniforms(exec_list *instructions,
+                            struct _mesa_glsl_parse_state *state)
 {
    glsl_symbol_table *const symtab = state->symbols;
 
@@ -512,8 +526,6 @@ generate_100ES_uniforms(exec_list *instructions,
 			state->Const.MaxVertexAttribs);
    add_builtin_constant(instructions, symtab, "gl_MaxVertexUniformVectors",
 			state->Const.MaxVertexUniformComponents);
-   add_builtin_constant(instructions, symtab, "gl_MaxVaryingVectors",
-			state->Const.MaxVaryingFloats / 4);
    add_builtin_constant(instructions, symtab, "gl_MaxVertexTextureImageUnits",
 			state->Const.MaxVertexTextureImageUnits);
    add_builtin_constant(instructions, symtab, "gl_MaxCombinedTextureImageUnits",
@@ -528,6 +540,36 @@ generate_100ES_uniforms(exec_list *instructions,
 }
 
 static void
+generate_100ES_uniforms(exec_list *instructions,
+		     struct _mesa_glsl_parse_state *state)
+{
+   generate_common_ES_uniforms(instructions, state);
+
+   glsl_symbol_table *const symtab = state->symbols;
+
+   add_builtin_constant(instructions, symtab, "gl_MaxVaryingVectors",
+			state->Const.MaxVaryingFloats / 4);
+}
+
+static void
+generate_300ES_uniforms(exec_list *instructions,
+                        struct _mesa_glsl_parse_state *state)
+{
+   generate_common_ES_uniforms(instructions, state);
+
+   glsl_symbol_table *const symtab = state->symbols;
+
+   add_builtin_constant(instructions, symtab, "gl_MaxVertexOutputVectors",
+			state->Const.MaxVaryingFloats / 4);
+   add_builtin_constant(instructions, symtab, "gl_MaxFrabmentInputVectors",
+			state->Const.MaxVaryingFloats / 4);
+   add_builtin_constant(instructions, symtab, "gl_MinProgramTexelOffset",
+                        state->Const.MinProgramTexelOffset);
+   add_builtin_constant(instructions, symtab, "gl_MaxProgramTexelOffset",
+                        state->Const.MaxProgramTexelOffset);
+}
+
+static void
 generate_110_uniforms(exec_list *instructions,
 		      struct _mesa_glsl_parse_state *state,
 		      bool add_deprecated)
@@ -657,6 +699,26 @@ generate_100ES_vs_variables(exec_list *instructions,
 				       vertex_shader);
 }
 
+static void
+generate_300ES_vs_variables(exec_list *instructions,
+                            struct _mesa_glsl_parse_state *state)
+{
+   for (unsigned i = 0; i < Elements(builtin_core_vs_variables); i++) {
+      add_builtin_variable(instructions, state->symbols,
+			   & builtin_core_vs_variables[i]);
+   }
+
+   for (unsigned i = 0; i < Elements(builtin_300ES_vs_variables); i++) {
+      add_builtin_variable(instructions, state->symbols,
+			   & builtin_300ES_vs_variables[i]);
+   }
+
+   generate_300ES_uniforms(instructions, state);
+
+   generate_ARB_draw_buffers_variables(instructions, state, false,
+				       vertex_shader);
+}
+
 
 static void
 generate_110_vs_variables(exec_list *instructions,
@@ -760,23 +822,36 @@ static void
 initialize_vs_variables(exec_list *instructions,
 			struct _mesa_glsl_parse_state *state)
 {
-
-   switch (state->language_version) {
-   case 100:
-      generate_100ES_vs_variables(instructions, state);
-      break;
-   case 110:
-      generate_110_vs_variables(instructions, state, true);
-      break;
-   case 120:
-      generate_120_vs_variables(instructions, state, true);
-      break;
-   case 130:
-      generate_130_vs_variables(instructions, state, true);
-      break;
-   case 140:
-      generate_130_vs_variables(instructions, state, false);
-      break;
+   if (state->es_shader) {
+      switch (state->language_version) {
+      case 100:
+         generate_100ES_vs_variables(instructions, state);
+         break;
+      case 300:
+         generate_300ES_vs_variables(instructions, state);
+         break;
+      default:
+         assert(!"Unexpected language version");
+         break;
+      }
+   } else {
+      switch (state->language_version) {
+      case 110:
+         generate_110_vs_variables(instructions, state, true);
+         break;
+      case 120:
+         generate_120_vs_variables(instructions, state, true);
+         break;
+      case 130:
+         generate_130_vs_variables(instructions, state, true);
+         break;
+      case 140:
+         generate_130_vs_variables(instructions, state, false);
+         break;
+      default:
+         assert(!"Unexpected language version");
+         break;
+      }
    }
 
    generate_ARB_draw_instanced_variables(instructions, state, false,
@@ -806,6 +881,25 @@ generate_100ES_fs_variables(exec_list *instructions,
 }
 
 static void
+generate_300ES_fs_variables(exec_list *instructions,
+			  struct _mesa_glsl_parse_state *state)
+{
+   /* Note: we don't add builtin_core_fs_variables, because it contains
+    * gl_FragColor, which is not in GLSL 3.00 ES.
+    */
+
+   for (unsigned i = 0; i < Elements(builtin_300ES_fs_variables); i++) {
+      add_builtin_variable(instructions, state->symbols,
+			   & builtin_300ES_fs_variables[i]);
+   }
+
+   generate_300ES_uniforms(instructions, state);
+
+   generate_ARB_draw_buffers_variables(instructions, state, false,
+				       fragment_shader);
+}
+
+static void
 generate_110_fs_variables(exec_list *instructions,
 			  struct _mesa_glsl_parse_state *state,
 			  bool add_deprecated)
@@ -865,8 +959,9 @@ generate_ARB_draw_buffers_variables(exec_list *instructions,
       mdb->warn_extension = "GL_ARB_draw_buffers";
 
    /* gl_FragData is only available in the fragment shader.
+    * It is not present in GLSL 3.00 ES.
     */
-   if (target == fragment_shader) {
+   if (target == fragment_shader && !state->is_version(0, 300)) {
       const glsl_type *const vec4_array_type =
 	 glsl_type::get_array_instance(glsl_type::vec4_type,
 				       state->Const.MaxDrawBuffers);
@@ -903,7 +998,8 @@ generate_ARB_draw_instanced_variables(exec_list *instructions,
          inst->warn_extension = "GL_ARB_draw_instanced";
    }
 
-   if (state->ARB_draw_instanced_enable || state->language_version >= 140) {
+   bool available_in_core = state->is_version(140, 300);
+   if (state->ARB_draw_instanced_enable || available_in_core) {
       /* Originally ARB_draw_instanced only specified that ARB decorated name.
        * Since no vendor actually implemented that behavior and some apps use
        * the undecorated name, the extension now specifies that both names are
@@ -914,7 +1010,7 @@ generate_ARB_draw_instanced_variables(exec_list *instructions,
 		      "gl_InstanceID", glsl_type::int_type,
 		      ir_var_system_value, SYSTEM_VALUE_INSTANCE_ID);
 
-      if (state->language_version < 140 && warn)
+      if (!available_in_core && warn)
          inst->warn_extension = "GL_ARB_draw_instanced";
    }
 }
@@ -1016,23 +1112,36 @@ static void
 initialize_fs_variables(exec_list *instructions,
 			struct _mesa_glsl_parse_state *state)
 {
-
-   switch (state->language_version) {
-   case 100:
-      generate_100ES_fs_variables(instructions, state);
-      break;
-   case 110:
-      generate_110_fs_variables(instructions, state, true);
-      break;
-   case 120:
-      generate_120_fs_variables(instructions, state, true);
-      break;
-   case 130:
-      generate_130_fs_variables(instructions, state);
-      break;
-   case 140:
-      generate_140_fs_variables(instructions, state);
-      break;
+   if (state->es_shader) {
+      switch (state->language_version) {
+      case 100:
+         generate_100ES_fs_variables(instructions, state);
+         break;
+      case 300:
+         generate_300ES_fs_variables(instructions, state);
+         break;
+      default:
+         assert(!"Unexpected language version");
+         break;
+      }
+   } else {
+      switch (state->language_version) {
+      case 110:
+         generate_110_fs_variables(instructions, state, true);
+         break;
+      case 120:
+         generate_120_fs_variables(instructions, state, true);
+         break;
+      case 130:
+         generate_130_fs_variables(instructions, state);
+         break;
+      case 140:
+         generate_140_fs_variables(instructions, state);
+         break;
+      default:
+         assert(!"Unexpected language version");
+         break;
+      }
    }
 
    if (state->ARB_shader_stencil_export_enable)
diff --git a/src/glsl/builtins/glsl/determinant.glsl b/src/glsl/builtins/glsl/determinant.glsl
new file mode 100644
index 0000000..32695a8
--- /dev/null
+++ b/src/glsl/builtins/glsl/determinant.glsl
@@ -0,0 +1,70 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#version 120
+float determinant(mat2 m)
+{
+   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
+}
+
+float determinant(mat3 m)
+{
+   return (+ m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
+           - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
+           + m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]));
+}
+
+float determinant(mat4 m)
+{
+   float SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
+   float SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
+   float SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
+   float SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
+   float SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
+   float SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
+   float SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
+   float SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
+   float SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
+   float SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
+   float SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
+   float SubFactor11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
+   float SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
+   float SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
+   float SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
+   float SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
+   float SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
+   float SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
+   float SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];
+
+   vec4 adj_0;
+
+   adj_0[0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);
+   adj_0[1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);
+   adj_0[2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);
+   adj_0[3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);
+
+   return (+ m[0][0] * adj_0[0]
+           + m[0][1] * adj_0[1]
+           + m[0][2] * adj_0[2]
+           + m[0][3] * adj_0[3]);
+}
diff --git a/src/glsl/builtins/profiles/100.frag b/src/glsl/builtins/profiles/100.frag
deleted file mode 100644
index 904aa30..0000000
--- a/src/glsl/builtins/profiles/100.frag
+++ /dev/null
@@ -1,6 +0,0 @@
-#version 100
-vec4 texture2D       (sampler2D sampler, vec2 coord, float bias);
-vec4 texture2DProj   (sampler2D sampler, vec3 coord, float bias);
-vec4 texture2DProj   (sampler2D sampler, vec4 coord, float bias);
-
-vec4 textureCube     (samplerCube sampler, vec3 coord, float bias);
diff --git a/src/glsl/builtins/profiles/100.glsl b/src/glsl/builtins/profiles/100.glsl
deleted file mode 100644
index 0d60a7f..0000000
--- a/src/glsl/builtins/profiles/100.glsl
+++ /dev/null
@@ -1,296 +0,0 @@
-#version 100
-/*
- * 8.1 - Angle and Trigonometry Functions
- */
-float radians(float degrees);
-vec2  radians(vec2  degrees);
-vec3  radians(vec3  degrees);
-vec4  radians(vec4  degrees);
-
-float degrees(float radians);
-vec2  degrees(vec2  radians);
-vec3  degrees(vec3  radians);
-vec4  degrees(vec4  radians);
-
-float sin(float angle);
-vec2  sin(vec2  angle);
-vec3  sin(vec3  angle);
-vec4  sin(vec4  angle);
-
-float cos(float angle);
-vec2  cos(vec2  angle);
-vec3  cos(vec3  angle);
-vec4  cos(vec4  angle);
-
-float tan(float angle);
-vec2  tan(vec2  angle);
-vec3  tan(vec3  angle);
-vec4  tan(vec4  angle);
-
-float asin(float angle);
-vec2  asin(vec2  angle);
-vec3  asin(vec3  angle);
-vec4  asin(vec4  angle);
-
-float acos(float angle);
-vec2  acos(vec2  angle);
-vec3  acos(vec3  angle);
-vec4  acos(vec4  angle);
-
-float atan(float y, float x);
-vec2  atan(vec2  y, vec2  x);
-vec3  atan(vec3  y, vec3  x);
-vec4  atan(vec4  y, vec4  x);
-
-float atan(float y_over_x);
-vec2  atan(vec2  y_over_x);
-vec3  atan(vec3  y_over_x);
-vec4  atan(vec4  y_over_x);
-
-/*
- * 8.2 - Exponential Functions
- */
-float pow(float x, float y);
-vec2  pow(vec2  x, vec2  y);
-vec3  pow(vec3  x, vec3  y);
-vec4  pow(vec4  x, vec4  y);
-
-float exp(float x);
-vec2  exp(vec2  x);
-vec3  exp(vec3  x);
-vec4  exp(vec4  x);
-
-float log(float x);
-vec2  log(vec2  x);
-vec3  log(vec3  x);
-vec4  log(vec4  x);
-
-float exp2(float x);
-vec2  exp2(vec2  x);
-vec3  exp2(vec3  x);
-vec4  exp2(vec4  x);
-
-float log2(float x);
-vec2  log2(vec2  x);
-vec3  log2(vec3  x);
-vec4  log2(vec4  x);
-
-float sqrt(float x);
-vec2  sqrt(vec2  x);
-vec3  sqrt(vec3  x);
-vec4  sqrt(vec4  x);
-
-float inversesqrt(float x);
-vec2  inversesqrt(vec2  x);
-vec3  inversesqrt(vec3  x);
-vec4  inversesqrt(vec4  x);
-
-/*
- * 8.3 - Common Functions
- */
-float abs(float x);
-vec2  abs(vec2  x);
-vec3  abs(vec3  x);
-vec4  abs(vec4  x);
-
-float sign(float x);
-vec2  sign(vec2  x);
-vec3  sign(vec3  x);
-vec4  sign(vec4  x);
-
-float floor(float x);
-vec2  floor(vec2  x);
-vec3  floor(vec3  x);
-vec4  floor(vec4  x);
-
-float ceil(float x);
-vec2  ceil(vec2  x);
-vec3  ceil(vec3  x);
-vec4  ceil(vec4  x);
-
-float fract(float x);
-vec2  fract(vec2  x);
-vec3  fract(vec3  x);
-vec4  fract(vec4  x);
-
-float mod(float x, float y);
-vec2  mod(vec2  x, float y);
-vec3  mod(vec3  x, float y);
-vec4  mod(vec4  x, float y);
-
-vec2  mod(vec2  x, vec2  y);
-vec3  mod(vec3  x, vec3  y);
-vec4  mod(vec4  x, vec4  y);
-
-float min(float x, float y);
-vec2  min(vec2  x, vec2  y);
-vec3  min(vec3  x, vec3  y);
-vec4  min(vec4  x, vec4  y);
-
-vec2  min(vec2  x, float y);
-vec3  min(vec3  x, float y);
-vec4  min(vec4  x, float y);
-
-float max(float x, float y);
-vec2  max(vec2  x, vec2  y);
-vec3  max(vec3  x, vec3  y);
-vec4  max(vec4  x, vec4  y);
-
-vec2  max(vec2  x, float y);
-vec3  max(vec3  x, float y);
-vec4  max(vec4  x, float y);
-
-float clamp(float x, float minVal, float maxVal);
-vec2  clamp(vec2  x, vec2  minVal, vec2  maxVal);
-vec3  clamp(vec3  x, vec3  minVal, vec3  maxVal);
-vec4  clamp(vec4  x, vec4  minVal, vec4  maxVal);
-
-vec2  clamp(vec2  x, float minVal, float maxVal);
-vec3  clamp(vec3  x, float minVal, float maxVal);
-vec4  clamp(vec4  x, float minVal, float maxVal);
-
-float mix(float x, float y, float a);
-vec2  mix(vec2  x, vec2  y, vec2  a);
-vec3  mix(vec3  x, vec3  y, vec3  a);
-vec4  mix(vec4  x, vec4  y, vec4  a);
-
-vec2  mix(vec2  x, vec2  y, float a);
-vec3  mix(vec3  x, vec3  y, float a);
-vec4  mix(vec4  x, vec4  y, float a);
-
-float step(float edge, float x);
-vec2  step(vec2  edge, vec2  x);
-vec3  step(vec3  edge, vec3  x);
-vec4  step(vec4  edge, vec4  x);
-
-vec2  step(float edge, vec2  x);
-vec3  step(float edge, vec3  x);
-vec4  step(float edge, vec4  x);
-
-float smoothstep(float edge0, float edge1, float x);
-vec2  smoothstep(vec2  edge0, vec2  edge1, vec2  x);
-vec3  smoothstep(vec3  edge0, vec3  edge1, vec3  x);
-vec4  smoothstep(vec4  edge0, vec4  edge1, vec4  x);
-
-vec2  smoothstep(float edge0, float edge1, vec2  x);
-vec3  smoothstep(float edge0, float edge1, vec3  x);
-vec4  smoothstep(float edge0, float edge1, vec4  x);
-
-/*
- * 8.4 - Geometric Functions
- */
-float length(float x);
-float length(vec2  x);
-float length(vec3  x);
-float length(vec4  x);
-
-float distance(float p0, float p1);
-float distance(vec2  p0, vec2  p1);
-float distance(vec3  p0, vec3  p1);
-float distance(vec4  p0, vec4  p1);
-
-float dot(float x, float y);
-float dot(vec2  x, vec2  y);
-float dot(vec3  x, vec3  y);
-float dot(vec4  x, vec4  y);
-
-vec3 cross(vec3 x, vec3 y);
-
-float normalize(float x);
-vec2  normalize(vec2  x);
-vec3  normalize(vec3  x);
-vec4  normalize(vec4  x);
-
-float faceforward(float N, float I, float Nref);
-vec2  faceforward(vec2  N, vec2  I, vec2  Nref);
-vec3  faceforward(vec3  N, vec3  I, vec3  Nref);
-vec4  faceforward(vec4  N, vec4  I, vec4  Nref);
-
-float reflect(float I, float N);
-vec2  reflect(vec2  I, vec2  N);
-vec3  reflect(vec3  I, vec3  N);
-vec4  reflect(vec4  I, vec4  N);
-
-float refract(float I, float N, float eta);
-vec2  refract(vec2  I, vec2  N, float eta);
-vec3  refract(vec3  I, vec3  N, float eta);
-vec4  refract(vec4  I, vec4  N, float eta);
-
-/*
- * 8.5 - Matrix Functions
- */
-mat2 matrixCompMult(mat2 x, mat2 y);
-mat3 matrixCompMult(mat3 x, mat3 y);
-mat4 matrixCompMult(mat4 x, mat4 y);
-
-/*
- * 8.6 - Vector Relational Functions
- */
-bvec2 lessThan( vec2 x,  vec2 y);
-bvec3 lessThan( vec3 x,  vec3 y);
-bvec4 lessThan( vec4 x,  vec4 y);
-bvec2 lessThan(ivec2 x, ivec2 y);
-bvec3 lessThan(ivec3 x, ivec3 y);
-bvec4 lessThan(ivec4 x, ivec4 y);
-
-bvec2 lessThanEqual( vec2 x,  vec2 y);
-bvec3 lessThanEqual( vec3 x,  vec3 y);
-bvec4 lessThanEqual( vec4 x,  vec4 y);
-bvec2 lessThanEqual(ivec2 x, ivec2 y);
-bvec3 lessThanEqual(ivec3 x, ivec3 y);
-bvec4 lessThanEqual(ivec4 x, ivec4 y);
-
-bvec2 greaterThan( vec2 x,  vec2 y);
-bvec3 greaterThan( vec3 x,  vec3 y);
-bvec4 greaterThan( vec4 x,  vec4 y);
-bvec2 greaterThan(ivec2 x, ivec2 y);
-bvec3 greaterThan(ivec3 x, ivec3 y);
-bvec4 greaterThan(ivec4 x, ivec4 y);
-
-bvec2 greaterThanEqual( vec2 x,  vec2 y);
-bvec3 greaterThanEqual( vec3 x,  vec3 y);
-bvec4 greaterThanEqual( vec4 x,  vec4 y);
-bvec2 greaterThanEqual(ivec2 x, ivec2 y);
-bvec3 greaterThanEqual(ivec3 x, ivec3 y);
-bvec4 greaterThanEqual(ivec4 x, ivec4 y);
-
-bvec2 equal( vec2 x,  vec2 y);
-bvec3 equal( vec3 x,  vec3 y);
-bvec4 equal( vec4 x,  vec4 y);
-bvec2 equal(ivec2 x, ivec2 y);
-bvec3 equal(ivec3 x, ivec3 y);
-bvec4 equal(ivec4 x, ivec4 y);
-bvec2 equal(bvec2 x, bvec2 y);
-bvec3 equal(bvec3 x, bvec3 y);
-bvec4 equal(bvec4 x, bvec4 y);
-
-bvec2 notEqual( vec2 x,  vec2 y);
-bvec3 notEqual( vec3 x,  vec3 y);
-bvec4 notEqual( vec4 x,  vec4 y);
-bvec2 notEqual(ivec2 x, ivec2 y);
-bvec3 notEqual(ivec3 x, ivec3 y);
-bvec4 notEqual(ivec4 x, ivec4 y);
-bvec2 notEqual(bvec2 x, bvec2 y);
-bvec3 notEqual(bvec3 x, bvec3 y);
-bvec4 notEqual(bvec4 x, bvec4 y);
-
-bool any(bvec2 x);
-bool any(bvec3 x);
-bool any(bvec4 x);
-
-bool all(bvec2 x);
-bool all(bvec3 x);
-bool all(bvec4 x);
-
-bvec2 not(bvec2 x);
-bvec3 not(bvec3 x);
-bvec4 not(bvec4 x);
-
-/*
- * 8.7 - Texture Lookup Functions
- */
-vec4 texture2D       (sampler2D sampler, vec2 coord);
-vec4 texture2DProj   (sampler2D sampler, vec3 coord);
-vec4 texture2DProj   (sampler2D sampler, vec4 coord);
-
-vec4 textureCube     (samplerCube sampler, vec3 coord);
diff --git a/src/glsl/builtins/profiles/100.vert b/src/glsl/builtins/profiles/100.vert
deleted file mode 100644
index 8f7ea61..0000000
--- a/src/glsl/builtins/profiles/100.vert
+++ /dev/null
@@ -1,6 +0,0 @@
-#version 100
-vec4 texture2DLod    (sampler2D sampler, vec2 coord, float lod);
-vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);
-vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);
-
-vec4 textureCubeLod  (samplerCube sampler, vec3 coord, float lod);
diff --git a/src/glsl/builtins/profiles/100es.frag b/src/glsl/builtins/profiles/100es.frag
new file mode 100644
index 0000000..904aa30
--- /dev/null
+++ b/src/glsl/builtins/profiles/100es.frag
@@ -0,0 +1,6 @@
+#version 100
+vec4 texture2D       (sampler2D sampler, vec2 coord, float bias);
+vec4 texture2DProj   (sampler2D sampler, vec3 coord, float bias);
+vec4 texture2DProj   (sampler2D sampler, vec4 coord, float bias);
+
+vec4 textureCube     (samplerCube sampler, vec3 coord, float bias);
diff --git a/src/glsl/builtins/profiles/100es.glsl b/src/glsl/builtins/profiles/100es.glsl
new file mode 100644
index 0000000..0d60a7f
--- /dev/null
+++ b/src/glsl/builtins/profiles/100es.glsl
@@ -0,0 +1,296 @@
+#version 100
+/*
+ * 8.1 - Angle and Trigonometry Functions
+ */
+float radians(float degrees);
+vec2  radians(vec2  degrees);
+vec3  radians(vec3  degrees);
+vec4  radians(vec4  degrees);
+
+float degrees(float radians);
+vec2  degrees(vec2  radians);
+vec3  degrees(vec3  radians);
+vec4  degrees(vec4  radians);
+
+float sin(float angle);
+vec2  sin(vec2  angle);
+vec3  sin(vec3  angle);
+vec4  sin(vec4  angle);
+
+float cos(float angle);
+vec2  cos(vec2  angle);
+vec3  cos(vec3  angle);
+vec4  cos(vec4  angle);
+
+float tan(float angle);
+vec2  tan(vec2  angle);
+vec3  tan(vec3  angle);
+vec4  tan(vec4  angle);
+
+float asin(float angle);
+vec2  asin(vec2  angle);
+vec3  asin(vec3  angle);
+vec4  asin(vec4  angle);
+
+float acos(float angle);
+vec2  acos(vec2  angle);
+vec3  acos(vec3  angle);
+vec4  acos(vec4  angle);
+
+float atan(float y, float x);
+vec2  atan(vec2  y, vec2  x);
+vec3  atan(vec3  y, vec3  x);
+vec4  atan(vec4  y, vec4  x);
+
+float atan(float y_over_x);
+vec2  atan(vec2  y_over_x);
+vec3  atan(vec3  y_over_x);
+vec4  atan(vec4  y_over_x);
+
+/*
+ * 8.2 - Exponential Functions
+ */
+float pow(float x, float y);
+vec2  pow(vec2  x, vec2  y);
+vec3  pow(vec3  x, vec3  y);
+vec4  pow(vec4  x, vec4  y);
+
+float exp(float x);
+vec2  exp(vec2  x);
+vec3  exp(vec3  x);
+vec4  exp(vec4  x);
+
+float log(float x);
+vec2  log(vec2  x);
+vec3  log(vec3  x);
+vec4  log(vec4  x);
+
+float exp2(float x);
+vec2  exp2(vec2  x);
+vec3  exp2(vec3  x);
+vec4  exp2(vec4  x);
+
+float log2(float x);
+vec2  log2(vec2  x);
+vec3  log2(vec3  x);
+vec4  log2(vec4  x);
+
+float sqrt(float x);
+vec2  sqrt(vec2  x);
+vec3  sqrt(vec3  x);
+vec4  sqrt(vec4  x);
+
+float inversesqrt(float x);
+vec2  inversesqrt(vec2  x);
+vec3  inversesqrt(vec3  x);
+vec4  inversesqrt(vec4  x);
+
+/*
+ * 8.3 - Common Functions
+ */
+float abs(float x);
+vec2  abs(vec2  x);
+vec3  abs(vec3  x);
+vec4  abs(vec4  x);
+
+float sign(float x);
+vec2  sign(vec2  x);
+vec3  sign(vec3  x);
+vec4  sign(vec4  x);
+
+float floor(float x);
+vec2  floor(vec2  x);
+vec3  floor(vec3  x);
+vec4  floor(vec4  x);
+
+float ceil(float x);
+vec2  ceil(vec2  x);
+vec3  ceil(vec3  x);
+vec4  ceil(vec4  x);
+
+float fract(float x);
+vec2  fract(vec2  x);
+vec3  fract(vec3  x);
+vec4  fract(vec4  x);
+
+float mod(float x, float y);
+vec2  mod(vec2  x, float y);
+vec3  mod(vec3  x, float y);
+vec4  mod(vec4  x, float y);
+
+vec2  mod(vec2  x, vec2  y);
+vec3  mod(vec3  x, vec3  y);
+vec4  mod(vec4  x, vec4  y);
+
+float min(float x, float y);
+vec2  min(vec2  x, vec2  y);
+vec3  min(vec3  x, vec3  y);
+vec4  min(vec4  x, vec4  y);
+
+vec2  min(vec2  x, float y);
+vec3  min(vec3  x, float y);
+vec4  min(vec4  x, float y);
+
+float max(float x, float y);
+vec2  max(vec2  x, vec2  y);
+vec3  max(vec3  x, vec3  y);
+vec4  max(vec4  x, vec4  y);
+
+vec2  max(vec2  x, float y);
+vec3  max(vec3  x, float y);
+vec4  max(vec4  x, float y);
+
+float clamp(float x, float minVal, float maxVal);
+vec2  clamp(vec2  x, vec2  minVal, vec2  maxVal);
+vec3  clamp(vec3  x, vec3  minVal, vec3  maxVal);
+vec4  clamp(vec4  x, vec4  minVal, vec4  maxVal);
+
+vec2  clamp(vec2  x, float minVal, float maxVal);
+vec3  clamp(vec3  x, float minVal, float maxVal);
+vec4  clamp(vec4  x, float minVal, float maxVal);
+
+float mix(float x, float y, float a);
+vec2  mix(vec2  x, vec2  y, vec2  a);
+vec3  mix(vec3  x, vec3  y, vec3  a);
+vec4  mix(vec4  x, vec4  y, vec4  a);
+
+vec2  mix(vec2  x, vec2  y, float a);
+vec3  mix(vec3  x, vec3  y, float a);
+vec4  mix(vec4  x, vec4  y, float a);
+
+float step(float edge, float x);
+vec2  step(vec2  edge, vec2  x);
+vec3  step(vec3  edge, vec3  x);
+vec4  step(vec4  edge, vec4  x);
+
+vec2  step(float edge, vec2  x);
+vec3  step(float edge, vec3  x);
+vec4  step(float edge, vec4  x);
+
+float smoothstep(float edge0, float edge1, float x);
+vec2  smoothstep(vec2  edge0, vec2  edge1, vec2  x);
+vec3  smoothstep(vec3  edge0, vec3  edge1, vec3  x);
+vec4  smoothstep(vec4  edge0, vec4  edge1, vec4  x);
+
+vec2  smoothstep(float edge0, float edge1, vec2  x);
+vec3  smoothstep(float edge0, float edge1, vec3  x);
+vec4  smoothstep(float edge0, float edge1, vec4  x);
+
+/*
+ * 8.4 - Geometric Functions
+ */
+float length(float x);
+float length(vec2  x);
+float length(vec3  x);
+float length(vec4  x);
+
+float distance(float p0, float p1);
+float distance(vec2  p0, vec2  p1);
+float distance(vec3  p0, vec3  p1);
+float distance(vec4  p0, vec4  p1);
+
+float dot(float x, float y);
+float dot(vec2  x, vec2  y);
+float dot(vec3  x, vec3  y);
+float dot(vec4  x, vec4  y);
+
+vec3 cross(vec3 x, vec3 y);
+
+float normalize(float x);
+vec2  normalize(vec2  x);
+vec3  normalize(vec3  x);
+vec4  normalize(vec4  x);
+
+float faceforward(float N, float I, float Nref);
+vec2  faceforward(vec2  N, vec2  I, vec2  Nref);
+vec3  faceforward(vec3  N, vec3  I, vec3  Nref);
+vec4  faceforward(vec4  N, vec4  I, vec4  Nref);
+
+float reflect(float I, float N);
+vec2  reflect(vec2  I, vec2  N);
+vec3  reflect(vec3  I, vec3  N);
+vec4  reflect(vec4  I, vec4  N);
+
+float refract(float I, float N, float eta);
+vec2  refract(vec2  I, vec2  N, float eta);
+vec3  refract(vec3  I, vec3  N, float eta);
+vec4  refract(vec4  I, vec4  N, float eta);
+
+/*
+ * 8.5 - Matrix Functions
+ */
+mat2 matrixCompMult(mat2 x, mat2 y);
+mat3 matrixCompMult(mat3 x, mat3 y);
+mat4 matrixCompMult(mat4 x, mat4 y);
+
+/*
+ * 8.6 - Vector Relational Functions
+ */
+bvec2 lessThan( vec2 x,  vec2 y);
+bvec3 lessThan( vec3 x,  vec3 y);
+bvec4 lessThan( vec4 x,  vec4 y);
+bvec2 lessThan(ivec2 x, ivec2 y);
+bvec3 lessThan(ivec3 x, ivec3 y);
+bvec4 lessThan(ivec4 x, ivec4 y);
+
+bvec2 lessThanEqual( vec2 x,  vec2 y);
+bvec3 lessThanEqual( vec3 x,  vec3 y);
+bvec4 lessThanEqual( vec4 x,  vec4 y);
+bvec2 lessThanEqual(ivec2 x, ivec2 y);
+bvec3 lessThanEqual(ivec3 x, ivec3 y);
+bvec4 lessThanEqual(ivec4 x, ivec4 y);
+
+bvec2 greaterThan( vec2 x,  vec2 y);
+bvec3 greaterThan( vec3 x,  vec3 y);
+bvec4 greaterThan( vec4 x,  vec4 y);
+bvec2 greaterThan(ivec2 x, ivec2 y);
+bvec3 greaterThan(ivec3 x, ivec3 y);
+bvec4 greaterThan(ivec4 x, ivec4 y);
+
+bvec2 greaterThanEqual( vec2 x,  vec2 y);
+bvec3 greaterThanEqual( vec3 x,  vec3 y);
+bvec4 greaterThanEqual( vec4 x,  vec4 y);
+bvec2 greaterThanEqual(ivec2 x, ivec2 y);
+bvec3 greaterThanEqual(ivec3 x, ivec3 y);
+bvec4 greaterThanEqual(ivec4 x, ivec4 y);
+
+bvec2 equal( vec2 x,  vec2 y);
+bvec3 equal( vec3 x,  vec3 y);
+bvec4 equal( vec4 x,  vec4 y);
+bvec2 equal(ivec2 x, ivec2 y);
+bvec3 equal(ivec3 x, ivec3 y);
+bvec4 equal(ivec4 x, ivec4 y);
+bvec2 equal(bvec2 x, bvec2 y);
+bvec3 equal(bvec3 x, bvec3 y);
+bvec4 equal(bvec4 x, bvec4 y);
+
+bvec2 notEqual( vec2 x,  vec2 y);
+bvec3 notEqual( vec3 x,  vec3 y);
+bvec4 notEqual( vec4 x,  vec4 y);
+bvec2 notEqual(ivec2 x, ivec2 y);
+bvec3 notEqual(ivec3 x, ivec3 y);
+bvec4 notEqual(ivec4 x, ivec4 y);
+bvec2 notEqual(bvec2 x, bvec2 y);
+bvec3 notEqual(bvec3 x, bvec3 y);
+bvec4 notEqual(bvec4 x, bvec4 y);
+
+bool any(bvec2 x);
+bool any(bvec3 x);
+bool any(bvec4 x);
+
+bool all(bvec2 x);
+bool all(bvec3 x);
+bool all(bvec4 x);
+
+bvec2 not(bvec2 x);
+bvec3 not(bvec3 x);
+bvec4 not(bvec4 x);
+
+/*
+ * 8.7 - Texture Lookup Functions
+ */
+vec4 texture2D       (sampler2D sampler, vec2 coord);
+vec4 texture2DProj   (sampler2D sampler, vec3 coord);
+vec4 texture2DProj   (sampler2D sampler, vec4 coord);
+
+vec4 textureCube     (samplerCube sampler, vec3 coord);
diff --git a/src/glsl/builtins/profiles/100es.vert b/src/glsl/builtins/profiles/100es.vert
new file mode 100644
index 0000000..8f7ea61
--- /dev/null
+++ b/src/glsl/builtins/profiles/100es.vert
@@ -0,0 +1,6 @@
+#version 100
+vec4 texture2DLod    (sampler2D sampler, vec2 coord, float lod);
+vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);
+vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);
+
+vec4 textureCubeLod  (samplerCube sampler, vec3 coord, float lod);
diff --git a/src/glsl/builtins/profiles/300es.frag b/src/glsl/builtins/profiles/300es.frag
new file mode 100644
index 0000000..38589f7
--- /dev/null
+++ b/src/glsl/builtins/profiles/300es.frag
@@ -0,0 +1,84 @@
+#version 300 es
+
+/* texture - bias variants */
+ vec4 texture( sampler2D sampler, vec2 P, float bias);
+ivec4 texture(isampler2D sampler, vec2 P, float bias);
+uvec4 texture(usampler2D sampler, vec2 P, float bias);
+
+ vec4 texture( sampler3D sampler, vec3 P, float bias);
+ivec4 texture(isampler3D sampler, vec3 P, float bias);
+uvec4 texture(usampler3D sampler, vec3 P, float bias);
+
+ vec4 texture( samplerCube sampler, vec3 P, float bias);
+ivec4 texture(isamplerCube sampler, vec3 P, float bias);
+uvec4 texture(usamplerCube sampler, vec3 P, float bias);
+
+float texture(sampler2DShadow   sampler, vec3 P, float bias);
+float texture(samplerCubeShadow sampler, vec4 P, float bias);
+
+ vec4 texture( sampler2DArray sampler, vec3 P, float bias);
+ivec4 texture(isampler2DArray sampler, vec3 P, float bias);
+uvec4 texture(usampler2DArray sampler, vec3 P, float bias);
+
+float texture(sampler2DArrayShadow sampler, vec4 P, float bias);
+
+/* textureProj - bias variants */
+ vec4 textureProj( sampler2D sampler, vec3 P, float bias);
+ivec4 textureProj(isampler2D sampler, vec3 P, float bias);
+uvec4 textureProj(usampler2D sampler, vec3 P, float bias);
+ vec4 textureProj( sampler2D sampler, vec4 P, float bias);
+ivec4 textureProj(isampler2D sampler, vec4 P, float bias);
+uvec4 textureProj(usampler2D sampler, vec4 P, float bias);
+
+ vec4 textureProj( sampler3D sampler, vec4 P, float bias);
+ivec4 textureProj(isampler3D sampler, vec4 P, float bias);
+uvec4 textureProj(usampler3D sampler, vec4 P, float bias);
+
+float textureProj(sampler2DShadow sampler, vec4 P, float bias);
+
+/* textureOffset - bias variants */
+ vec4 textureOffset( sampler2D sampler, vec2 P, ivec2 offset, float bias);
+ivec4 textureOffset(isampler2D sampler, vec2 P, ivec2 offset, float bias);
+uvec4 textureOffset(usampler2D sampler, vec2 P, ivec2 offset, float bias);
+
+ vec4 textureOffset( sampler3D sampler, vec3 P, ivec3 offset, float bias);
+ivec4 textureOffset(isampler3D sampler, vec3 P, ivec3 offset, float bias);
+uvec4 textureOffset(usampler3D sampler, vec3 P, ivec3 offset, float bias);
+
+float textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset, float bias);
+
+ vec4 textureOffset( sampler2DArray sampler, vec3 P, ivec2 offset, float bias);
+ivec4 textureOffset(isampler2DArray sampler, vec3 P, ivec2 offset, float bias);
+uvec4 textureOffset(usampler2DArray sampler, vec3 P, ivec2 offset, float bias);
+
+/* textureProjOffsetOffset - bias variants */
+ vec4 textureProjOffset( sampler2D sampler, vec3 P, ivec2 offset, float bias);
+ivec4 textureProjOffset(isampler2D sampler, vec3 P, ivec2 offset, float bias);
+uvec4 textureProjOffset(usampler2D sampler, vec3 P, ivec2 offset, float bias);
+ vec4 textureProjOffset( sampler2D sampler, vec4 P, ivec2 offset, float bias);
+ivec4 textureProjOffset(isampler2D sampler, vec4 P, ivec2 offset, float bias);
+uvec4 textureProjOffset(usampler2D sampler, vec4 P, ivec2 offset, float bias);
+
+ vec4 textureProjOffset( sampler3D sampler, vec4 P, ivec3 offset, float bias);
+ivec4 textureProjOffset(isampler3D sampler, vec4 P, ivec3 offset, float bias);
+uvec4 textureProjOffset(usampler3D sampler, vec4 P, ivec3 offset, float bias);
+
+float textureProjOffset(sampler2DShadow s, vec4 P, ivec2 offset, float bias);
+
+/*
+ * 8.9 - Fragment Processing Functions
+ */
+float dFdx(float p);
+vec2  dFdx(vec2  p);
+vec3  dFdx(vec3  p);
+vec4  dFdx(vec4  p);
+
+float dFdy(float p);
+vec2  dFdy(vec2  p);
+vec3  dFdy(vec3  p);
+vec4  dFdy(vec4  p);
+
+float fwidth(float p);
+vec2  fwidth(vec2  p);
+vec3  fwidth(vec3  p);
+vec4  fwidth(vec4  p);
diff --git a/src/glsl/builtins/profiles/300es.glsl b/src/glsl/builtins/profiles/300es.glsl
new file mode 100644
index 0000000..45212b3
--- /dev/null
+++ b/src/glsl/builtins/profiles/300es.glsl
@@ -0,0 +1,749 @@
+#version 300 es
+/*
+ * 8.1 - Angle and Trigonometry Functions
+ */
+float radians(float degrees);
+vec2  radians(vec2  degrees);
+vec3  radians(vec3  degrees);
+vec4  radians(vec4  degrees);
+
+float degrees(float radians);
+vec2  degrees(vec2  radians);
+vec3  degrees(vec3  radians);
+vec4  degrees(vec4  radians);
+
+float sin(float angle);
+vec2  sin(vec2  angle);
+vec3  sin(vec3  angle);
+vec4  sin(vec4  angle);
+
+float cos(float angle);
+vec2  cos(vec2  angle);
+vec3  cos(vec3  angle);
+vec4  cos(vec4  angle);
+
+float tan(float angle);
+vec2  tan(vec2  angle);
+vec3  tan(vec3  angle);
+vec4  tan(vec4  angle);
+
+float asin(float angle);
+vec2  asin(vec2  angle);
+vec3  asin(vec3  angle);
+vec4  asin(vec4  angle);
+
+float acos(float angle);
+vec2  acos(vec2  angle);
+vec3  acos(vec3  angle);
+vec4  acos(vec4  angle);
+
+float atan(float y, float x);
+vec2  atan(vec2  y, vec2  x);
+vec3  atan(vec3  y, vec3  x);
+vec4  atan(vec4  y, vec4  x);
+
+float atan(float y_over_x);
+vec2  atan(vec2  y_over_x);
+vec3  atan(vec3  y_over_x);
+vec4  atan(vec4  y_over_x);
+
+float sinh(float x);
+vec2  sinh(vec2  x);
+vec3  sinh(vec3  x);
+vec4  sinh(vec4  x);
+
+float cosh(float x);
+vec2  cosh(vec2  x);
+vec3  cosh(vec3  x);
+vec4  cosh(vec4  x);
+
+float tanh(float x);
+vec2  tanh(vec2  x);
+vec3  tanh(vec3  x);
+vec4  tanh(vec4  x);
+
+float asinh(float x);
+vec2  asinh(vec2  x);
+vec3  asinh(vec3  x);
+vec4  asinh(vec4  x);
+
+float acosh(float x);
+vec2  acosh(vec2  x);
+vec3  acosh(vec3  x);
+vec4  acosh(vec4  x);
+
+float atanh(float x);
+vec2  atanh(vec2  x);
+vec3  atanh(vec3  x);
+vec4  atanh(vec4  x);
+
+/*
+ * 8.2 - Exponential Functions
+ */
+float pow(float x, float y);
+vec2  pow(vec2  x, vec2  y);
+vec3  pow(vec3  x, vec3  y);
+vec4  pow(vec4  x, vec4  y);
+
+float exp(float x);
+vec2  exp(vec2  x);
+vec3  exp(vec3  x);
+vec4  exp(vec4  x);
+
+float log(float x);
+vec2  log(vec2  x);
+vec3  log(vec3  x);
+vec4  log(vec4  x);
+
+float exp2(float x);
+vec2  exp2(vec2  x);
+vec3  exp2(vec3  x);
+vec4  exp2(vec4  x);
+
+float log2(float x);
+vec2  log2(vec2  x);
+vec3  log2(vec3  x);
+vec4  log2(vec4  x);
+
+float sqrt(float x);
+vec2  sqrt(vec2  x);
+vec3  sqrt(vec3  x);
+vec4  sqrt(vec4  x);
+
+float inversesqrt(float x);
+vec2  inversesqrt(vec2  x);
+vec3  inversesqrt(vec3  x);
+vec4  inversesqrt(vec4  x);
+
+/*
+ * 8.3 - Common Functions
+ */
+float abs(float x);
+vec2  abs(vec2  x);
+vec3  abs(vec3  x);
+vec4  abs(vec4  x);
+int   abs(int   x);
+ivec2 abs(ivec2 x);
+ivec3 abs(ivec3 x);
+ivec4 abs(ivec4 x);
+
+float sign(float x);
+vec2  sign(vec2  x);
+vec3  sign(vec3  x);
+vec4  sign(vec4  x);
+int   sign(int   x);
+ivec2 sign(ivec2 x);
+ivec3 sign(ivec3 x);
+ivec4 sign(ivec4 x);
+
+float floor(float x);
+vec2  floor(vec2  x);
+vec3  floor(vec3  x);
+vec4  floor(vec4  x);
+
+float trunc(float x);
+vec2  trunc(vec2  x);
+vec3  trunc(vec3  x);
+vec4  trunc(vec4  x);
+
+float round(float x);
+vec2  round(vec2  x);
+vec3  round(vec3  x);
+vec4  round(vec4  x);
+
+float roundEven(float x);
+vec2  roundEven(vec2  x);
+vec3  roundEven(vec3  x);
+vec4  roundEven(vec4  x);
+
+float ceil(float x);
+vec2  ceil(vec2  x);
+vec3  ceil(vec3  x);
+vec4  ceil(vec4  x);
+
+float fract(float x);
+vec2  fract(vec2  x);
+vec3  fract(vec3  x);
+vec4  fract(vec4  x);
+
+float mod(float x, float y);
+vec2  mod(vec2  x, float y);
+vec3  mod(vec3  x, float y);
+vec4  mod(vec4  x, float y);
+
+vec2  mod(vec2  x, vec2  y);
+vec3  mod(vec3  x, vec3  y);
+vec4  mod(vec4  x, vec4  y);
+
+float modf(float x, out float i);
+vec2  modf(vec2  x, out vec2  i);
+vec3  modf(vec3  x, out vec3  i);
+vec4  modf(vec4  x, out vec4  i);
+
+float min(float x, float y);
+vec2  min(vec2  x, vec2  y);
+vec3  min(vec3  x, vec3  y);
+vec4  min(vec4  x, vec4  y);
+
+vec2  min(vec2  x, float y);
+vec3  min(vec3  x, float y);
+vec4  min(vec4  x, float y);
+
+int   min(int   x, int   y);
+ivec2 min(ivec2 x, ivec2 y);
+ivec3 min(ivec3 x, ivec3 y);
+ivec4 min(ivec4 x, ivec4 y);
+
+ivec2 min(ivec2 x, int   y);
+ivec3 min(ivec3 x, int   y);
+ivec4 min(ivec4 x, int   y);
+
+uint  min(uint  x, uint  y);
+uvec2 min(uvec2 x, uvec2 y);
+uvec3 min(uvec3 x, uvec3 y);
+uvec4 min(uvec4 x, uvec4 y);
+
+uvec2 min(uvec2 x, uint  y);
+uvec3 min(uvec3 x, uint  y);
+uvec4 min(uvec4 x, uint  y);
+
+float max(float x, float y);
+vec2  max(vec2  x, vec2  y);
+vec3  max(vec3  x, vec3  y);
+vec4  max(vec4  x, vec4  y);
+
+vec2  max(vec2  x, float y);
+vec3  max(vec3  x, float y);
+vec4  max(vec4  x, float y);
+
+int   max(int   x, int   y);
+ivec2 max(ivec2 x, ivec2 y);
+ivec3 max(ivec3 x, ivec3 y);
+ivec4 max(ivec4 x, ivec4 y);
+
+ivec2 max(ivec2 x, int   y);
+ivec3 max(ivec3 x, int   y);
+ivec4 max(ivec4 x, int   y);
+
+uint  max(uint  x, uint  y);
+uvec2 max(uvec2 x, uvec2 y);
+uvec3 max(uvec3 x, uvec3 y);
+uvec4 max(uvec4 x, uvec4 y);
+
+uvec2 max(uvec2 x, uint  y);
+uvec3 max(uvec3 x, uint  y);
+uvec4 max(uvec4 x, uint  y);
+
+float clamp(float x, float minVal, float maxVal);
+vec2  clamp(vec2  x, vec2  minVal, vec2  maxVal);
+vec3  clamp(vec3  x, vec3  minVal, vec3  maxVal);
+vec4  clamp(vec4  x, vec4  minVal, vec4  maxVal);
+
+vec2  clamp(vec2  x, float minVal, float maxVal);
+vec3  clamp(vec3  x, float minVal, float maxVal);
+vec4  clamp(vec4  x, float minVal, float maxVal);
+
+int   clamp(int   x, int   minVal, int   maxVal);
+ivec2 clamp(ivec2 x, ivec2 minVal, ivec2 maxVal);
+ivec3 clamp(ivec3 x, ivec3 minVal, ivec3 maxVal);
+ivec4 clamp(ivec4 x, ivec4 minVal, ivec4 maxVal);
+
+ivec2 clamp(ivec2 x, int   minVal, int   maxVal);
+ivec3 clamp(ivec3 x, int   minVal, int   maxVal);
+ivec4 clamp(ivec4 x, int   minVal, int   maxVal);
+
+uint  clamp(uint  x, uint  minVal, uint  maxVal);
+uvec2 clamp(uvec2 x, uvec2 minVal, uvec2 maxVal);
+uvec3 clamp(uvec3 x, uvec3 minVal, uvec3 maxVal);
+uvec4 clamp(uvec4 x, uvec4 minVal, uvec4 maxVal);
+
+uvec2 clamp(uvec2 x, uint  minVal, uint  maxVal);
+uvec3 clamp(uvec3 x, uint  minVal, uint  maxVal);
+uvec4 clamp(uvec4 x, uint  minVal, uint  maxVal);
+
+float mix(float x, float y, float a);
+vec2  mix(vec2  x, vec2  y, vec2  a);
+vec3  mix(vec3  x, vec3  y, vec3  a);
+vec4  mix(vec4  x, vec4  y, vec4  a);
+
+vec2  mix(vec2  x, vec2  y, float a);
+vec3  mix(vec3  x, vec3  y, float a);
+vec4  mix(vec4  x, vec4  y, float a);
+
+float mix(float x, float y, bool  a);
+vec2  mix(vec2  x, vec2  y, bvec2 a);
+vec3  mix(vec3  x, vec3  y, bvec3 a);
+vec4  mix(vec4  x, vec4  y, bvec4 a);
+
+float step(float edge, float x);
+vec2  step(vec2  edge, vec2  x);
+vec3  step(vec3  edge, vec3  x);
+vec4  step(vec4  edge, vec4  x);
+
+vec2  step(float edge, vec2  x);
+vec3  step(float edge, vec3  x);
+vec4  step(float edge, vec4  x);
+
+float smoothstep(float edge0, float edge1, float x);
+vec2  smoothstep(vec2  edge0, vec2  edge1, vec2  x);
+vec3  smoothstep(vec3  edge0, vec3  edge1, vec3  x);
+vec4  smoothstep(vec4  edge0, vec4  edge1, vec4  x);
+
+vec2  smoothstep(float edge0, float edge1, vec2  x);
+vec3  smoothstep(float edge0, float edge1, vec3  x);
+vec4  smoothstep(float edge0, float edge1, vec4  x);
+
+bool  isnan(float x);
+bvec2 isnan(vec2  x);
+bvec3 isnan(vec3  x);
+bvec4 isnan(vec4  x);
+
+bool  isinf(float x);
+bvec2 isinf(vec2  x);
+bvec3 isinf(vec3  x);
+bvec4 isinf(vec4  x);
+
+int   floatBitsToInt(float value);
+ivec2 floatBitsToInt(vec2  value);
+ivec3 floatBitsToInt(vec3  value);
+ivec4 floatBitsToInt(vec4  value);
+
+uint  floatBitsToUint(float value);
+uvec2 floatBitsToUint(vec2  value);
+uvec3 floatBitsToUint(vec3  value);
+uvec4 floatBitsToUint(vec4  value);
+
+float intBitsToFloat(int   value);
+vec2  intBitsToFloat(ivec2 value);
+vec3  intBitsToFloat(ivec3 value);
+vec4  intBitsToFloat(ivec4 value);
+
+float uintBitsToFloat(uint  value);
+vec2  uintBitsToFloat(uvec2 value);
+vec3  uintBitsToFloat(uvec3 value);
+vec4  uintBitsToFloat(uvec4 value);
+
+/*
+ * 8.4 - Floating-Point Pack and Unpack Functions
+ * FIXME: implement these
+ */
+// uint packSnorm2x16(vec2 v);
+// vec2 unpackSnorm2x16(uint p);
+// uint packUnorm2x16(vec2 v);
+// vec2 unpackUnorm2x16(uint p);
+// uint packHalf2x16(vec2 v);
+// vec2 unpackHalf2x16(uint p);
+
+/*
+ * 8.5 - Geometric Functions
+ */
+float length(float x);
+float length(vec2  x);
+float length(vec3  x);
+float length(vec4  x);
+
+float distance(float p0, float p1);
+float distance(vec2  p0, vec2  p1);
+float distance(vec3  p0, vec3  p1);
+float distance(vec4  p0, vec4  p1);
+
+float dot(float x, float y);
+float dot(vec2  x, vec2  y);
+float dot(vec3  x, vec3  y);
+float dot(vec4  x, vec4  y);
+
+vec3 cross(vec3 x, vec3 y);
+
+float normalize(float x);
+vec2  normalize(vec2  x);
+vec3  normalize(vec3  x);
+vec4  normalize(vec4  x);
+
+float faceforward(float N, float I, float Nref);
+vec2  faceforward(vec2  N, vec2  I, vec2  Nref);
+vec3  faceforward(vec3  N, vec3  I, vec3  Nref);
+vec4  faceforward(vec4  N, vec4  I, vec4  Nref);
+
+float reflect(float I, float N);
+vec2  reflect(vec2  I, vec2  N);
+vec3  reflect(vec3  I, vec3  N);
+vec4  reflect(vec4  I, vec4  N);
+
+float refract(float I, float N, float eta);
+vec2  refract(vec2  I, vec2  N, float eta);
+vec3  refract(vec3  I, vec3  N, float eta);
+vec4  refract(vec4  I, vec4  N, float eta);
+
+/*
+ * 8.6 - Matrix Functions
+ */
+mat2 matrixCompMult(mat2 x, mat2 y);
+mat3 matrixCompMult(mat3 x, mat3 y);
+mat4 matrixCompMult(mat4 x, mat4 y);
+mat2x3 matrixCompMult(mat2x3 x, mat2x3 y);
+mat2x4 matrixCompMult(mat2x4 x, mat2x4 y);
+mat3x2 matrixCompMult(mat3x2 x, mat3x2 y);
+mat3x4 matrixCompMult(mat3x4 x, mat3x4 y);
+mat4x2 matrixCompMult(mat4x2 x, mat4x2 y);
+mat4x3 matrixCompMult(mat4x3 x, mat4x3 y);
+
+mat2   outerProduct(vec2 c, vec2 r);
+mat3   outerProduct(vec3 c, vec3 r);
+mat4   outerProduct(vec4 c, vec4 r);
+
+mat2x3 outerProduct(vec3 c, vec2 r);
+mat3x2 outerProduct(vec2 c, vec3 r);
+
+mat2x4 outerProduct(vec4 c, vec2 r);
+mat4x2 outerProduct(vec2 c, vec4 r);
+
+mat3x4 outerProduct(vec4 c, vec3 r);
+mat4x3 outerProduct(vec3 c, vec4 r);
+
+mat2   transpose(mat2 m);
+mat3   transpose(mat3 m);
+mat4   transpose(mat4 m);
+
+mat2x3 transpose(mat3x2 m);
+mat3x2 transpose(mat2x3 m);
+
+mat2x4 transpose(mat4x2 m);
+mat4x2 transpose(mat2x4 m);
+
+mat3x4 transpose(mat4x3 m);
+mat4x3 transpose(mat3x4 m);
+
+float determinant(mat2 m);
+float determinant(mat3 m);
+float determinant(mat4 m);
+
+mat2 inverse(mat2 m);
+mat3 inverse(mat3 m);
+mat4 inverse(mat4 m);
+
+/*
+ * 8.7 - Vector Relational Functions
+ */
+bvec2 lessThan( vec2 x,  vec2 y);
+bvec3 lessThan( vec3 x,  vec3 y);
+bvec4 lessThan( vec4 x,  vec4 y);
+bvec2 lessThan(ivec2 x, ivec2 y);
+bvec3 lessThan(ivec3 x, ivec3 y);
+bvec4 lessThan(ivec4 x, ivec4 y);
+bvec2 lessThan(uvec2 x, uvec2 y);
+bvec3 lessThan(uvec3 x, uvec3 y);
+bvec4 lessThan(uvec4 x, uvec4 y);
+
+bvec2 lessThanEqual( vec2 x,  vec2 y);
+bvec3 lessThanEqual( vec3 x,  vec3 y);
+bvec4 lessThanEqual( vec4 x,  vec4 y);
+bvec2 lessThanEqual(ivec2 x, ivec2 y);
+bvec3 lessThanEqual(ivec3 x, ivec3 y);
+bvec4 lessThanEqual(ivec4 x, ivec4 y);
+bvec2 lessThanEqual(uvec2 x, uvec2 y);
+bvec3 lessThanEqual(uvec3 x, uvec3 y);
+bvec4 lessThanEqual(uvec4 x, uvec4 y);
+
+bvec2 greaterThan( vec2 x,  vec2 y);
+bvec3 greaterThan( vec3 x,  vec3 y);
+bvec4 greaterThan( vec4 x,  vec4 y);
+bvec2 greaterThan(ivec2 x, ivec2 y);
+bvec3 greaterThan(ivec3 x, ivec3 y);
+bvec4 greaterThan(ivec4 x, ivec4 y);
+bvec2 greaterThan(uvec2 x, uvec2 y);
+bvec3 greaterThan(uvec3 x, uvec3 y);
+bvec4 greaterThan(uvec4 x, uvec4 y);
+
+bvec2 greaterThanEqual( vec2 x,  vec2 y);
+bvec3 greaterThanEqual( vec3 x,  vec3 y);
+bvec4 greaterThanEqual( vec4 x,  vec4 y);
+bvec2 greaterThanEqual(ivec2 x, ivec2 y);
+bvec3 greaterThanEqual(ivec3 x, ivec3 y);
+bvec4 greaterThanEqual(ivec4 x, ivec4 y);
+bvec2 greaterThanEqual(uvec2 x, uvec2 y);
+bvec3 greaterThanEqual(uvec3 x, uvec3 y);
+bvec4 greaterThanEqual(uvec4 x, uvec4 y);
+
+bvec2 equal( vec2 x,  vec2 y);
+bvec3 equal( vec3 x,  vec3 y);
+bvec4 equal( vec4 x,  vec4 y);
+bvec2 equal(ivec2 x, ivec2 y);
+bvec3 equal(ivec3 x, ivec3 y);
+bvec4 equal(ivec4 x, ivec4 y);
+bvec2 equal(uvec2 x, uvec2 y);
+bvec3 equal(uvec3 x, uvec3 y);
+bvec4 equal(uvec4 x, uvec4 y);
+bvec2 equal(bvec2 x, bvec2 y);
+bvec3 equal(bvec3 x, bvec3 y);
+bvec4 equal(bvec4 x, bvec4 y);
+
+bvec2 notEqual( vec2 x,  vec2 y);
+bvec3 notEqual( vec3 x,  vec3 y);
+bvec4 notEqual( vec4 x,  vec4 y);
+bvec2 notEqual(ivec2 x, ivec2 y);
+bvec3 notEqual(ivec3 x, ivec3 y);
+bvec4 notEqual(ivec4 x, ivec4 y);
+bvec2 notEqual(uvec2 x, uvec2 y);
+bvec3 notEqual(uvec3 x, uvec3 y);
+bvec4 notEqual(uvec4 x, uvec4 y);
+bvec2 notEqual(bvec2 x, bvec2 y);
+bvec3 notEqual(bvec3 x, bvec3 y);
+bvec4 notEqual(bvec4 x, bvec4 y);
+
+bool any(bvec2 x);
+bool any(bvec3 x);
+bool any(bvec4 x);
+
+bool all(bvec2 x);
+bool all(bvec3 x);
+bool all(bvec4 x);
+
+bvec2 not(bvec2 x);
+bvec3 not(bvec3 x);
+bvec4 not(bvec4 x);
+
+/*
+ * 8.8 - Texture Lookup Functions
+ */
+
+/* textureSize */
+ivec2 textureSize( sampler2D sampler, int lod);
+ivec2 textureSize(isampler2D sampler, int lod);
+ivec2 textureSize(usampler2D sampler, int lod);
+
+ivec3 textureSize( sampler3D sampler, int lod);
+ivec3 textureSize(isampler3D sampler, int lod);
+ivec3 textureSize(usampler3D sampler, int lod);
+
+ivec2 textureSize( samplerCube sampler, int lod);
+ivec2 textureSize(isamplerCube sampler, int lod);
+ivec2 textureSize(usamplerCube sampler, int lod);
+
+ivec2 textureSize(sampler2DShadow   sampler, int lod);
+ivec2 textureSize(samplerCubeShadow sampler, int lod);
+
+ivec3 textureSize( sampler2DArray sampler, int lod);
+ivec3 textureSize(isampler2DArray sampler, int lod);
+ivec3 textureSize(usampler2DArray sampler, int lod);
+
+ivec3 textureSize(sampler2DArrayShadow sampler, int lod);
+
+/* texture - no bias */
+ vec4 texture( sampler2D sampler, vec2 P);
+ivec4 texture(isampler2D sampler, vec2 P);
+uvec4 texture(usampler2D sampler, vec2 P);
+
+ vec4 texture( sampler3D sampler, vec3 P);
+ivec4 texture(isampler3D sampler, vec3 P);
+uvec4 texture(usampler3D sampler, vec3 P);
+
+ vec4 texture( samplerCube sampler, vec3 P);
+ivec4 texture(isamplerCube sampler, vec3 P);
+uvec4 texture(usamplerCube sampler, vec3 P);
+
+float texture(sampler2DShadow   sampler, vec3 P);
+float texture(samplerCubeShadow sampler, vec4 P);
+
+ vec4 texture( sampler2DArray sampler, vec3 P);
+ivec4 texture(isampler2DArray sampler, vec3 P);
+uvec4 texture(usampler2DArray sampler, vec3 P);
+
+float texture(sampler2DArrayShadow sampler, vec4 P);
+
+/* textureProj - no bias */
+ vec4 textureProj( sampler2D sampler, vec3 P);
+ivec4 textureProj(isampler2D sampler, vec3 P);
+uvec4 textureProj(usampler2D sampler, vec3 P);
+ vec4 textureProj( sampler2D sampler, vec4 P);
+ivec4 textureProj(isampler2D sampler, vec4 P);
+uvec4 textureProj(usampler2D sampler, vec4 P);
+
+ vec4 textureProj( sampler3D sampler, vec4 P);
+ivec4 textureProj(isampler3D sampler, vec4 P);
+uvec4 textureProj(usampler3D sampler, vec4 P);
+
+float textureProj(sampler2DShadow sampler, vec4 P);
+
+/* textureLod */
+ vec4 textureLod( sampler2D sampler, vec2 P, float lod);
+ivec4 textureLod(isampler2D sampler, vec2 P, float lod);
+uvec4 textureLod(usampler2D sampler, vec2 P, float lod);
+
+ vec4 textureLod( sampler3D sampler, vec3 P, float lod);
+ivec4 textureLod(isampler3D sampler, vec3 P, float lod);
+uvec4 textureLod(usampler3D sampler, vec3 P, float lod);
+
+ vec4 textureLod( samplerCube sampler, vec3 P, float lod);
+ivec4 textureLod(isamplerCube sampler, vec3 P, float lod);
+uvec4 textureLod(usamplerCube sampler, vec3 P, float lod);
+
+float textureLod(sampler2DShadow sampler, vec3 P, float lod);
+
+ vec4 textureLod( sampler2DArray sampler, vec3 P, float lod);
+ivec4 textureLod(isampler2DArray sampler, vec3 P, float lod);
+uvec4 textureLod(usampler2DArray sampler, vec3 P, float lod);
+
+/* textureOffset - no bias */
+ vec4 textureOffset( sampler2D sampler, vec2 P, ivec2 offset);
+ivec4 textureOffset(isampler2D sampler, vec2 P, ivec2 offset);
+uvec4 textureOffset(usampler2D sampler, vec2 P, ivec2 offset);
+
+ vec4 textureOffset( sampler3D sampler, vec3 P, ivec3 offset);
+ivec4 textureOffset(isampler3D sampler, vec3 P, ivec3 offset);
+uvec4 textureOffset(usampler3D sampler, vec3 P, ivec3 offset);
+
+float textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset);
+
+ vec4 textureOffset( sampler2DArray sampler, vec3 P, ivec2 offset);
+ivec4 textureOffset(isampler2DArray sampler, vec3 P, ivec2 offset);
+uvec4 textureOffset(usampler2DArray sampler, vec3 P, ivec2 offset);
+
+/* texelFetch */
+ vec4 texelFetch( sampler2D sampler, ivec2 P, int lod);
+ivec4 texelFetch(isampler2D sampler, ivec2 P, int lod);
+uvec4 texelFetch(usampler2D sampler, ivec2 P, int lod);
+
+ vec4 texelFetch( sampler3D sampler, ivec3 P, int lod);
+ivec4 texelFetch(isampler3D sampler, ivec3 P, int lod);
+uvec4 texelFetch(usampler3D sampler, ivec3 P, int lod);
+
+ vec4 texelFetch( sampler2DArray sampler, ivec3 P, int lod);
+ivec4 texelFetch(isampler2DArray sampler, ivec3 P, int lod);
+uvec4 texelFetch(usampler2DArray sampler, ivec3 P, int lod);
+
+/* texelFetchOffset */
+ vec4 texelFetchOffset( sampler2D sampler, ivec2 P, int lod, ivec2 offset);
+ivec4 texelFetchOffset(isampler2D sampler, ivec2 P, int lod, ivec2 offset);
+uvec4 texelFetchOffset(usampler2D sampler, ivec2 P, int lod, ivec2 offset);
+
+ vec4 texelFetchOffset( sampler3D sampler, ivec3 P, int lod, ivec3 offset);
+ivec4 texelFetchOffset(isampler3D sampler, ivec3 P, int lod, ivec3 offset);
+uvec4 texelFetchOffset(usampler3D sampler, ivec3 P, int lod, ivec3 offset);
+
+ vec4 texelFetchOffset( sampler2DArray sampler, ivec3 P, int lod, ivec2 offset);
+ivec4 texelFetchOffset(isampler2DArray sampler, ivec3 P, int lod, ivec2 offset);
+uvec4 texelFetchOffset(usampler2DArray sampler, ivec3 P, int lod, ivec2 offset);
+
+/* textureProjOffset - no bias */
+ vec4 textureProjOffset( sampler2D sampler, vec3 P, ivec2 offset);
+ivec4 textureProjOffset(isampler2D sampler, vec3 P, ivec2 offset);
+uvec4 textureProjOffset(usampler2D sampler, vec3 P, ivec2 offset);
+ vec4 textureProjOffset( sampler2D sampler, vec4 P, ivec2 offset);
+ivec4 textureProjOffset(isampler2D sampler, vec4 P, ivec2 offset);
+uvec4 textureProjOffset(usampler2D sampler, vec4 P, ivec2 offset);
+
+ vec4 textureProjOffset( sampler3D sampler, vec4 P, ivec3 offset);
+ivec4 textureProjOffset(isampler3D sampler, vec4 P, ivec3 offset);
+uvec4 textureProjOffset(usampler3D sampler, vec4 P, ivec3 offset);
+
+float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset);
+
+/* textureLodOffset */
+ vec4 textureLodOffset( sampler2D sampler, vec2 P, float lod, ivec2 offset);
+ivec4 textureLodOffset(isampler2D sampler, vec2 P, float lod, ivec2 offset);
+uvec4 textureLodOffset(usampler2D sampler, vec2 P, float lod, ivec2 offset);
+
+ vec4 textureLodOffset( sampler3D sampler, vec3 P, float lod, ivec3 offset);
+ivec4 textureLodOffset(isampler3D sampler, vec3 P, float lod, ivec3 offset);
+uvec4 textureLodOffset(usampler3D sampler, vec3 P, float lod, ivec3 offset);
+
+float textureLodOffset(sampler2DShadow samp, vec3 P, float lod, ivec2 offset);
+
+ vec4 textureLodOffset( sampler2DArray samp, vec3 P, float lod, ivec2 offset);
+ivec4 textureLodOffset(isampler2DArray samp, vec3 P, float lod, ivec2 offset);
+uvec4 textureLodOffset(usampler2DArray samp, vec3 P, float lod, ivec2 offset);
+
+/* textureProjLod */
+ vec4 textureProjLod( sampler2D sampler, vec3 P, float lod);
+ivec4 textureProjLod(isampler2D sampler, vec3 P, float lod);
+uvec4 textureProjLod(usampler2D sampler, vec3 P, float lod);
+ vec4 textureProjLod( sampler2D sampler, vec4 P, float lod);
+ivec4 textureProjLod(isampler2D sampler, vec4 P, float lod);
+uvec4 textureProjLod(usampler2D sampler, vec4 P, float lod);
+
+ vec4 textureProjLod( sampler3D sampler, vec4 P, float lod);
+ivec4 textureProjLod(isampler3D sampler, vec4 P, float lod);
+uvec4 textureProjLod(usampler3D sampler, vec4 P, float lod);
+
+float textureProjLod(sampler2DShadow sampler, vec4 P, float lod);
+
+/* textureProjLodOffset */
+ vec4 textureProjLodOffset( sampler2D sampler, vec3 P, float lod, ivec2 offset);
+ivec4 textureProjLodOffset(isampler2D sampler, vec3 P, float lod, ivec2 offset);
+uvec4 textureProjLodOffset(usampler2D sampler, vec3 P, float lod, ivec2 offset);
+ vec4 textureProjLodOffset( sampler2D sampler, vec4 P, float lod, ivec2 offset);
+ivec4 textureProjLodOffset(isampler2D sampler, vec4 P, float lod, ivec2 offset);
+uvec4 textureProjLodOffset(usampler2D sampler, vec4 P, float lod, ivec2 offset);
+
+ vec4 textureProjLodOffset( sampler3D sampler, vec4 P, float lod, ivec3 offset);
+ivec4 textureProjLodOffset(isampler3D sampler, vec4 P, float lod, ivec3 offset);
+uvec4 textureProjLodOffset(usampler3D sampler, vec4 P, float lod, ivec3 offset);
+
+float textureProjLodOffset(sampler2DShadow s, vec4 P, float lod, ivec2 offset);
+
+/* textureGrad */
+ vec4 textureGrad( sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);
+ivec4 textureGrad(isampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);
+uvec4 textureGrad(usampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);
+
+ vec4 textureGrad( sampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);
+ivec4 textureGrad(isampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);
+uvec4 textureGrad(usampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);
+
+ vec4 textureGrad( samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);
+ivec4 textureGrad(isamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);
+uvec4 textureGrad(usamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);
+
+float textureGrad(sampler2DShadow   sampler, vec3 P, vec2  dPdx, vec2  dPdy);
+float textureGrad(samplerCubeShadow sampler, vec4 P, vec3  dPdx, vec3  dPdy);
+
+ vec4 textureGrad( sampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);
+ivec4 textureGrad(isampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);
+uvec4 textureGrad(usampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);
+
+float textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2  dPdx, vec2  dPdy);
+
+/* textureGradOffset */
+ vec4 textureGradOffset( sampler2D s, vec2 P, vec2 dx, vec2 dy, ivec2 offset);
+ivec4 textureGradOffset(isampler2D s, vec2 P, vec2 dx, vec2 dy, ivec2 offset);
+uvec4 textureGradOffset(usampler2D s, vec2 P, vec2 dx, vec2 dy, ivec2 offset);
+
+ vec4 textureGradOffset( sampler3D s, vec3 P, vec3 dx, vec3 dy, ivec3 offset);
+ivec4 textureGradOffset(isampler3D s, vec3 P, vec3 dx, vec3 dy, ivec3 offset);
+uvec4 textureGradOffset(usampler3D s, vec3 P, vec3 dx, vec3 dy, ivec3 offset);
+
+float textureGradOffset(sampler2DShadow s, vec3 P, vec2 dx, vec2 dy, ivec2 off);
+
+ vec4 textureGradOffset( sampler2DArray s, vec3 P, vec2 dx, vec2 dy, ivec2 off);
+ivec4 textureGradOffset(isampler2DArray s, vec3 P, vec2 dx, vec2 dy, ivec2 off);
+uvec4 textureGradOffset(usampler2DArray s, vec3 P, vec2 dx, vec2 dy, ivec2 off);
+
+float textureGradOffset(sampler2DArrayShadow s, vec4 P, vec2 dx, vec2 dy, ivec2 o);
+
+/* textureProjGrad */
+ vec4 textureProjGrad( sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);
+ivec4 textureProjGrad(isampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);
+uvec4 textureProjGrad(usampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);
+ vec4 textureProjGrad( sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);
+ivec4 textureProjGrad(isampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);
+uvec4 textureProjGrad(usampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);
+
+ vec4 textureProjGrad( sampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);
+ivec4 textureProjGrad(isampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);
+uvec4 textureProjGrad(usampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);
+
+float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2  dPdx, vec2  dPdy);
+
+/* textureProjGradOffset */
+ vec4 textureProjGradOffset( sampler2D s, vec3 P, vec2 dx, vec2 dy, ivec2 off);
+ivec4 textureProjGradOffset(isampler2D s, vec3 P, vec2 dx, vec2 dy, ivec2 off);
+uvec4 textureProjGradOffset(usampler2D s, vec3 P, vec2 dx, vec2 dy, ivec2 off);
+ vec4 textureProjGradOffset( sampler2D s, vec4 P, vec2 dx, vec2 dy, ivec2 off);
+ivec4 textureProjGradOffset(isampler2D s, vec4 P, vec2 dx, vec2 dy, ivec2 off);
+uvec4 textureProjGradOffset(usampler2D s, vec4 P, vec2 dx, vec2 dy, ivec2 off);
+
+ vec4 textureProjGradOffset( sampler3D s, vec4 P, vec3 dx, vec3 dy, ivec3 off);
+ivec4 textureProjGradOffset(isampler3D s, vec4 P, vec3 dx, vec3 dy, ivec3 off);
+uvec4 textureProjGradOffset(usampler3D s, vec4 P, vec3 dx, vec3 dy, ivec3 off);
+
+float textureProjGradOffset(sampler2DShadow s, vec4 P, vec2 dx, vec2 dy, ivec2 o);
diff --git a/src/glsl/builtins/tools/generate_builtins.py b/src/glsl/builtins/tools/generate_builtins.py
index 86660a9..ca9336a 100755
--- a/src/glsl/builtins/tools/generate_builtins.py
+++ b/src/glsl/builtins/tools/generate_builtins.py
@@ -176,13 +176,14 @@ read_builtins(GLenum target, const char *protos, const char **functions, unsigne
    fakeCtx.API = API_OPENGL;
    fakeCtx.Const.GLSLVersion = 140;
    fakeCtx.Extensions.ARB_ES2_compatibility = true;
+   fakeCtx.Extensions.ARB_ES3_compatibility = true;
    fakeCtx.Const.ForceGLSLExtensionsWarn = false;
    gl_shader *sh = _mesa_new_shader(NULL, 0, target);
    struct _mesa_glsl_parse_state *st =
       new(sh) _mesa_glsl_parse_state(&fakeCtx, target, sh);
 
    st->language_version = 140;
-   st->symbols->language_version = 140;
+   st->symbols->separate_function_namespace = false;
    st->ARB_texture_rectangle_enable = true;
    st->EXT_texture_array_enable = true;
    st->OES_EGL_image_external_enable = true;
@@ -277,8 +278,12 @@ _mesa_glsl_initialize_functions(struct _mesa_glsl_parse_state *state)
             check = ''
 
         version = re.sub(r'_(glsl|vert|frag)$', '', profile)
-        if version.isdigit():
+        if version[0].isdigit():
+            is_es = version.endswith('es')
+            if is_es:
+                version = version[:-2]
             check += 'state->language_version == ' + version
+            check += ' && {0}state->es_shader'.format('' if is_es else '!')
         else: # an extension name
             check += 'state->' + version + '_enable'
 
diff --git a/src/glsl/glcpp/glcpp-parse.y b/src/glsl/glcpp/glcpp-parse.y
index bf6f3ad..0e02901 100644
--- a/src/glsl/glcpp/glcpp-parse.y
+++ b/src/glsl/glcpp/glcpp-parse.y
@@ -133,6 +133,10 @@ _glcpp_parser_skip_stack_change_if (glcpp_parser_t *parser, YYLTYPE *loc,
 static void
 _glcpp_parser_skip_stack_pop (glcpp_parser_t *parser, YYLTYPE *loc);
 
+static void
+_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, int version,
+                                         const char *ident);
+
 #define yylex glcpp_parser_lex
 
 static int
@@ -336,25 +340,10 @@ control_line:
 		_glcpp_parser_skip_stack_pop (parser, & @1);
 	}
 |	HASH_VERSION integer_constant NEWLINE {
-		macro_t *macro = hash_table_find (parser->defines, "__VERSION__");
-		if (macro) {
-			hash_table_remove (parser->defines, "__VERSION__");
-			ralloc_free (macro);
-		}
-		add_builtin_define (parser, "__VERSION__", $2);
-
-		if ($2 == 100)
-			add_builtin_define (parser, "GL_ES", 1);
-
-		/* Currently, all ES2 implementations support highp in the
-		 * fragment shader, so we always define this macro in ES2.
-		 * If we ever get a driver that doesn't support highp, we'll
-		 * need to add a flag to the gl_context and check that here.
-		 */
-		if ($2 >= 130 || $2 == 100)
-			add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);
-
-		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "#version %" PRIiMAX, $2);
+		_glcpp_parser_handle_version_declaration(parser, $2, NULL);
+	}
+|	HASH_VERSION integer_constant IDENTIFIER NEWLINE {
+		_glcpp_parser_handle_version_declaration(parser, $2, $3);
 	}
 |	HASH NEWLINE
 ;
@@ -1973,3 +1962,38 @@ _glcpp_parser_skip_stack_pop (glcpp_parser_t *parser, YYLTYPE *loc)
 	parser->skip_stack = node->next;
 	ralloc_free (node);
 }
+
+static void
+_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, int version,
+                                         const char *es_identifier)
+{
+	/* Note: We assume that if any identifier is present, it means ES.
+         * The GLSL parser will double-check that the identifier is correct.
+	 */
+	bool is_es = es_identifier != NULL;
+
+	macro_t *macro = hash_table_find (parser->defines, "__VERSION__");
+	if (macro) {
+		hash_table_remove (parser->defines, "__VERSION__");
+		ralloc_free (macro);
+	}
+	add_builtin_define (parser, "__VERSION__", version);
+
+	if (version == 100)
+		is_es = true;
+	if (is_es)
+		add_builtin_define (parser, "GL_ES", 1);
+
+	/* Currently, all ES2/ES3 implementations support highp in the
+	 * fragment shader, so we always define this macro in ES2/ES3.
+	 * If we ever get a driver that doesn't support highp, we'll
+	 * need to add a flag to the gl_context and check that here.
+	 */
+	if (version >= 130 || is_es)
+		add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);
+
+	ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length,
+                                      "#version %" PRIiMAX "%s%s", version,
+                                      es_identifier ? " " : "",
+                                      es_identifier ? es_identifier : "");
+}
diff --git a/src/glsl/glsl_lexer.ll b/src/glsl/glsl_lexer.ll
index 24cda0c..8573e76 100644
--- a/src/glsl/glsl_lexer.ll
+++ b/src/glsl/glsl_lexer.ll
@@ -48,20 +48,34 @@ static int classify_identifier(struct _mesa_glsl_parse_state *, const char *);
  *
  * Certain words start out as identifiers, become reserved words in
  * later language revisions, and finally become language keywords.
+ * This may happen at different times in desktop GLSL and GLSL ES.
  *
  * For example, consider the following lexer rule:
- * samplerBuffer       KEYWORD(130, 140, SAMPLERBUFFER)
+ * samplerBuffer       KEYWORD(130, 0, 140, 0, SAMPLERBUFFER)
  *
  * This means that "samplerBuffer" will be treated as:
  * - a keyword (SAMPLERBUFFER token)         ...in GLSL >= 1.40
  * - a reserved word - error                 ...in GLSL >= 1.30
- * - an identifier                           ...in GLSL <  1.30
+ * - an identifier                           ...in GLSL <  1.30 or GLSL ES
  */
-#define KEYWORD(reserved_version, allowed_version, token)		\
+#define KEYWORD(reserved_glsl, reserved_glsl_es,			\
+                allowed_glsl, allowed_glsl_es, token)			\
+   KEYWORD_WITH_ALT(reserved_glsl, reserved_glsl_es,			\
+                    allowed_glsl, allowed_glsl_es, false, token)
+
+/**
+ * Like the KEYWORD macro, but the word is also treated as a keyword
+ * if the given boolean expression is true.
+ */
+#define KEYWORD_WITH_ALT(reserved_glsl, reserved_glsl_es,		\
+                         allowed_glsl, allowed_glsl_es,			\
+                         alt_expr, token)				\
    do {									\
-      if (yyextra->language_version >= allowed_version) {		\
+      if (yyextra->is_version(allowed_glsl, allowed_glsl_es)		\
+          || alt_expr) {						\
 	 return token;							\
-      } else if (yyextra->language_version >= reserved_version) {	\
+      } else if (yyextra->is_version(reserved_glsl,			\
+                                     reserved_glsl_es)) {		\
 	 _mesa_glsl_error(yylloc, yyextra,				\
 			  "Illegal use of reserved word `%s'", yytext);	\
 	 return ERROR_TOK;						\
@@ -71,15 +85,20 @@ static int classify_identifier(struct _mesa_glsl_parse_state *, const char *);
       }									\
    } while (0)
 
-/* The ES macro can be used in KEYWORD checks:
- *
- *    word      KEYWORD(110 || ES, 400, TOKEN)
- * ...means the word is reserved in GLSL ES 1.00, while
- *
- *    word      KEYWORD(110, 130 || ES, TOKEN)
- * ...means the word is a legal keyword in GLSL ES 1.00.
+/**
+ * A macro for handling keywords that have been present in GLSL since
+ * its origin, but were changed into reserved words in GLSL 3.00 ES.
  */
-#define ES yyextra->es_shader
+#define DEPRECATED_ES_KEYWORD(token)					\
+   do {									\
+      if (yyextra->is_version(0, 300)) {				\
+	 _mesa_glsl_error(yylloc, yyextra,				\
+			  "Illegal use of reserved word `%s'", yytext);	\
+	 return ERROR_TOK;						\
+      } else {								\
+         return token;							\
+      }									\
+   } while (0)
 
 static int
 literal_integer(char *text, int len, struct _mesa_glsl_parse_state *state,
@@ -103,7 +122,7 @@ literal_integer(char *text, int len, struct _mesa_glsl_parse_state *state,
 
    if (value > UINT_MAX) {
       /* Note that signed 0xffffffff is valid, not out of range! */
-      if (state->language_version >= 130) {
+      if (state->is_version(130, 300)) {
 	 _mesa_glsl_error(lloc, state,
 			  "Literal value `%s' out of range", text);
       } else {
@@ -219,12 +238,12 @@ HASH		^{SPC}#{SPC}
 
 \n		{ yylineno++; yycolumn = 0; }
 
-attribute	return ATTRIBUTE;
+attribute	DEPRECATED_ES_KEYWORD(ATTRIBUTE);
 const		return CONST_TOK;
 bool		return BOOL_TOK;
 float		return FLOAT_TOK;
 int		return INT_TOK;
-uint		KEYWORD(130, 130, UINT_TOK);
+uint		KEYWORD(130, 300, 130, 300, UINT_TOK);
 
 break		return BREAK;
 continue	return CONTINUE;
@@ -242,59 +261,59 @@ bvec4		return BVEC4;
 ivec2		return IVEC2;
 ivec3		return IVEC3;
 ivec4		return IVEC4;
-uvec2		KEYWORD(130, 130, UVEC2);
-uvec3		KEYWORD(130, 130, UVEC3);
-uvec4		KEYWORD(130, 130, UVEC4);
+uvec2		KEYWORD(130, 300, 130, 300, UVEC2);
+uvec3		KEYWORD(130, 300, 130, 300, UVEC3);
+uvec4		KEYWORD(130, 300, 130, 300, UVEC4);
 vec2		return VEC2;
 vec3		return VEC3;
 vec4		return VEC4;
 mat2		return MAT2X2;
 mat3		return MAT3X3;
 mat4		return MAT4X4;
-mat2x2		KEYWORD(120, 120, MAT2X2);
-mat2x3		KEYWORD(120, 120, MAT2X3);
-mat2x4		KEYWORD(120, 120, MAT2X4);
-mat3x2		KEYWORD(120, 120, MAT3X2);
-mat3x3		KEYWORD(120, 120, MAT3X3);
-mat3x4		KEYWORD(120, 120, MAT3X4);
-mat4x2		KEYWORD(120, 120, MAT4X2);
-mat4x3		KEYWORD(120, 120, MAT4X3);
-mat4x4		KEYWORD(120, 120, MAT4X4);
+mat2x2		KEYWORD(120, 300, 120, 300, MAT2X2);
+mat2x3		KEYWORD(120, 300, 120, 300, MAT2X3);
+mat2x4		KEYWORD(120, 300, 120, 300, MAT2X4);
+mat3x2		KEYWORD(120, 300, 120, 300, MAT3X2);
+mat3x3		KEYWORD(120, 300, 120, 300, MAT3X3);
+mat3x4		KEYWORD(120, 300, 120, 300, MAT3X4);
+mat4x2		KEYWORD(120, 300, 120, 300, MAT4X2);
+mat4x3		KEYWORD(120, 300, 120, 300, MAT4X3);
+mat4x4		KEYWORD(120, 300, 120, 300, MAT4X4);
 
 in		return IN_TOK;
 out		return OUT_TOK;
 inout		return INOUT_TOK;
 uniform		return UNIFORM;
-varying		return VARYING;
-centroid	KEYWORD(120, 120, CENTROID);
-invariant	KEYWORD(120 || ES, 120 || ES, INVARIANT);
-flat		KEYWORD(130 || ES, 130, FLAT);
-smooth		KEYWORD(130, 130, SMOOTH);
-noperspective	KEYWORD(130, 130, NOPERSPECTIVE);
-
-sampler1D	return SAMPLER1D;
+varying		DEPRECATED_ES_KEYWORD(VARYING);
+centroid	KEYWORD(120, 300, 120, 300, CENTROID);
+invariant	KEYWORD(120, 100, 120, 100, INVARIANT);
+flat		KEYWORD(130, 100, 130, 300, FLAT);
+smooth		KEYWORD(130, 300, 130, 300, SMOOTH);
+noperspective	KEYWORD(130, 300, 130, 0, NOPERSPECTIVE);
+
+sampler1D	DEPRECATED_ES_KEYWORD(SAMPLER1D);
 sampler2D	return SAMPLER2D;
 sampler3D	return SAMPLER3D;
 samplerCube	return SAMPLERCUBE;
-sampler1DArray	KEYWORD(130, 130, SAMPLER1DARRAY);
-sampler2DArray	KEYWORD(130, 130, SAMPLER2DARRAY);
-sampler1DShadow	return SAMPLER1DSHADOW;
+sampler1DArray	KEYWORD(130, 300, 130, 0, SAMPLER1DARRAY);
+sampler2DArray	KEYWORD(130, 300, 130, 300, SAMPLER2DARRAY);
+sampler1DShadow	DEPRECATED_ES_KEYWORD(SAMPLER1DSHADOW);
 sampler2DShadow	return SAMPLER2DSHADOW;
-samplerCubeShadow	KEYWORD(130, 130, SAMPLERCUBESHADOW);
-sampler1DArrayShadow	KEYWORD(130, 130, SAMPLER1DARRAYSHADOW);
-sampler2DArrayShadow	KEYWORD(130, 130, SAMPLER2DARRAYSHADOW);
-isampler1D		KEYWORD(130, 130, ISAMPLER1D);
-isampler2D		KEYWORD(130, 130, ISAMPLER2D);
-isampler3D		KEYWORD(130, 130, ISAMPLER3D);
-isamplerCube		KEYWORD(130, 130, ISAMPLERCUBE);
-isampler1DArray		KEYWORD(130, 130, ISAMPLER1DARRAY);
-isampler2DArray		KEYWORD(130, 130, ISAMPLER2DARRAY);
-usampler1D		KEYWORD(130, 130, USAMPLER1D);
-usampler2D		KEYWORD(130, 130, USAMPLER2D);
-usampler3D		KEYWORD(130, 130, USAMPLER3D);
-usamplerCube		KEYWORD(130, 130, USAMPLERCUBE);
-usampler1DArray		KEYWORD(130, 130, USAMPLER1DARRAY);
-usampler2DArray		KEYWORD(130, 130, USAMPLER2DARRAY);
+samplerCubeShadow	KEYWORD(130, 300, 130, 300, SAMPLERCUBESHADOW);
+sampler1DArrayShadow	KEYWORD(130, 300, 130, 0, SAMPLER1DARRAYSHADOW);
+sampler2DArrayShadow	KEYWORD(130, 300, 130, 300, SAMPLER2DARRAYSHADOW);
+isampler1D		KEYWORD(130, 300, 130, 0, ISAMPLER1D);
+isampler2D		KEYWORD(130, 300, 130, 300, ISAMPLER2D);
+isampler3D		KEYWORD(130, 300, 130, 300, ISAMPLER3D);
+isamplerCube		KEYWORD(130, 300, 130, 300, ISAMPLERCUBE);
+isampler1DArray		KEYWORD(130, 300, 130, 0, ISAMPLER1DARRAY);
+isampler2DArray		KEYWORD(130, 300, 130, 300, ISAMPLER2DARRAY);
+usampler1D		KEYWORD(130, 300, 130, 0, USAMPLER1D);
+usampler2D		KEYWORD(130, 300, 130, 300, USAMPLER2D);
+usampler3D		KEYWORD(130, 300, 130, 300, USAMPLER3D);
+usamplerCube		KEYWORD(130, 300, 130, 300, USAMPLERCUBE);
+usampler1DArray		KEYWORD(130, 300, 130, 0, USAMPLER1DARRAY);
+usampler2DArray		KEYWORD(130, 300, 130, 300, USAMPLER2DARRAY);
 
 samplerExternalOES	{
 			  if (yyextra->OES_EGL_image_external_enable)
@@ -308,7 +327,7 @@ struct		return STRUCT;
 void		return VOID_TOK;
 
 layout		{
-		  if ((yyextra->language_version >= 140)
+		  if ((yyextra->is_version(140, 300))
 		      || yyextra->AMD_conservative_depth_enable
 		      || yyextra->ARB_conservative_depth_enable
 		      || yyextra->ARB_explicit_attrib_location_enable
@@ -386,96 +405,114 @@ false			{
 
 
     /* Reserved words in GLSL 1.10. */
-asm		KEYWORD(110 || ES, 999, ASM);
-class		KEYWORD(110 || ES, 999, CLASS);
-union		KEYWORD(110 || ES, 999, UNION);
-enum		KEYWORD(110 || ES, 999, ENUM);
-typedef		KEYWORD(110 || ES, 999, TYPEDEF);
-template	KEYWORD(110 || ES, 999, TEMPLATE);
-this		KEYWORD(110 || ES, 999, THIS);
-packed		KEYWORD(110 || ES, 140 || yyextra->ARB_uniform_buffer_object_enable, PACKED_TOK);
-goto		KEYWORD(110 || ES, 999, GOTO);
-switch		KEYWORD(110 || ES, 130, SWITCH);
-default		KEYWORD(110 || ES, 130, DEFAULT);
-inline		KEYWORD(110 || ES, 999, INLINE_TOK);
-noinline	KEYWORD(110 || ES, 999, NOINLINE);
-volatile	KEYWORD(110 || ES, 999, VOLATILE);
-public		KEYWORD(110 || ES, 999, PUBLIC_TOK);
-static		KEYWORD(110 || ES, 999, STATIC);
-extern		KEYWORD(110 || ES, 999, EXTERN);
-external	KEYWORD(110 || ES, 999, EXTERNAL);
-interface	KEYWORD(110 || ES, 999, INTERFACE);
-long		KEYWORD(110 || ES, 999, LONG_TOK);
-short		KEYWORD(110 || ES, 999, SHORT_TOK);
-double		KEYWORD(110 || ES, 400, DOUBLE_TOK);
-half		KEYWORD(110 || ES, 999, HALF);
-fixed		KEYWORD(110 || ES, 999, FIXED_TOK);
-unsigned	KEYWORD(110 || ES, 999, UNSIGNED);
-input		KEYWORD(110 || ES, 999, INPUT_TOK);
-output		KEYWORD(110 || ES, 999, OUTPUT);
-hvec2		KEYWORD(110 || ES, 999, HVEC2);
-hvec3		KEYWORD(110 || ES, 999, HVEC3);
-hvec4		KEYWORD(110 || ES, 999, HVEC4);
-dvec2		KEYWORD(110 || ES, 400, DVEC2);
-dvec3		KEYWORD(110 || ES, 400, DVEC3);
-dvec4		KEYWORD(110 || ES, 400, DVEC4);
-fvec2		KEYWORD(110 || ES, 999, FVEC2);
-fvec3		KEYWORD(110 || ES, 999, FVEC3);
-fvec4		KEYWORD(110 || ES, 999, FVEC4);
-sampler2DRect		return SAMPLER2DRECT;
-sampler3DRect		KEYWORD(110 || ES, 999, SAMPLER3DRECT);
-sampler2DRectShadow	return SAMPLER2DRECTSHADOW;
-sizeof		KEYWORD(110 || ES, 999, SIZEOF);
-cast		KEYWORD(110 || ES, 999, CAST);
-namespace	KEYWORD(110 || ES, 999, NAMESPACE);
-using		KEYWORD(110 || ES, 999, USING);
+asm		KEYWORD(110, 100, 0, 0, ASM);
+class		KEYWORD(110, 100, 0, 0, CLASS);
+union		KEYWORD(110, 100, 0, 0, UNION);
+enum		KEYWORD(110, 100, 0, 0, ENUM);
+typedef		KEYWORD(110, 100, 0, 0, TYPEDEF);
+template	KEYWORD(110, 100, 0, 0, TEMPLATE);
+this		KEYWORD(110, 100, 0, 0, THIS);
+packed		KEYWORD_WITH_ALT(110, 100, 140, 0, yyextra->ARB_uniform_buffer_object_enable, PACKED_TOK);
+goto		KEYWORD(110, 100, 0, 0, GOTO);
+switch		KEYWORD(110, 100, 130, 300, SWITCH);
+default		KEYWORD(110, 100, 130, 300, DEFAULT);
+inline		KEYWORD(110, 100, 0, 0, INLINE_TOK);
+noinline	KEYWORD(110, 100, 0, 0, NOINLINE);
+volatile	KEYWORD(110, 100, 0, 0, VOLATILE);
+public		KEYWORD(110, 100, 0, 0, PUBLIC_TOK);
+static		KEYWORD(110, 100, 0, 0, STATIC);
+extern		KEYWORD(110, 100, 0, 0, EXTERN);
+external	KEYWORD(110, 100, 0, 0, EXTERNAL);
+interface	KEYWORD(110, 100, 0, 0, INTERFACE);
+long		KEYWORD(110, 100, 0, 0, LONG_TOK);
+short		KEYWORD(110, 100, 0, 0, SHORT_TOK);
+double		KEYWORD(110, 100, 400, 0, DOUBLE_TOK);
+half		KEYWORD(110, 100, 0, 0, HALF);
+fixed		KEYWORD(110, 100, 0, 0, FIXED_TOK);
+unsigned	KEYWORD(110, 100, 0, 0, UNSIGNED);
+input		KEYWORD(110, 100, 0, 0, INPUT_TOK);
+output		KEYWORD(110, 100, 0, 0, OUTPUT);
+hvec2		KEYWORD(110, 100, 0, 0, HVEC2);
+hvec3		KEYWORD(110, 100, 0, 0, HVEC3);
+hvec4		KEYWORD(110, 100, 0, 0, HVEC4);
+dvec2		KEYWORD(110, 100, 400, 0, DVEC2);
+dvec3		KEYWORD(110, 100, 400, 0, DVEC3);
+dvec4		KEYWORD(110, 100, 400, 0, DVEC4);
+fvec2		KEYWORD(110, 100, 0, 0, FVEC2);
+fvec3		KEYWORD(110, 100, 0, 0, FVEC3);
+fvec4		KEYWORD(110, 100, 0, 0, FVEC4);
+sampler2DRect		DEPRECATED_ES_KEYWORD(SAMPLER2DRECT);
+sampler3DRect		KEYWORD(110, 100, 0, 0, SAMPLER3DRECT);
+sampler2DRectShadow	DEPRECATED_ES_KEYWORD(SAMPLER2DRECTSHADOW);
+sizeof		KEYWORD(110, 100, 0, 0, SIZEOF);
+cast		KEYWORD(110, 100, 0, 0, CAST);
+namespace	KEYWORD(110, 100, 0, 0, NAMESPACE);
+using		KEYWORD(110, 100, 0, 0, USING);
 
     /* Additional reserved words in GLSL 1.20. */
-lowp		KEYWORD(120, 130 || ES, LOWP);
-mediump		KEYWORD(120, 130 || ES, MEDIUMP);
-highp		KEYWORD(120, 130 || ES, HIGHP);
-precision	KEYWORD(120, 130 || ES, PRECISION);
+lowp		KEYWORD(120, 100, 130, 100, LOWP);
+mediump		KEYWORD(120, 100, 130, 100, MEDIUMP);
+highp		KEYWORD(120, 100, 130, 100, HIGHP);
+precision	KEYWORD(120, 100, 130, 100, PRECISION);
 
     /* Additional reserved words in GLSL 1.30. */
-case		KEYWORD(130, 130, CASE);
-common		KEYWORD(130, 999, COMMON);
-partition	KEYWORD(130, 999, PARTITION);
-active		KEYWORD(130, 999, ACTIVE);
-superp		KEYWORD(130 || ES, 999, SUPERP);
-samplerBuffer	KEYWORD(130, 140, SAMPLERBUFFER);
-filter		KEYWORD(130, 999, FILTER);
-image1D		KEYWORD(130, 999, IMAGE1D);
-image2D		KEYWORD(130, 999, IMAGE2D);
-image3D		KEYWORD(130, 999, IMAGE3D);
-imageCube	KEYWORD(130, 999, IMAGECUBE);
-iimage1D	KEYWORD(130, 999, IIMAGE1D);
-iimage2D	KEYWORD(130, 999, IIMAGE2D);
-iimage3D	KEYWORD(130, 999, IIMAGE3D);
-iimageCube	KEYWORD(130, 999, IIMAGECUBE);
-uimage1D	KEYWORD(130, 999, UIMAGE1D);
-uimage2D	KEYWORD(130, 999, UIMAGE2D);
-uimage3D	KEYWORD(130, 999, UIMAGE3D);
-uimageCube	KEYWORD(130, 999, UIMAGECUBE);
-image1DArray	KEYWORD(130, 999, IMAGE1DARRAY);
-image2DArray	KEYWORD(130, 999, IMAGE2DARRAY);
-iimage1DArray	KEYWORD(130, 999, IIMAGE1DARRAY);
-iimage2DArray	KEYWORD(130, 999, IIMAGE2DARRAY);
-uimage1DArray	KEYWORD(130, 999, UIMAGE1DARRAY);
-uimage2DArray	KEYWORD(130, 999, UIMAGE2DARRAY);
-image1DShadow	KEYWORD(130, 999, IMAGE1DSHADOW);
-image2DShadow	KEYWORD(130, 999, IMAGE2DSHADOW);
-image1DArrayShadow KEYWORD(130, 999, IMAGE1DARRAYSHADOW);
-image2DArrayShadow KEYWORD(130, 999, IMAGE2DARRAYSHADOW);
-imageBuffer	KEYWORD(130, 999, IMAGEBUFFER);
-iimageBuffer	KEYWORD(130, 999, IIMAGEBUFFER);
-uimageBuffer	KEYWORD(130, 999, UIMAGEBUFFER);
-row_major	KEYWORD(130, 140 || yyextra->ARB_uniform_buffer_object_enable, ROW_MAJOR);
+case		KEYWORD(130, 300, 130, 300, CASE);
+common		KEYWORD(130, 300, 0, 0, COMMON);
+partition	KEYWORD(130, 300, 0, 0, PARTITION);
+active		KEYWORD(130, 300, 0, 0, ACTIVE);
+superp		KEYWORD(130, 100, 0, 0, SUPERP);
+samplerBuffer	KEYWORD(130, 300, 140, 0, SAMPLERBUFFER);
+filter		KEYWORD(130, 300, 0, 0, FILTER);
+image1D		KEYWORD(130, 300, 0, 0, IMAGE1D);
+image2D		KEYWORD(130, 300, 0, 0, IMAGE2D);
+image3D		KEYWORD(130, 300, 0, 0, IMAGE3D);
+imageCube	KEYWORD(130, 300, 0, 0, IMAGECUBE);
+iimage1D	KEYWORD(130, 300, 0, 0, IIMAGE1D);
+iimage2D	KEYWORD(130, 300, 0, 0, IIMAGE2D);
+iimage3D	KEYWORD(130, 300, 0, 0, IIMAGE3D);
+iimageCube	KEYWORD(130, 300, 0, 0, IIMAGECUBE);
+uimage1D	KEYWORD(130, 300, 0, 0, UIMAGE1D);
+uimage2D	KEYWORD(130, 300, 0, 0, UIMAGE2D);
+uimage3D	KEYWORD(130, 300, 0, 0, UIMAGE3D);
+uimageCube	KEYWORD(130, 300, 0, 0, UIMAGECUBE);
+image1DArray	KEYWORD(130, 300, 0, 0, IMAGE1DARRAY);
+image2DArray	KEYWORD(130, 300, 0, 0, IMAGE2DARRAY);
+iimage1DArray	KEYWORD(130, 300, 0, 0, IIMAGE1DARRAY);
+iimage2DArray	KEYWORD(130, 300, 0, 0, IIMAGE2DARRAY);
+uimage1DArray	KEYWORD(130, 300, 0, 0, UIMAGE1DARRAY);
+uimage2DArray	KEYWORD(130, 300, 0, 0, UIMAGE2DARRAY);
+image1DShadow	KEYWORD(130, 300, 0, 0, IMAGE1DSHADOW);
+image2DShadow	KEYWORD(130, 300, 0, 0, IMAGE2DSHADOW);
+image1DArrayShadow KEYWORD(130, 300, 0, 0, IMAGE1DARRAYSHADOW);
+image2DArrayShadow KEYWORD(130, 300, 0, 0, IMAGE2DARRAYSHADOW);
+imageBuffer	KEYWORD(130, 300, 0, 0, IMAGEBUFFER);
+iimageBuffer	KEYWORD(130, 300, 0, 0, IIMAGEBUFFER);
+uimageBuffer	KEYWORD(130, 300, 0, 0, UIMAGEBUFFER);
+row_major	KEYWORD_WITH_ALT(130, 0, 140, 0, yyextra->ARB_uniform_buffer_object_enable, ROW_MAJOR);
 
     /* Additional reserved words in GLSL 1.40 */
-isampler2DRect	KEYWORD(140, 140, ISAMPLER2DRECT);
-usampler2DRect	KEYWORD(140, 140, USAMPLER2DRECT);
-isamplerBuffer	KEYWORD(140, 140, ISAMPLERBUFFER);
-usamplerBuffer	KEYWORD(140, 140, USAMPLERBUFFER);
+isampler2DRect	KEYWORD(140, 300, 140, 0, ISAMPLER2DRECT);
+usampler2DRect	KEYWORD(140, 300, 140, 0, USAMPLER2DRECT);
+isamplerBuffer	KEYWORD(140, 300, 140, 0, ISAMPLERBUFFER);
+usamplerBuffer	KEYWORD(140, 300, 140, 0, USAMPLERBUFFER);
+
+    /* Additional reserved words in GLSL ES 3.00 */
+coherent	KEYWORD(0, 300, 0, 0, COHERENT);
+restrict	KEYWORD(0, 300, 0, 0, RESTRICT);
+readonly	KEYWORD(0, 300, 0, 0, READONLY);
+writeonly	KEYWORD(0, 300, 0, 0, WRITEONLY);
+resource	KEYWORD(0, 300, 0, 0, RESOURCE);
+atomic_uint	KEYWORD(0, 300, 0, 0, ATOMIC_UINT);
+patch		KEYWORD(0, 300, 0, 0, PATCH);
+sample		KEYWORD(0, 300, 0, 0, SAMPLE);
+subroutine	KEYWORD(0, 300, 0, 0, SUBROUTINE);
+sampler2DMS	KEYWORD(0, 300, 0, 0, SAMPLER2DMS);
+isampler2DMS	KEYWORD(0, 300, 0, 0, ISAMPLER2DMS);
+usampler2DMS	KEYWORD(0, 300, 0, 0, USAMPLER2DMS);
+sampler2DMSArray KEYWORD(0, 300, 0, 0, SAMPLER2DMSARRAY);
+isampler2DMSArray KEYWORD(0, 300, 0, 0, ISAMPLER2DMSARRAY);
+usampler2DMSArray KEYWORD(0, 300, 0, 0, USAMPLER2DMSARRAY);
+
 
 [_a-zA-Z][_a-zA-Z0-9]*	{
 			    struct _mesa_glsl_parse_state *state = yyextra;
diff --git a/src/glsl/glsl_parser.yy b/src/glsl/glsl_parser.yy
index ee6a672..2ff68d6 100644
--- a/src/glsl/glsl_parser.yy
+++ b/src/glsl/glsl_parser.yy
@@ -135,6 +135,9 @@ static void yyerror(YYLTYPE *loc, _mesa_glsl_parse_state *st, const char *msg)
 %token HVEC2 HVEC3 HVEC4 DVEC2 DVEC3 DVEC4 FVEC2 FVEC3 FVEC4
 %token SAMPLER3DRECT
 %token SIZEOF CAST NAMESPACE USING
+%token COHERENT RESTRICT READONLY WRITEONLY RESOURCE ATOMIC_UINT PATCH SAMPLE
+%token SUBROUTINE SAMPLER2DMS ISAMPLER2DMS USAMPLER2DMS SAMPLER2DMSARRAY
+%token ISAMPLER2DMSARRAY USAMPLER2DMSARRAY
 
 %token ERROR_TOK
 
@@ -255,54 +258,12 @@ version_statement:
 	/* blank - no #version specified: defaults are already set */
 	| VERSION_TOK INTCONSTANT EOL
 	{
-	   bool supported = false;
-
-	   switch ($2) {
-	   case 100:
-	      state->es_shader = true;
-	      supported = state->ctx->API == API_OPENGLES2 ||
-		          state->ctx->Extensions.ARB_ES2_compatibility;
-	      break;
-	   case 110:
-	   case 120:
-	      /* FINISHME: Once the OpenGL 3.0 'forward compatible' context or
-	       * the OpenGL 3.2 Core context is supported, this logic will need
-	       * change.  Older versions of GLSL are no longer supported
-	       * outside the compatibility contexts of 3.x.
-	       */
-	   case 130:
-	   case 140:
-	   case 150:
-	   case 330:
-	   case 400:
-	   case 410:
-	   case 420:
-	      supported = _mesa_is_desktop_gl(state->ctx) &&
-			  ((unsigned) $2) <= state->ctx->Const.GLSLVersion;
-	      break;
-	   default:
-	      supported = false;
-	      break;
-	   }
-
-	   state->language_version = $2;
-	   state->version_string =
-	      ralloc_asprintf(state, "GLSL%s %d.%02d",
-			      state->es_shader ? " ES" : "",
-			      state->language_version / 100,
-			      state->language_version % 100);
-
-	   if (!supported) {
-	      _mesa_glsl_error(& @2, state, "%s is not supported. "
-			       "Supported versions are: %s\n",
-			       state->version_string,
-			       state->supported_version_string);
-	   }
-
-	   if (state->language_version >= 140) {
-	      state->ARB_uniform_buffer_object_enable = true;
-	   }
+           state->process_version_directive(&@2, $2, NULL);
 	}
+        | VERSION_TOK INTCONSTANT any_identifier EOL
+        {
+           state->process_version_directive(&@2, $2, $3);
+        }
 	;
 
 pragma_statement:
@@ -312,10 +273,11 @@ pragma_statement:
 	| PRAGMA_OPTIMIZE_OFF EOL
 	| PRAGMA_INVARIANT_ALL EOL
 	{
-	   if (state->language_version == 110) {
+	   if (!state->is_version(120, 100)) {
 	      _mesa_glsl_warning(& @1, state,
-				 "pragma `invariant(all)' not supported in %s",
-				 state->version_string);
+				 "pragma `invariant(all)' not supported in %s "
+                                 "(GLSL ES 1.00 or GLSL 1.20 required).",
+				 state->get_version_string());
 	   } else {
 	      state->all_invariant = true;
 	   }
@@ -1487,32 +1449,17 @@ basic_type_specifier_nonarray:
 
 precision_qualifier:
 	HIGHP	  {
-		     if (!state->es_shader && state->language_version < 130)
-			_mesa_glsl_error(& @1, state,
-				         "precision qualifier forbidden "
-					 "in %s (1.30 or later "
-					 "required)\n",
-					 state->version_string);
+                     state->check_precision_qualifiers_allowed(&@1);
 
 		     $$ = ast_precision_high;
 		  }
 	| MEDIUMP {
-		     if (!state->es_shader && state->language_version < 130)
-			_mesa_glsl_error(& @1, state,
-					 "precision qualifier forbidden "
-					 "in %s (1.30 or later "
-					 "required)\n",
-					 state->version_string);
+                     state->check_precision_qualifiers_allowed(&@1);
 
 		     $$ = ast_precision_medium;
 		  }
 	| LOWP	  {
-		     if (!state->es_shader && state->language_version < 130)
-			_mesa_glsl_error(& @1, state,
-					 "precision qualifier forbidden "
-					 "in %s (1.30 or later "
-					 "required)\n",
-					 state->version_string);
+                     state->check_precision_qualifiers_allowed(&@1);
 
 		     $$ = ast_precision_low;
 		  }
diff --git a/src/glsl/glsl_parser_extras.cpp b/src/glsl/glsl_parser_extras.cpp
index 872fcda..32c4d05 100644
--- a/src/glsl/glsl_parser_extras.cpp
+++ b/src/glsl/glsl_parser_extras.cpp
@@ -37,6 +37,16 @@ extern "C" {
 #include "ir_optimization.h"
 #include "loop_analysis.h"
 
+/**
+ * Format a short human-readable description of the given GLSL version.
+ */
+const char *
+glsl_compute_version_string(void *ctx, bool is_es, unsigned version)
+{
+   return ralloc_asprintf(ctx, "GLSL%s %d.%02d", is_es ? " ES" : "",
+                          version / 100, version % 100);
+}
+
 _mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
 					       GLenum target, void *mem_ctx)
  : ctx(_ctx)
@@ -82,6 +92,8 @@ _mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
    this->Const.MaxCombinedTextureImageUnits = ctx->Const.MaxCombinedTextureImageUnits;
    this->Const.MaxTextureImageUnits = ctx->Const.MaxTextureImageUnits;
    this->Const.MaxFragmentUniformComponents = ctx->Const.FragmentProgram.MaxUniformComponents;
+   this->Const.MinProgramTexelOffset = ctx->Const.MinProgramTexelOffset;
+   this->Const.MaxProgramTexelOffset = ctx->Const.MaxProgramTexelOffset;
 
    this->Const.MaxDrawBuffers = ctx->Const.MaxDrawBuffers;
 
@@ -113,6 +125,146 @@ _mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
    this->default_uniform_qualifier->flags.q.column_major = 1;
 }
 
+/**
+ * Determine whether the current GLSL version is sufficiently high to support
+ * a certain feature, and generate an error message if it isn't.
+ *
+ * \param required_glsl_version and \c required_glsl_es_version are
+ * interpreted as they are in _mesa_glsl_parse_state::is_version().
+ *
+ * \param locp is the parser location where the error should be reported.
+ *
+ * \param fmt (and additional arguments) constitute a printf-style error
+ * message to report if the version check fails.  Information about the
+ * current and required GLSL versions will be appended.  So, for example, if
+ * the GLSL version being compiled is 1.20, and check_version(130, 300, locp,
+ * "foo unsupported") is called, the error message will be "foo unsupported in
+ * GLSL 1.20 (GLSL 1.30 or GLSL 3.00 ES required)".
+ */
+bool
+_mesa_glsl_parse_state::check_version(unsigned required_glsl_version,
+                                      unsigned required_glsl_es_version,
+                                      YYLTYPE *locp, const char *fmt, ...)
+{
+   if (this->is_version(required_glsl_version, required_glsl_es_version))
+      return true;
+
+   va_list args;
+   va_start(args, fmt);
+   char *problem = ralloc_vasprintf(ctx, fmt, args);
+   va_end(args);
+   const char *glsl_version_string
+      = glsl_compute_version_string(ctx, false, required_glsl_version);
+   const char *glsl_es_version_string
+      = glsl_compute_version_string(ctx, true, required_glsl_es_version);
+   const char *requirement_string = "";
+   if (required_glsl_version && required_glsl_es_version) {
+      requirement_string = ralloc_asprintf(ctx, " (%s or %s required)",
+                                           glsl_version_string,
+                                           glsl_es_version_string);
+   } else if (required_glsl_version) {
+      requirement_string = ralloc_asprintf(ctx, " (%s required)",
+                                           glsl_version_string);
+   } else if (required_glsl_es_version) {
+      requirement_string = ralloc_asprintf(ctx, " (%s required)",
+                                           glsl_es_version_string);
+   }
+   _mesa_glsl_error(locp, this, "%s in %s%s.",
+                    problem, this->get_version_string(),
+                    requirement_string);
+
+   return false;
+}
+
+/**
+ * Process a GLSL #version directive.
+ *
+ * \param version is the integer that follows the #version token.
+ *
+ * \param ident is a string identifier that follows the integer, if any is
+ * present.  Otherwise NULL.
+ */
+void
+_mesa_glsl_parse_state::process_version_directive(YYLTYPE *locp, int version,
+                                                  const char *ident)
+{
+   bool es_token_present = false;
+   if (ident) {
+      if (strcmp(ident, "es") == 0) {
+         es_token_present = true;
+      } else {
+         _mesa_glsl_error(locp, this,
+                          "Illegal text following version number\n");
+      }
+   }
+
+   bool supported = false;
+
+   if (es_token_present) {
+      this->es_shader = true;
+      switch (version) {
+      case 100:
+         _mesa_glsl_error(locp, this,
+                          "GLSL 1.00 ES should be selected using "
+                          "`#version 100'\n");
+         supported = this->ctx->API == API_OPENGLES2 ||
+            this->ctx->Extensions.ARB_ES2_compatibility;
+         break;
+      case 300:
+         /* FIXME: we really should be comparing the API to API_OPENGLES3, but
+          * that enum doesn't exist yet.
+          */
+         supported = this->ctx->API == API_OPENGLES2 ||
+            this->ctx->Extensions.ARB_ES3_compatibility;
+         break;
+      default:
+         supported = false;
+         break;
+      }
+   } else {
+      switch (version) {
+      case 100:
+         this->es_shader = true;
+         supported = this->ctx->API == API_OPENGLES2 ||
+            this->ctx->Extensions.ARB_ES2_compatibility;
+         break;
+      case 110:
+      case 120:
+         /* FINISHME: Once the OpenGL 3.0 'forward compatible' context or
+          * the OpenGL 3.2 Core context is supported, this logic will need
+          * change.  Older versions of GLSL are no longer supported
+          * outside the compatibility contexts of 3.x.
+          */
+      case 130:
+      case 140:
+      case 150:
+      case 330:
+      case 400:
+      case 410:
+      case 420:
+         supported = _mesa_is_desktop_gl(this->ctx) &&
+            ((unsigned) version) <= this->ctx->Const.GLSLVersion;
+         break;
+      default:
+         supported = false;
+         break;
+      }
+   }
+
+   this->language_version = version;
+
+   if (!supported) {
+      _mesa_glsl_error(locp, this, "%s is not supported. "
+                       "Supported versions are: %s\n",
+                       this->get_version_string(),
+                       this->supported_version_string);
+   }
+
+   if (this->language_version >= 140) {
+      this->ARB_uniform_buffer_object_enable = true;
+   }
+}
+
 const char *
 _mesa_glsl_shader_target_name(enum _mesa_glsl_parser_targets target)
 {
diff --git a/src/glsl/glsl_parser_extras.h b/src/glsl/glsl_parser_extras.h
index 66463c5..8d11434 100644
--- a/src/glsl/glsl_parser_extras.h
+++ b/src/glsl/glsl_parser_extras.h
@@ -56,6 +56,19 @@ struct glsl_switch_state {
    bool is_switch_innermost; // if switch stmt is closest to break, ...
 };
 
+const char *
+glsl_compute_version_string(void *ctx, bool is_es, unsigned version);
+
+typedef struct YYLTYPE {
+   int first_line;
+   int first_column;
+   int last_line;
+   int last_column;
+   unsigned source;
+} YYLTYPE;
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+
 struct _mesa_glsl_parse_state {
    _mesa_glsl_parse_state(struct gl_context *_ctx, GLenum target,
 			  void *mem_ctx);
@@ -77,6 +90,55 @@ struct _mesa_glsl_parse_state {
       ralloc_free(mem);
    }
 
+   /**
+    * Generate a string representing the GLSL version currently being compiled
+    * (useful for error messages).
+    */
+   const char *get_version_string()
+   {
+      return glsl_compute_version_string(this, this->es_shader,
+                                         this->language_version);
+   }
+
+   /**
+    * Determine whether the current GLSL version is sufficiently high to
+    * support a certain feature.
+    *
+    * \param required_glsl_version is the desktop GLSL version that is
+    * required to support the feature, or 0 if no version of desktop GLSL
+    * supports the feature.
+    *
+    * \param required_glsl_es_version is the GLSL ES version that is required
+    * to support the feature, or 0 if no version of desktop GLSL suports the
+    * feature.
+    */
+   bool is_version(unsigned required_glsl_version,
+                   unsigned required_glsl_es_version)
+   {
+      unsigned required_version = this->es_shader ?
+         required_glsl_es_version : required_glsl_version;
+      return required_version != 0
+         && this->language_version >= required_version;
+   }
+
+   bool check_version(unsigned required_glsl_version,
+                      unsigned required_glsl_es_version,
+                      YYLTYPE *locp, const char *fmt, ...);
+
+   bool check_precision_qualifiers_allowed(YYLTYPE *locp)
+   {
+      return check_version(130, 100, locp,
+                           "precision qualifiers are forbidden");
+   }
+
+   bool check_bitwise_operations_allowed(YYLTYPE *locp)
+   {
+      return check_version(130, 300, locp, "bit-wise operations are forbidden");
+   }
+
+   void process_version_directive(YYLTYPE *locp, int version,
+                                  const char *ident);
+
    struct gl_context *const ctx;
    void *scanner;
    exec_list translation_unit;
@@ -88,7 +150,6 @@ struct _mesa_glsl_parse_state {
 
    bool es_shader;
    unsigned language_version;
-   const char *version_string;
    enum _mesa_glsl_parser_targets target;
 
    /**
@@ -129,6 +190,10 @@ struct _mesa_glsl_parse_state {
 
       /* ARB_draw_buffers */
       unsigned MaxDrawBuffers;
+
+      /* 3.00 ES */
+      int MinProgramTexelOffset;
+      int MaxProgramTexelOffset;
    } Const;
 
    /**
@@ -215,16 +280,6 @@ struct _mesa_glsl_parse_state {
    unsigned num_builtins_to_link;
 };
 
-typedef struct YYLTYPE {
-   int first_line;
-   int first_column;
-   int last_line;
-   int last_column;
-   unsigned source;
-} YYLTYPE;
-# define YYLTYPE_IS_DECLARED 1
-# define YYLTYPE_IS_TRIVIAL 1
-
 # define YYLLOC_DEFAULT(Current, Rhs, N)			\
 do {								\
    if (N)							\
diff --git a/src/glsl/glsl_symbol_table.cpp b/src/glsl/glsl_symbol_table.cpp
index bcb65d3..f934ea8 100644
--- a/src/glsl/glsl_symbol_table.cpp
+++ b/src/glsl/glsl_symbol_table.cpp
@@ -52,7 +52,7 @@ public:
 
 glsl_symbol_table::glsl_symbol_table()
 {
-   this->language_version = 120;
+   this->separate_function_namespace = false;
    this->table = _mesa_symbol_table_ctor();
    this->mem_ctx = ralloc_context(NULL);
 }
@@ -80,7 +80,7 @@ bool glsl_symbol_table::name_declared_this_scope(const char *name)
 
 bool glsl_symbol_table::add_variable(ir_variable *v)
 {
-   if (this->language_version == 110) {
+   if (this->separate_function_namespace) {
       /* In 1.10, functions and variables have separate namespaces. */
       symbol_table_entry *existing = get_entry(v->name);
       if (name_declared_this_scope(v->name)) {
@@ -120,7 +120,7 @@ bool glsl_symbol_table::add_type(const char *name, const glsl_type *t)
 
 bool glsl_symbol_table::add_function(ir_function *f)
 {
-   if (this->language_version == 110 && name_declared_this_scope(f->name)) {
+   if (this->separate_function_namespace && name_declared_this_scope(f->name)) {
       /* In 1.10, functions and variables have separate namespaces. */
       symbol_table_entry *existing = get_entry(f->name);
       if ((existing->f == NULL) && (existing->t == NULL)) {
diff --git a/src/glsl/glsl_symbol_table.h b/src/glsl/glsl_symbol_table.h
index 637bc03..9f56027 100644
--- a/src/glsl/glsl_symbol_table.h
+++ b/src/glsl/glsl_symbol_table.h
@@ -77,7 +77,8 @@ public:
    glsl_symbol_table();
    ~glsl_symbol_table();
 
-   unsigned int language_version;
+   /* In 1.10, functions and variables have separate namespaces. */
+   bool separate_function_namespace;
 
    void push_scope();
    void pop_scope();
diff --git a/src/glsl/glsl_types.cpp b/src/glsl/glsl_types.cpp
index 2aa51f0..71c1ef6 100644
--- a/src/glsl/glsl_types.cpp
+++ b/src/glsl/glsl_types.cpp
@@ -102,11 +102,16 @@ glsl_type::glsl_type(const glsl_struct_field *fields, unsigned num_fields,
 static void
 add_types_to_symbol_table(glsl_symbol_table *symtab,
 			  const struct glsl_type *types,
-			  unsigned num_types, bool warn)
+			  unsigned num_types, bool warn,
+                          bool skip_1d)
 {
    (void) warn;
 
    for (unsigned i = 0; i < num_types; i++) {
+      if (skip_1d && types[i].base_type == GLSL_TYPE_SAMPLER
+          && types[i].sampler_dimensionality == GLSL_SAMPLER_DIM_1D)
+         continue;
+
       symtab->add_type(types[i].name, & types[i]);
    }
 }
@@ -158,49 +163,68 @@ glsl_type::sampler_index() const
 void
 glsl_type::generate_100ES_types(glsl_symbol_table *symtab)
 {
+   bool skip_1d = false;
    add_types_to_symbol_table(symtab, builtin_core_types,
 			     Elements(builtin_core_types),
-			     false);
+			     false, skip_1d);
    add_types_to_symbol_table(symtab, builtin_structure_types,
 			     Elements(builtin_structure_types),
-			     false);
-   add_types_to_symbol_table(symtab, void_type, 1, false);
+			     false, skip_1d);
+   add_types_to_symbol_table(symtab, void_type, 1, false, skip_1d);
+}
+
+void
+glsl_type::generate_300ES_types(glsl_symbol_table *symtab)
+{
+   /* GLSL 3.00 ES types are the same as GLSL 1.30 types, except that 1D
+    * samplers are skipped, and samplerCubeShadow is added.
+    */
+   bool add_deprecated = false;
+   bool skip_1d = true;
+
+   generate_130_types(symtab, add_deprecated, skip_1d);
+
+   add_types_to_symbol_table(symtab, &_samplerCubeShadow_type, 1, false,
+                             skip_1d);
 }
 
 void
-glsl_type::generate_110_types(glsl_symbol_table *symtab, bool add_deprecated)
+glsl_type::generate_110_types(glsl_symbol_table *symtab, bool add_deprecated,
+                              bool skip_1d)
 {
    generate_100ES_types(symtab);
 
    add_types_to_symbol_table(symtab, builtin_110_types,
 			     Elements(builtin_110_types),
-			     false);
-   add_types_to_symbol_table(symtab, &_sampler3D_type, 1, false);
+			     false, skip_1d);
+   add_types_to_symbol_table(symtab, &_sampler3D_type, 1, false, skip_1d);
    if (add_deprecated) {
       add_types_to_symbol_table(symtab, builtin_110_deprecated_structure_types,
 				Elements(builtin_110_deprecated_structure_types),
-				false);
+				false, skip_1d);
    }
 }
 
 
 void
-glsl_type::generate_120_types(glsl_symbol_table *symtab, bool add_deprecated)
+glsl_type::generate_120_types(glsl_symbol_table *symtab, bool add_deprecated,
+                              bool skip_1d)
 {
-   generate_110_types(symtab, add_deprecated);
+   generate_110_types(symtab, add_deprecated, skip_1d);
 
    add_types_to_symbol_table(symtab, builtin_120_types,
-			     Elements(builtin_120_types), false);
+			     Elements(builtin_120_types), false, skip_1d);
 }
 
 
 void
-glsl_type::generate_130_types(glsl_symbol_table *symtab, bool add_deprecated)
+glsl_type::generate_130_types(glsl_symbol_table *symtab, bool add_deprecated,
+                              bool skip_1d)
 {
-   generate_120_types(symtab, add_deprecated);
+   generate_120_types(symtab, add_deprecated, skip_1d);
 
    add_types_to_symbol_table(symtab, builtin_130_types,
-			     Elements(builtin_130_types), false);
+			     Elements(builtin_130_types), false, skip_1d);
    generate_EXT_texture_array_types(symtab, false);
 }
 
@@ -208,14 +232,16 @@ glsl_type::generate_130_types(glsl_symbol_table *symtab, bool add_deprecated)
 void
 glsl_type::generate_140_types(glsl_symbol_table *symtab)
 {
-   generate_130_types(symtab, false);
+   bool skip_1d = false;
+
+   generate_130_types(symtab, false, skip_1d);
 
    add_types_to_symbol_table(symtab, builtin_140_types,
-			     Elements(builtin_140_types), false);
+			     Elements(builtin_140_types), false, skip_1d);
 
    add_types_to_symbol_table(symtab, builtin_EXT_texture_buffer_object_types,
 			     Elements(builtin_EXT_texture_buffer_object_types),
-			     false);
+			     false, skip_1d);
 }
 
 
@@ -223,9 +249,11 @@ void
 glsl_type::generate_ARB_texture_rectangle_types(glsl_symbol_table *symtab,
 						bool warn)
 {
+   bool skip_1d = false;
+
    add_types_to_symbol_table(symtab, builtin_ARB_texture_rectangle_types,
 			     Elements(builtin_ARB_texture_rectangle_types),
-			     warn);
+			     warn, skip_1d);
 }
 
 
@@ -233,16 +261,20 @@ void
 glsl_type::generate_EXT_texture_array_types(glsl_symbol_table *symtab,
 					    bool warn)
 {
+   bool skip_1d = false;
+
    add_types_to_symbol_table(symtab, builtin_EXT_texture_array_types,
 			     Elements(builtin_EXT_texture_array_types),
-			     warn);
+			     warn, skip_1d);
 }
 
 
 void
 glsl_type::generate_OES_texture_3D_types(glsl_symbol_table *symtab, bool warn)
 {
-   add_types_to_symbol_table(symtab, &_sampler3D_type, 1, warn);
+   bool skip_1d = false;
+
+   add_types_to_symbol_table(symtab, &_sampler3D_type, 1, warn, skip_1d);
 }
 
 
@@ -250,47 +282,63 @@ void
 glsl_type::generate_OES_EGL_image_external_types(glsl_symbol_table *symtab,
 						 bool warn)
 {
+   bool skip_1d = false;
+
    add_types_to_symbol_table(symtab, builtin_OES_EGL_image_external_types,
 			     Elements(builtin_OES_EGL_image_external_types),
-			     warn);
+			     warn, skip_1d);
 }
 
 void
 _mesa_glsl_initialize_types(struct _mesa_glsl_parse_state *state)
 {
-   switch (state->language_version) {
-   case 100:
-      assert(state->es_shader);
-      glsl_type::generate_100ES_types(state->symbols);
-      break;
-   case 110:
-      glsl_type::generate_110_types(state->symbols, true);
-      break;
-   case 120:
-      glsl_type::generate_120_types(state->symbols, true);
-      break;
-   case 130:
-      glsl_type::generate_130_types(state->symbols, true);
-      break;
-   case 140:
-      glsl_type::generate_140_types(state->symbols);
-      break;
-   default:
-      /* error */
-      break;
+   if (state->es_shader) {
+      switch (state->language_version) {
+      case 100:
+         assert(state->es_shader);
+         glsl_type::generate_100ES_types(state->symbols);
+         break;
+      case 300:
+         glsl_type::generate_300ES_types(state->symbols);
+         break;
+      default:
+         assert(!"Unexpected language version");
+         break;
+      }
+   } else {
+      bool skip_1d = false;
+      switch (state->language_version) {
+      case 110:
+         glsl_type::generate_110_types(state->symbols, true, skip_1d);
+         break;
+      case 120:
+         glsl_type::generate_120_types(state->symbols, true, skip_1d);
+         break;
+      case 130:
+         glsl_type::generate_130_types(state->symbols, true, skip_1d);
+         break;
+      case 140:
+         glsl_type::generate_140_types(state->symbols);
+         break;
+      default:
+         assert(!"Unexpected language version");
+         break;
+      }
    }
 
    if (state->ARB_texture_rectangle_enable ||
-       state->language_version >= 140) {
+       state->is_version(140, 0)) {
       glsl_type::generate_ARB_texture_rectangle_types(state->symbols,
 					   state->ARB_texture_rectangle_warn);
    }
-   if (state->OES_texture_3D_enable && state->language_version == 100) {
+   if (state->OES_texture_3D_enable
+       && state->is_version(0, 100)) {
       glsl_type::generate_OES_texture_3D_types(state->symbols,
 					       state->OES_texture_3D_warn);
    }
 
-   if (state->EXT_texture_array_enable && state->language_version < 130) {
+   if (state->EXT_texture_array_enable
+       && !state->is_version(130, 0)) {
       // These are already included in 130; don't create twice.
       glsl_type::generate_EXT_texture_array_types(state->symbols,
 				       state->EXT_texture_array_warn);
diff --git a/src/glsl/glsl_types.h b/src/glsl/glsl_types.h
index 915d1a2..6e11a02 100644
--- a/src/glsl/glsl_types.h
+++ b/src/glsl/glsl_types.h
@@ -510,6 +510,7 @@ private:
    static const glsl_type _error_type;
    static const glsl_type _void_type;
    static const glsl_type _sampler3D_type;
+   static const glsl_type _samplerCubeShadow_type;
    static const glsl_type builtin_core_types[];
    static const glsl_type builtin_structure_types[];
    static const glsl_type builtin_110_deprecated_structure_types[];
@@ -533,9 +534,13 @@ private:
     */
    /*@{*/
    static void generate_100ES_types(glsl_symbol_table *);
-   static void generate_110_types(glsl_symbol_table *, bool add_deprecated);
-   static void generate_120_types(glsl_symbol_table *, bool add_deprecated);
-   static void generate_130_types(glsl_symbol_table *, bool add_deprecated);
+   static void generate_300ES_types(glsl_symbol_table *);
+   static void generate_110_types(glsl_symbol_table *, bool add_deprecated,
+                                  bool skip_1d);
+   static void generate_120_types(glsl_symbol_table *, bool add_deprecated,
+                                  bool skip_1d);
+   static void generate_130_types(glsl_symbol_table *, bool add_deprecated,
+                                  bool skip_1d);
    static void generate_140_types(glsl_symbol_table *);
    static void generate_ARB_texture_rectangle_types(glsl_symbol_table *, bool);
    static void generate_EXT_texture_array_types(glsl_symbol_table *, bool);
diff --git a/src/glsl/hir_field_selection.cpp b/src/glsl/hir_field_selection.cpp
index 260b415..ac416d5 100644
--- a/src/glsl/hir_field_selection.cpp
+++ b/src/glsl/hir_field_selection.cpp
@@ -72,8 +72,7 @@ _mesa_ast_field_selection_to_hir(const ast_expression *expr,
       }
    } else if (expr->subexpressions[1] != NULL) {
       /* Handle "method calls" in GLSL 1.20 - namely, array.length() */
-      if (state->language_version < 120)
-	 _mesa_glsl_error(&loc, state, "Methods not supported in GLSL 1.10.");
+      state->check_version(120, 300, &loc, "Methods not supported");
 
       ast_expression *call = expr->subexpressions[1];
       assert(call->oper == ast_function_call);
diff --git a/src/glsl/linker.cpp b/src/glsl/linker.cpp
index 34ce133..98b8ddf 100644
--- a/src/glsl/linker.cpp
+++ b/src/glsl/linker.cpp
@@ -289,8 +289,11 @@ validate_vertex_shader_executable(struct gl_shader_program *prog,
     *      operations, if present, that operate on primitives after
     *      vertex processing has occurred. Its value is undefined if
     *      the vertex shader executable does not write gl_Position."
+    *
+    * GLSL ES 3.00 is similar to GLSL 1.40--failing to write to gl_Position is
+    * not an error.
     */
-   if (prog->Version < 140) {
+   if (prog->Version < (prog->IsEsProg ? 300 : 140)) {
       find_assignment_visitor find("gl_Position");
       find.run(shader->ir);
       if (!find.variable_found()) {
@@ -301,12 +304,15 @@ validate_vertex_shader_executable(struct gl_shader_program *prog,
 
    prog->Vert.ClipDistanceArraySize = 0;
 
-   if (prog->Version >= 130) {
+   if (!prog->IsEsProg && prog->Version >= 130) {
       /* From section 7.1 (Vertex Shader Special Variables) of the
        * GLSL 1.30 spec:
        *
        *   "It is an error for a shader to statically write both
        *   gl_ClipVertex and gl_ClipDistance."
+       *
+       * This does not apply to GLSL ES shaders, since GLSL ES defines neither
+       * gl_ClipVertex not gl_ClipDistance.
        */
       find_assignment_visitor clip_vertex("gl_ClipVertex");
       find_assignment_visitor clip_distance("gl_ClipDistance");
@@ -2144,7 +2150,7 @@ assign_varying_locations(struct gl_context *ctx,
       }
    }
 
-   if (ctx->API == API_OPENGLES2 || prog->Version == 100) {
+   if (ctx->API == API_OPENGLES2 || prog->IsEsProg) {
       if (varying_vectors > ctx->Const.MaxVarying) {
          if (ctx->Const.GLSLSkipStrictMaxVaryingLimitCheck) {
             linker_warning(prog, "shader uses too many varying vectors "
@@ -2421,9 +2427,19 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
 
    unsigned min_version = UINT_MAX;
    unsigned max_version = 0;
+   bool is_es_prog = false;
    for (unsigned i = 0; i < prog->NumShaders; i++) {
       min_version = MIN2(min_version, prog->Shaders[i]->Version);
       max_version = MAX2(max_version, prog->Shaders[i]->Version);
+      if (i == 0) {
+         is_es_prog = prog->Shaders[i]->IsEsShader;
+      } else {
+         if (prog->Shaders[i]->IsEsShader != is_es_prog) {
+            linker_error(prog, "all shaders must use same shading "
+                         "language version\n");
+            goto done;
+         }
+      }
 
       switch (prog->Shaders[i]->Type) {
       case GL_VERTEX_SHADER:
@@ -2444,10 +2460,10 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
    /* Previous to GLSL version 1.30, different compilation units could mix and
     * match shading language versions.  With GLSL 1.30 and later, the versions
     * of all shaders must match.
+    *
+    * GLSL ES has never allowed mixing of shading language versions.
     */
-   assert(min_version >= 100);
-   assert(max_version <= 140);
-   if ((max_version >= 130 || min_version == 100)
+   if ((is_es_prog || max_version >= 130)
        && min_version != max_version) {
       linker_error(prog, "all shaders must use same shading "
 		   "language version\n");
@@ -2455,6 +2471,7 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
    }
 
    prog->Version = max_version;
+   prog->IsEsProg = is_es_prog;
 
    for (unsigned int i = 0; i < MESA_SHADER_TYPES; i++) {
       if (prog->_LinkedShaders[i] != NULL)
@@ -2528,8 +2545,10 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
    /* Implement the GLSL 1.30+ rule for discard vs infinite loops Do
     * it before optimization because we want most of the checks to get
     * dropped thanks to constant propagation.
+    *
+    * This rule also applies to GLSL ES 3.00.
     */
-   if (max_version >= 130) {
+   if (max_version >= (is_es_prog ? 300 : 130)) {
       struct gl_shader *sh = prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
       if (sh) {
 	 lower_discard_flow(sh->ir);
@@ -2673,11 +2692,11 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
       goto done;
 
    /* OpenGL ES requires that a vertex shader and a fragment shader both be
-    * present in a linked program.  By checking for use of shading language
-    * version 1.00, we also catch the GL_ARB_ES2_compatibility case.
+    * present in a linked program.  By checking prog->IsEsProg, we also
+    * catch the GL_ARB_ES2_compatibility case.
     */
    if (!prog->InternalSeparateShader &&
-       (ctx->API == API_OPENGLES2 || prog->Version == 100)) {
+       (ctx->API == API_OPENGLES2 || prog->IsEsProg)) {
       if (prog->_LinkedShaders[MESA_SHADER_VERTEX] == NULL) {
 	 linker_error(prog, "program lacks a vertex shader\n");
       } else if (prog->_LinkedShaders[MESA_SHADER_FRAGMENT] == NULL) {
diff --git a/src/glsl/main.cpp b/src/glsl/main.cpp
index 64c2496..e33ca59 100644
--- a/src/glsl/main.cpp
+++ b/src/glsl/main.cpp
@@ -48,6 +48,7 @@ initialize_context(struct gl_context *ctx, gl_api api)
     * everything in order to compile the built-in functions.
     */
    ctx->Const.GLSLVersion = 140;
+   ctx->Extensions.ARB_ES3_compatibility = true;
 
    ctx->Const.MaxClipPlanes = 8;
    ctx->Const.MaxDrawBuffers = 2;
@@ -190,6 +191,7 @@ compile_shader(struct gl_context *ctx, struct gl_shader *shader)
    shader->symbols = state->symbols;
    shader->CompileStatus = !state->error;
    shader->Version = state->language_version;
+   shader->IsEsShader = state->es_shader;
    memcpy(shader->builtins_to_link, state->builtins_to_link,
 	  sizeof(shader->builtins_to_link[0]) * state->num_builtins_to_link);
    shader->num_builtins_to_link = state->num_builtins_to_link;
diff --git a/src/glsl/standalone_scaffolding.cpp b/src/glsl/standalone_scaffolding.cpp
index 679714e..9d327c9 100644
--- a/src/glsl/standalone_scaffolding.cpp
+++ b/src/glsl/standalone_scaffolding.cpp
@@ -73,6 +73,7 @@ void initialize_context_to_defaults(struct gl_context *ctx, gl_api api)
    ctx->Extensions.dummy_false = false;
    ctx->Extensions.dummy_true = true;
    ctx->Extensions.ARB_ES2_compatibility = true;
+   ctx->Extensions.ARB_ES3_compatibility = false;
    ctx->Extensions.ARB_draw_instanced = true;
    ctx->Extensions.ARB_fragment_coord_conventions = true;
    ctx->Extensions.EXT_texture_array = true;
diff --git a/src/mesa/Android.gen.mk b/src/mesa/Android.gen.mk
index 5443bb9..f5e6323 100644
--- a/src/mesa/Android.gen.mk
+++ b/src/mesa/Android.gen.mk
@@ -35,13 +35,10 @@ sources := \
 	main/api_exec_es1.c \
 	main/api_exec_es1_dispatch.h \
 	main/api_exec_es1_remap_helper.h \
-	main/api_exec_es2.c \
-	main/api_exec_es2_dispatch.h \
 	program/program_parse.tab.c \
 	program/lex.yy.c \
 	main/dispatch.h \
-	main/remap_helper.h \
-	main/api_exec_es2_remap_helper.h
+	main/remap_helper.h
 
 LOCAL_SRC_FILES := $(filter-out $(sources), $(LOCAL_SRC_FILES))
 
@@ -100,9 +97,6 @@ $(intermediates)/main/api_exec_%_remap_helper.h: PRIVATE_XML := -f $(glapi)/gl_a
 $(intermediates)/main/api_exec_es1.c: $(es_src_deps)
 	$(call es-gen, -V GLES1.1)
 
-$(intermediates)/main/api_exec_es2.c: $(es_src_deps)
-	$(call es-gen, -V GLES2.0)
-
 $(intermediates)/main/api_exec_%_dispatch.h: $(es_hdr_deps)
 	$(call es-gen, -c $* -m remap_table)
 
diff --git a/src/mesa/Makefile.am b/src/mesa/Makefile.am
index 85cdc1a..c25f4aa 100644
--- a/src/mesa/Makefile.am
+++ b/src/mesa/Makefile.am
@@ -49,10 +49,7 @@ BUILT_SOURCES = \
 	main/git_sha1.h \
 	main/api_exec_es1_dispatch.h \
 	main/api_exec_es1_remap_helper.h \
-	main/api_exec_es2_dispatch.h \
-	main/api_exec_es2_remap_helper.h \
 	main/api_exec_es1.c \
-	main/api_exec_es2.c \
 	program/program_parse.tab.c \
 	program/program_parse.tab.h \
 	program/lex.yy.c
@@ -68,22 +65,10 @@ main/api_exec_es1_remap_helper.h: $(GLAPI)/gl_and_es_API.xml $(glapi_gen_remap_d
 
 main/api_exec_es1.o: main/api_exec_es1_dispatch.h main/api_exec_es1_remap_helper.h
 
-main/api_exec_es2_dispatch.h: $(GLAPI)/gl_and_es_API.xml $(glapi_gen_dispatch_deps)
-	$(call glapi_gen_dispatch,$<,es2)
-
-main/api_exec_es2_remap_helper.h: $(GLAPI)/gl_and_es_API.xml $(glapi_gen_remap_deps)
-	$(call glapi_gen_remap,$<,es2)
-
-main/api_exec_es2.o: main/api_exec_es2_dispatch.h main/api_exec_es2_remap_helper.h
-
 main/api_exec_es1.c: main/APIspec.xml main/es_generator.py main/APIspecutil.py main/APIspec.py
 	$(PYTHON2) $(PYTHON_FLAGS) main/es_generator.py \
 	  -S $(srcdir)/main/APIspec.xml -V GLES1.1 > $@
 
-main/api_exec_es2.c: main/APIspec.xml main/es_generator.py main/APIspecutil.py main/APIspec.py
-	$(PYTHON2) $(PYTHON_FLAGS) main/es_generator.py \
-	  -S $(srcdir)/main/APIspec.xml -V GLES2.0 > $@
-
 program/program_parse.tab.c program/program_parse.tab.h: program/program_parse.y
 	mkdir -p program
 	$(YACC) -v -d --output=program/program_parse.tab.c $<
diff --git a/src/mesa/SConscript b/src/mesa/SConscript
index a3cbc16..41f77ca 100644
--- a/src/mesa/SConscript
+++ b/src/mesa/SConscript
@@ -345,12 +345,6 @@ if env['gles']:
         source = 'main/APIspec.xml',
         command = python_cmd + ' $SCRIPT -S $SOURCE -V GLES1.1 > $TARGET'
     )
-    gles_sources += env.CodeGenerate(
-        target = 'main/api_exec_es2.c',
-        script = 'main/es_generator.py',
-        source = 'main/APIspec.xml',
-        command = python_cmd + ' $SCRIPT -S $SOURCE -V GLES2.0 > $TARGET'
-    )
 
     # generate GLES headers
     gles_headers = []
@@ -366,18 +360,6 @@ if env['gles']:
         source = GLAPI + 'gen/gl_and_es_API.xml',
         command = python_cmd + ' $SCRIPT -c es1 -f $SOURCE > $TARGET',
     )
-    gles_headers += env.CodeGenerate(
-        target = 'main/api_exec_es2_dispatch.h',
-        script = GLAPI + 'gen/gl_table.py',
-        source = GLAPI + 'gen/gl_and_es_API.xml',
-        command = python_cmd + ' $SCRIPT -c es2 -m remap_table -f $SOURCE > $TARGET',
-    )
-    gles_headers += env.CodeGenerate(
-        target = 'main/api_exec_es2_remap_helper.h',
-        script = GLAPI + 'gen/remap_helper.py',
-        source = GLAPI + 'gen/gl_and_es_API.xml',
-        command = python_cmd + ' $SCRIPT -c es2 -f $SOURCE > $TARGET',
-    )
 
     env.Depends(gles_sources, gles_headers)
 
diff --git a/src/mesa/drivers/common/meta.c b/src/mesa/drivers/common/meta.c
index d36b1a3..2b3fe3b 100644
--- a/src/mesa/drivers/common/meta.c
+++ b/src/mesa/drivers/common/meta.c
@@ -547,8 +547,10 @@ _mesa_meta_begin(struct gl_context *ctx, GLbitfield state)
       save->PolygonCull = ctx->Polygon.CullFlag;
       _mesa_PolygonMode(GL_FRONT_AND_BACK, GL_FILL);
       _mesa_set_enable(ctx, GL_POLYGON_OFFSET_FILL, GL_FALSE);
-      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, GL_FALSE);
-      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, GL_FALSE);
+      if (ctx->API == API_OPENGL) {
+         _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, GL_FALSE);
+         _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, GL_FALSE);
+      }
       _mesa_set_enable(ctx, GL_CULL_FACE, GL_FALSE);
    }
 
@@ -558,14 +560,14 @@ _mesa_meta_begin(struct gl_context *ctx, GLbitfield state)
    }
 
    if (state & MESA_META_SHADER) {
-      if (ctx->Extensions.ARB_vertex_program) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ARB_vertex_program) {
          save->VertexProgramEnabled = ctx->VertexProgram.Enabled;
          _mesa_reference_vertprog(ctx, &save->VertexProgram,
 				  ctx->VertexProgram.Current);
          _mesa_set_enable(ctx, GL_VERTEX_PROGRAM_ARB, GL_FALSE);
       }
 
-      if (ctx->Extensions.ARB_fragment_program) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ARB_fragment_program) {
          save->FragmentProgramEnabled = ctx->FragmentProgram.Enabled;
          _mesa_reference_fragprog(ctx, &save->FragmentProgram,
 				  ctx->FragmentProgram.Current);
@@ -608,7 +610,9 @@ _mesa_meta_begin(struct gl_context *ctx, GLbitfield state)
              ctx->Texture.Unit[u].TexGenEnabled) {
             _mesa_ActiveTextureARB(GL_TEXTURE0 + u);
             _mesa_set_enable(ctx, GL_TEXTURE_1D, GL_FALSE);
+#ifdef ARGLEBARGLE
             _mesa_set_enable(ctx, GL_TEXTURE_2D, GL_FALSE);
+#endif
             _mesa_set_enable(ctx, GL_TEXTURE_3D, GL_FALSE);
             if (ctx->Extensions.ARB_texture_cube_map)
                _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);
@@ -739,11 +743,13 @@ _mesa_meta_begin(struct gl_context *ctx, GLbitfield state)
    }
 #endif
 
+#ifdef ARGLEBARGLE
    if (state & MESA_META_MULTISAMPLE) {
       save->MultisampleEnabled = ctx->Multisample.Enabled;
       if (ctx->Multisample.Enabled)
          _mesa_set_enable(ctx, GL_MULTISAMPLE, GL_FALSE);
    }
+#endif
 
    /* misc */
    {
@@ -840,9 +846,11 @@ _mesa_meta_end(struct gl_context *ctx)
    if (state & MESA_META_RASTERIZATION) {
       _mesa_PolygonMode(GL_FRONT, save->FrontPolygonMode);
       _mesa_PolygonMode(GL_BACK, save->BackPolygonMode);
-      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, save->PolygonStipple);
+      if (ctx->API == API_OPENGL) {
+         _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, save->PolygonStipple);
+         _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, save->PolygonSmooth);
+      }
       _mesa_set_enable(ctx, GL_POLYGON_OFFSET_FILL, save->PolygonOffset);
-      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, save->PolygonSmooth);
       _mesa_set_enable(ctx, GL_CULL_FACE, save->PolygonCull);
    }
 
@@ -853,7 +861,7 @@ _mesa_meta_end(struct gl_context *ctx)
    }
 
    if (state & MESA_META_SHADER) {
-      if (ctx->Extensions.ARB_vertex_program) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ARB_vertex_program) {
          _mesa_set_enable(ctx, GL_VERTEX_PROGRAM_ARB,
                           save->VertexProgramEnabled);
          _mesa_reference_vertprog(ctx, &ctx->VertexProgram.Current, 
@@ -861,7 +869,7 @@ _mesa_meta_end(struct gl_context *ctx)
 	 _mesa_reference_vertprog(ctx, &save->VertexProgram, NULL);
       }
 
-      if (ctx->Extensions.ARB_fragment_program) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ARB_fragment_program) {
          _mesa_set_enable(ctx, GL_FRAGMENT_PROGRAM_ARB,
                           save->FragmentProgramEnabled);
          _mesa_reference_fragprog(ctx, &ctx->FragmentProgram.Current,
@@ -894,7 +902,7 @@ _mesa_meta_end(struct gl_context *ctx)
 
       _mesa_set_enable(ctx, GL_STENCIL_TEST, stencil->Enabled);
       _mesa_ClearStencil(stencil->Clear);
-      if (ctx->Extensions.EXT_stencil_two_side) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.EXT_stencil_two_side) {
          _mesa_set_enable(ctx, GL_STENCIL_TEST_TWO_SIDE_EXT,
                           stencil->TestTwoSide);
          _mesa_ActiveStencilFaceEXT(stencil->ActiveFace
@@ -1388,17 +1396,21 @@ blitframebuffer_texture(struct gl_context *ctx,
          _mesa_SamplerParameteri(sampler, GL_TEXTURE_MAG_FILTER, filter);
          if (target != GL_TEXTURE_RECTANGLE_ARB) {
             _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, srcLevel);
-            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, srcLevel);
+            if (_mesa_is_desktop_gl(ctx)) {
+               _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, srcLevel);
+            }
          }
          _mesa_SamplerParameteri(sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
          _mesa_SamplerParameteri(sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
 	 /* Always do our blits with no sRGB decode or encode.*/
-	 if (ctx->Extensions.EXT_texture_sRGB_decode) {
+         if (_mesa_is_desktop_gl(ctx)
+             && ctx->Extensions.EXT_texture_sRGB_decode) {
 	    _mesa_SamplerParameteri(sampler, GL_TEXTURE_SRGB_DECODE_EXT,
 				GL_SKIP_DECODE_EXT);
 	 }
-         if (ctx->Extensions.EXT_framebuffer_sRGB) {
+         if (_mesa_is_desktop_gl(ctx)
+             && ctx->Extensions.EXT_framebuffer_sRGB) {
             _mesa_set_enable(ctx, GL_FRAMEBUFFER_SRGB_EXT, GL_FALSE);
          }
 
@@ -1457,9 +1469,12 @@ blitframebuffer_texture(struct gl_context *ctx,
           */
          if (target != GL_TEXTURE_RECTANGLE_ARB) {
             _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, baseLevelSave);
-            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
+            if (_mesa_is_desktop_gl(ctx)) {
+               _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
+            }
          }
-	 if (ctx->Extensions.EXT_framebuffer_sRGB && fbo_srgb_save) {
+         if (_mesa_is_desktop_gl(ctx)
+             && ctx->Extensions.EXT_framebuffer_sRGB && fbo_srgb_save) {
 	    _mesa_set_enable(ctx, GL_FRAMEBUFFER_SRGB_EXT, GL_TRUE);
 	 }
 
@@ -2694,6 +2709,12 @@ _mesa_meta_check_generate_mipmap_fallback(struct gl_context *ctx, GLenum target,
    GLuint srcLevel;
    GLenum status;
 
+   /* HACK: GLES2 doesn't support the fixed function paths that we need to
+    * generate mipmaps
+    */
+   if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+      return GL_TRUE;
+
    /* check for fallbacks */
    if (!ctx->Extensions.EXT_framebuffer_object ||
        target == GL_TEXTURE_3D ||
@@ -3076,7 +3097,8 @@ _mesa_meta_GenerateMipmap(struct gl_context *ctx, GLenum target,
       /* Allocate storage for the destination mipmap image(s) */
 
       /* Set MaxLevel large enough to hold the new level when we allocate it */
-      _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, dstLevel);
+      if (_mesa_is_desktop_gl(ctx))
+         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, dstLevel);
 
       if (!_mesa_prepare_mipmap_level(ctx, texObj, dstLevel,
                                       dstWidth, dstHeight, dstDepth,
@@ -3372,11 +3394,10 @@ decompress_texture_image(struct gl_context *ctx,
       _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
       _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
       /* No sRGB decode or encode.*/
-      if (ctx->Extensions.EXT_texture_sRGB_decode) {
+      if (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_sRGB_decode) {
          _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_SRGB_DECODE_EXT,
                              GL_SKIP_DECODE_EXT);
       }
-
    } else {
       _mesa_BindSampler(ctx->Texture.CurrentUnit, decompress->Sampler);
    }
@@ -3412,11 +3433,12 @@ decompress_texture_image(struct gl_context *ctx,
       /* restrict sampling to the texture level of interest */
       if (target != GL_TEXTURE_RECTANGLE_ARB) {
          _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, texImage->Level);
-         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, texImage->Level);
+         if (_mesa_is_desktop_gl(ctx))
+            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, texImage->Level);
       }
 
       /* No sRGB decode or encode.*/
-      if (ctx->Extensions.EXT_framebuffer_sRGB) {
+      if (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_framebuffer_sRGB) {
          _mesa_set_enable(ctx, GL_FRAMEBUFFER_SRGB_EXT, GL_FALSE);
       }
 
@@ -3428,7 +3450,8 @@ decompress_texture_image(struct gl_context *ctx,
        */
       if (target != GL_TEXTURE_RECTANGLE_ARB) {
          _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, baseLevelSave);
-         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
+         if (_mesa_is_desktop_gl(ctx))
+            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
       }
 
    }
diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
index d28f774..86409dd 100644
--- a/src/mesa/drivers/dri/common/dri_util.c
+++ b/src/mesa/drivers/dri/common/dri_util.c
@@ -244,8 +244,8 @@ dri2CreateContextAttribs(__DRIscreen *screen, int api,
      * anything specific about this case.  However, none of the known flags
      * have any meaning in an ES context, so this seems safe.
      */
-    if (mesa_api != __DRI_API_OPENGL
-        && mesa_api != __DRI_API_OPENGL_CORE
+    if (mesa_api != API_OPENGL
+        && mesa_api != API_OPENGL_CORE
         && flags != 0) {
 	*error = __DRI_CTX_ERROR_BAD_FLAG;
 	return NULL;
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index e72d5b6..2599862 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -108,6 +108,25 @@ brwCreateContext(int api,
    case API_OPENGLES:
    case API_OPENGLES2:
       break;
+   case API_OPENGL_CORE: {
+#ifdef TEXTURE_FLOAT_ENABLED
+      const unsigned max_version =
+         (screen->gen == 6 ||
+          (screen->gen == 7 && screen->kernel_has_gen7_sol_reset))
+         ? 0x301 : 0;
+#else
+      const unsigned max_version = 0;
+#endif
+      const unsigned req_version = (major_version << 8) | minor_version;
+
+      if (req_version > max_version) {
+         *error = (max_version == 0)
+            ? __DRI_CTX_ERROR_BAD_API : __DRI_CTX_ERROR_BAD_VERSION;
+         return false;
+      }
+
+      break;
+   }
    default:
       *error = __DRI_CTX_ERROR_BAD_API;
       return false;
diff --git a/src/mesa/drivers/dri/intel/intel_extensions.c b/src/mesa/drivers/dri/intel/intel_extensions.c
index 76b56a2..0eb916f 100755
--- a/src/mesa/drivers/dri/intel/intel_extensions.c
+++ b/src/mesa/drivers/dri/intel/intel_extensions.c
@@ -93,7 +93,11 @@ intelInitExtensions(struct gl_context *ctx)
    ctx->Extensions.OES_compressed_ETC1_RGB8_texture = true;
 
    if (intel->gen >= 6)
-      ctx->Const.GLSLVersion = 130;
+      if (ctx->API == API_OPENGL_CORE) {
+         ctx->Const.GLSLVersion = 140;
+      } else {
+         ctx->Const.GLSLVersion = 130;
+      }
    else
       ctx->Const.GLSLVersion = 120;
    _mesa_override_glsl_version(ctx);
@@ -106,6 +110,11 @@ intelInitExtensions(struct gl_context *ctx)
       ctx->Extensions.ARB_blend_func_extended = !driQueryOptionb(&intel->optionCache, "disable_blend_func_extended");
       ctx->Extensions.ARB_draw_buffers_blend = true;
       ctx->Extensions.ARB_uniform_buffer_object = true;
+      ctx->Extensions.ARB_ES3_compatibility = true;
+
+      if (ctx->API == API_OPENGL_CORE) {
+         ctx->Extensions.ARB_texture_buffer_object = true;
+      }
    }
 
    if (intel->gen >= 5)
diff --git a/src/mesa/drivers/dri/intel/intel_screen.c b/src/mesa/drivers/dri/intel/intel_screen.c
index 034499b..a3bc597 100644
--- a/src/mesa/drivers/dri/intel/intel_screen.c
+++ b/src/mesa/drivers/dri/intel/intel_screen.c
@@ -720,23 +720,6 @@ intelCreateContext(gl_api api,
    struct intel_screen *intelScreen = sPriv->driverPrivate;
    bool success = false;
 
-   switch (api) {
-   case API_OPENGL:
-   case API_OPENGLES:
-      break;
-   case API_OPENGLES2:
-#ifdef I915
-      if (!IS_9XX(intelScreen->deviceID)) {
-         *error = __DRI_CTX_ERROR_BAD_API;
-         return false;
-      }
-#endif
-      break;
-   case API_OPENGL_CORE:
-      *error = __DRI_CTX_ERROR_BAD_API;
-      return GL_FALSE;
-   }
-
 #ifdef I915
    if (IS_9XX(intelScreen->deviceID)) {
       success = i915CreateContext(api, mesaVis, driContextPriv,
@@ -747,22 +730,22 @@ intelCreateContext(gl_api api,
       case API_OPENGL:
          if (major_version > 1 || minor_version > 3) {
             *error = __DRI_CTX_ERROR_BAD_VERSION;
-            return false;
+            success = false;
          }
          break;
       case API_OPENGLES:
          break;
       default:
          *error = __DRI_CTX_ERROR_BAD_API;
-         return false;
+         success = false;
       }
 
-      intelScreen->no_vbo = true;
-      success = i830CreateContext(mesaVis, driContextPriv,
-				  sharedContextPrivate);
-      if (!success) {
-         *error = __DRI_CTX_ERROR_NO_MEMORY;
-         return false;
+      if (success) {
+         intelScreen->no_vbo = true;
+         success = i830CreateContext(mesaVis, driContextPriv,
+                                     sharedContextPrivate);
+         if (!success)
+            *error = __DRI_CTX_ERROR_NO_MEMORY;
       }
    }
 #else
@@ -772,22 +755,10 @@ intelCreateContext(gl_api api,
                               sharedContextPrivate);
 #endif
 
-   if (success) {
-      struct gl_context *ctx =
-	 (struct gl_context *) driContextPriv->driverPrivate;
-
-      _mesa_compute_version(ctx);
-      if (ctx->Version >= major_version * 10 + minor_version) {
-	 return true;
-      }
-
-      *error = __DRI_CTX_ERROR_BAD_VERSION;
-      intelDestroyContext(driContextPriv);
-   } else {
-      *error = __DRI_CTX_ERROR_NO_MEMORY;
-      fprintf(stderr, "Unrecognized deviceID 0x%x\n", intelScreen->deviceID);
-   }
+   if (success)
+      return true;
 
+   intelDestroyContext(driContextPriv);
    return false;
 }
 
diff --git a/src/mesa/main/.gitignore b/src/mesa/main/.gitignore
index caed74f..b26be22 100644
--- a/src/mesa/main/.gitignore
+++ b/src/mesa/main/.gitignore
@@ -1,5 +1,4 @@
 api_exec_es1.c
-api_exec_es2.c
 dispatch.h
 enums.c
 get_es1.c
@@ -8,6 +7,4 @@ git_sha1.h
 git_sha1.h.tmp
 api_exec_es1_dispatch.h
 api_exec_es1_remap_helper.h
-api_exec_es2_dispatch.h
-api_exec_es2_remap_helper.h
 remap_helper.h
diff --git a/src/mesa/main/APIspec.xml b/src/mesa/main/APIspec.xml
index b6cf52d..a65c5c5 100644
--- a/src/mesa/main/APIspec.xml
+++ b/src/mesa/main/APIspec.xml
@@ -48,12 +48,6 @@
 		<return type="void"/>
 		<param name="mode" type="GLenum"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_FRONT"/>
-		<value name="GL_BACK"/>
-		<value name="GL_FRONT_AND_BACK"/>
-	</desc>
 </template>
 
 <template name="Fog">
@@ -64,29 +58,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-        <desc name="pname">
-		<value name="GL_FOG_MODE"/>
-		<desc name="param">
-			<value name="GL_EXP"/>
-			<value name="GL_EXP2"/>
-			<value name="GL_LINEAR"/>
-		</desc>
-        </desc>
-
-	<desc name="pname">
-		<value name="GL_FOG_COLOR"/>
-
-		<desc name="params" vector_size="4"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_FOG_DENSITY"/>
-		<value name="GL_FOG_START"/>
-		<value name="GL_FOG_END"/>
-
-		<desc name="params" vector_size="1"/>
-	</desc>
 </template>
 
 <template name="FrontFace">
@@ -94,11 +65,6 @@
 		<return type="void"/>
 		<param name="mode" type="GLenum"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_CW"/>
-		<value name="GL_CCW"/>
-	</desc>
 </template>
 
 <template name="Hint">
@@ -107,25 +73,6 @@
 		<param name="target" type="GLenum"/>
 		<param name="mode" type="GLenum"/>
 	</proto>
-
-	<desc name="target" category="GLES1.1">
-		<value name="GL_FOG_HINT"/>
-		<value name="GL_LINE_SMOOTH_HINT"/>
-		<value name="GL_PERSPECTIVE_CORRECTION_HINT"/>
-		<value name="GL_POINT_SMOOTH_HINT"/>
-	</desc>
-	<desc name="target" category="OES_standard_derivatives">
-		<value name="GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES"/>
-	</desc>
-	<desc name="target">
-		<value name="GL_GENERATE_MIPMAP_HINT"/>
-	</desc>
-
-	<desc name="mode">
-		<value name="GL_FASTEST"/>
-		<value name="GL_NICEST"/>
-		<value name="GL_DONT_CARE"/>
-	</desc>
 </template>
 
 <template name="Light">
@@ -137,35 +84,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="light">
-		<range base="GL_LIGHT" from="0" to="7"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_AMBIENT"/>
-		<value name="GL_DIFFUSE"/>
-		<value name="GL_SPECULAR"/>
-		<value name="GL_POSITION"/>
-
-		<desc name="params" vector_size="4"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_SPOT_DIRECTION"/>
-
-		<desc name="params" vector_size="3"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_SPOT_EXPONENT"/>
-		<value name="GL_SPOT_CUTOFF"/>
-		<value name="GL_CONSTANT_ATTENUATION"/>
-		<value name="GL_LINEAR_ATTENUATION"/>
-		<value name="GL_QUADRATIC_ATTENUATION"/>
-
-		<desc name="params" vector_size="1"/>
-	</desc>
 </template>
 
 <template name="LightModel">
@@ -176,20 +94,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_LIGHT_MODEL_AMBIENT"/>
-
-		<desc name="params" vector_size="4"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_LIGHT_MODEL_TWO_SIDE"/>
-		<desc name="param">
-			<value name="GL_TRUE"/>
-			<value name="GL_FALSE"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="LineWidth">
@@ -208,26 +112,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="face">
-		<value name="GL_FRONT_AND_BACK"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_AMBIENT"/>
-		<value name="GL_DIFFUSE"/>
-		<value name="GL_AMBIENT_AND_DIFFUSE"/>
-		<value name="GL_SPECULAR"/>
-		<value name="GL_EMISSION"/>
-
-		<desc name="params" vector_size="4"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_SHININESS"/>
-
-		<desc name="params" vector_size="1"/>
-	</desc>
 </template>
 
 <template name="PointSize">
@@ -244,11 +128,6 @@
 		<param name="stride" type="GLsizei"/>
 		<param name="pointer" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="type">
-		<value name="GL_FLOAT"/>
-		<value name="GL_FIXED"/>
-	</desc>
 </template>
 
 <template name="Scissor">
@@ -266,11 +145,6 @@
 		<return type="void"/>
 		<param name="mode" type="GLenum"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_FLAT"/>
-		<value name="GL_SMOOTH"/>
-	</desc>
 </template>
 
 <template name="TexParameter">
@@ -282,68 +156,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_3D_OES" category="OES_texture_3D"/>
-		<value name="GL_TEXTURE_EXTERNAL_OES" category="OES_EGL_image_external"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_WRAP_S"/>
-		<value name="GL_TEXTURE_WRAP_T"/>
-		<value name="GL_TEXTURE_WRAP_R_OES" category="OES_texture_3D"/>
-
-		<desc name="param">
-			<value name="GL_CLAMP_TO_EDGE"/>
-			<value name="GL_REPEAT"/>
-			<value name="GL_MIRRORED_REPEAT" category="GLES2.0"/>
-			<value name="GL_MIRRORED_REPEAT_OES" category="OES_texture_mirrored_repeat"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_MIN_FILTER"/>
-
-		<desc name="param">
-			<value name="GL_NEAREST"/>
-			<value name="GL_LINEAR"/>
-			<value name="GL_NEAREST_MIPMAP_NEAREST"/>
-			<value name="GL_NEAREST_MIPMAP_LINEAR"/>
-			<value name="GL_LINEAR_MIPMAP_NEAREST"/>
-			<value name="GL_LINEAR_MIPMAP_LINEAR"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_MAG_FILTER"/>
-
-		<desc name="param">
-			<value name="GL_NEAREST"/>
-			<value name="GL_LINEAR"/>
-		</desc>
-	</desc>
-
-	<desc name="pname" category="GLES1.1">
-		<value name="GL_GENERATE_MIPMAP"/>
-
-		<desc name="param">
-			<value name="GL_TRUE"/>
-			<value name="GL_FALSE"/>
-		</desc>
-	</desc>
-
-	<desc name="pname" category="EXT_texture_filter_anisotropic">
-		<value name="GL_TEXTURE_MAX_ANISOTROPY_EXT"/>
-		<desc name="params" vector_size="1"/>
-	</desc>
-
-	<desc name="pname" category="OES_draw_texture">
-		<value name="GL_TEXTURE_CROP_RECT_OES"/>
-		<desc name="params" vector_size="4"/>
-	</desc>
 </template>
 
 <template name="TexImage2D">
@@ -359,168 +171,6 @@
 		<param name="type" type="GLenum"/>
 		<param name="pixels" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES" category="OES_texture_cube_map"/>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_ALPHA"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_ALPHA"/>
-		</desc>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_RGB"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_RGB"/>
-		</desc>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_RGBA"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_RGBA"/>
-		</desc>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_LUMINANCE"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_LUMINANCE"/>
-		</desc>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_LUMINANCE_ALPHA"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_LUMINANCE_ALPHA"/>
-		</desc>
-	</desc>
-
-	<desc name="internalFormat" category="OES_depth_texture">
-		<value name="GL_DEPTH_COMPONENT"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_DEPTH_COMPONENT"/>
-		</desc>
-	</desc>
-
-	<desc name="internalFormat" category="OES_packed_depth_stencil">
-		<value name="GL_DEPTH_STENCIL_OES"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_DEPTH_STENCIL_OES"/>
-		</desc>
-	</desc>
-
-	<desc name="internalFormat" category="EXT_texture_format_BGRA8888">
-		<value name="GL_BGRA_EXT"/>
-
-		<desc name="format" error="GL_INVALID_VALUE">
-			<value name="GL_BGRA_EXT"/>
-		</desc>
-	</desc>
-
-	<desc name="border" error="GL_INVALID_VALUE">
-		<value name="0"/>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGB"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_5_6_5"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGBA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_4_4_4_4"/>
-			<value name="GL_UNSIGNED_SHORT_5_5_5_1"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-			<value name="GL_UNSIGNED_INT_2_10_10_10_REV_EXT" category="EXT_texture_type_2_10_10_10_REV"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format" category="OES_depth_texture">
-		<value name="GL_DEPTH_COMPONENT"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_SHORT"/>
-			<value name="GL_UNSIGNED_INT"/>
-		</desc>
-	</desc>
-
-	<desc name="format" category="OES_packed_depth_stencil">
-		<value name="GL_DEPTH_STENCIL_OES"/>
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_INT_24_8_OES"/>
-		</desc>
-	</desc>
-
-	<desc name="format" category="EXT_texture_format_BGRA8888">
-		<value name="GL_BGRA_EXT"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="TexEnv">
@@ -532,155 +182,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="target" category="OES_point_sprite">
-		<value name="GL_POINT_SPRITE_OES"/>
-
-		<desc name="pname">
-			<value name="GL_COORD_REPLACE_OES"/>
-		</desc>
-	</desc>
-
-	<desc name="pname" category="OES_point_sprite">
-		<value name="GL_COORD_REPLACE_OES"/>
-
-		<desc name="param">
-			<value name="GL_TRUE"/>
-			<value name="GL_FALSE"/>
-		</desc>
-	</desc>
-
-	<desc name="target" category="EXT_texture_lod_bias">
-		<value name="GL_TEXTURE_FILTER_CONTROL_EXT"/>
-
-		<desc name="pname">
-			<value name="GL_TEXTURE_LOD_BIAS_EXT"/>
-		</desc>
-	</desc>
-
-	<desc name="pname" category="EXT_texture_lod_bias">
-		<value name="GL_TEXTURE_LOD_BIAS_EXT"/>
-		<desc name="params" vector_size="1"/>
-	</desc>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_ENV"/>
-
-		<desc name="pname">
-			<value name="GL_TEXTURE_ENV_MODE"/>
-			<value name="GL_COMBINE_RGB"/>
-			<value name="GL_COMBINE_ALPHA"/>
-			<value name="GL_RGB_SCALE"/>
-			<value name="GL_ALPHA_SCALE"/>
-			<value name="GL_SRC0_RGB"/>
-			<value name="GL_SRC1_RGB"/>
-			<value name="GL_SRC2_RGB"/>
-			<value name="GL_SRC0_ALPHA"/>
-			<value name="GL_SRC1_ALPHA"/>
-			<value name="GL_SRC2_ALPHA"/>
-			<value name="GL_OPERAND0_RGB"/>
-			<value name="GL_OPERAND1_RGB"/>
-			<value name="GL_OPERAND2_RGB"/>
-			<value name="GL_OPERAND0_ALPHA"/>
-			<value name="GL_OPERAND1_ALPHA"/>
-			<value name="GL_OPERAND2_ALPHA"/>
-			<value name="GL_TEXTURE_ENV_COLOR"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_ENV_MODE"/>
-
-		<desc name="param">
-			<value name="GL_REPLACE"/>
-			<value name="GL_MODULATE"/>
-			<value name="GL_DECAL"/>
-			<value name="GL_BLEND"/>
-			<value name="GL_ADD"/>
-			<value name="GL_COMBINE"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_COMBINE_RGB"/>
-
-		<desc name="param">
-			<value name="GL_REPLACE"/>
-			<value name="GL_MODULATE"/>
-			<value name="GL_ADD"/>
-			<value name="GL_ADD_SIGNED"/>
-			<value name="GL_INTERPOLATE"/>
-			<value name="GL_SUBTRACT"/>
-			<value name="GL_DOT3_RGB"/>
-			<value name="GL_DOT3_RGBA"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_COMBINE_ALPHA"/>
-
-		<desc name="param">
-			<value name="GL_REPLACE"/>
-			<value name="GL_MODULATE"/>
-			<value name="GL_ADD"/>
-			<value name="GL_ADD_SIGNED"/>
-			<value name="GL_INTERPOLATE"/>
-			<value name="GL_SUBTRACT"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_RGB_SCALE"/>
-		<value name="GL_ALPHA_SCALE"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_SRC0_RGB"/>
-		<value name="GL_SRC1_RGB"/>
-		<value name="GL_SRC2_RGB"/>
-		<value name="GL_SRC0_ALPHA"/>
-		<value name="GL_SRC1_ALPHA"/>
-		<value name="GL_SRC2_ALPHA"/>
-
-		<desc name="param">
-			<value name="GL_TEXTURE"/>
-			<value name="GL_CONSTANT"/>
-			<value name="GL_PRIMARY_COLOR"/>
-			<value name="GL_PREVIOUS"/>
-
-			<range base="GL_TEXTURE" from="0" to="31" category="OES_texture_env_crossbar"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_OPERAND0_RGB"/>
-		<value name="GL_OPERAND1_RGB"/>
-		<value name="GL_OPERAND2_RGB"/>
-
-		<desc name="param">
-			<value name="GL_SRC_COLOR"/>
-			<value name="GL_ONE_MINUS_SRC_COLOR"/>
-			<value name="GL_SRC_ALPHA"/>
-			<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_OPERAND0_ALPHA"/>
-		<value name="GL_OPERAND1_ALPHA"/>
-		<value name="GL_OPERAND2_ALPHA"/>
-
-		<desc name="param">
-			<value name="GL_SRC_ALPHA"/>
-			<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_ENV_COLOR"/>
-
-		<desc name="params" vector_size="4"/>
-	</desc>
 </template>
 
 <template name="TexGen">
@@ -692,19 +193,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="coord" category="OES_texture_cube_map">
-		<value name="GL_TEXTURE_GEN_STR_OES"/>
-	</desc>
-
-	<desc name="pname" category="OES_texture_cube_map">
-		<value name="GL_TEXTURE_GEN_MODE_OES"/>
-
-		<desc name="param">
-			<value name="GL_NORMAL_MAP_OES"/>
-			<value name="GL_REFLECTION_MAP_OES"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="Clear">
@@ -712,17 +200,6 @@
 		<return type="void"/>
 		<param name="mask" type="GLbitfield"/>
 	</proto>
-
-	<desc name="mask" error="GL_INVALID_VALUE">
-		<value name="0"/>
-		<value name="(GL_COLOR_BUFFER_BIT)"/>
-		<value name="(GL_DEPTH_BUFFER_BIT)"/>
-		<value name="(GL_STENCIL_BUFFER_BIT)"/>
-		<value name="(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)"/>
-		<value name="(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)"/>
-		<value name="(GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)"/>
-		<value name="(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)"/>
-	</desc>
 </template>
 
 <template name="ClearColor">
@@ -762,12 +239,6 @@
 		<param name="face" type="GLenum"/>
 		<param name="mask" type="GLuint"/>
 	</proto>
-
-	<desc name="face">
-		<value name="GL_FRONT"/>
-		<value name="GL_BACK"/>
-		<value name="GL_FRONT_AND_BACK"/>
-	</desc>
 </template>
 
 <template name="ColorMask">
@@ -792,56 +263,6 @@
 		<return type="void"/>
 		<param name="cap" type="GLenum"/>
 	</proto>
-
-	<desc name="cap" category="GLES1.1">
-		<value name="GL_NORMALIZE"/>
-		<value name="GL_RESCALE_NORMAL"/>
-
-		<range base="GL_CLIP_PLANE" from="0" to="5"/>
-		<value name="GL_CLIP_PLANE0+6"/>
-		<value name="GL_CLIP_PLANE0+7"/>
-
-		<value name="GL_FOG"/>
-		<value name="GL_LIGHTING"/>
-		<value name="GL_COLOR_MATERIAL"/>
-
-		<range base="GL_LIGHT" from="0" to="7"/>
-
-		<value name="GL_POINT_SMOOTH"/>
-		<value name="GL_LINE_SMOOTH"/>
-		<value name="GL_CULL_FACE"/>
-		<value name="GL_POLYGON_OFFSET_FILL"/>
-		<value name="GL_MULTISAMPLE"/>
-		<value name="GL_SAMPLE_ALPHA_TO_COVERAGE"/>
-		<value name="GL_SAMPLE_ALPHA_TO_ONE"/>
-		<value name="GL_SAMPLE_COVERAGE"/>
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_SCISSOR_TEST"/>
-		<value name="GL_ALPHA_TEST"/>
-		<value name="GL_STENCIL_TEST"/>
-		<value name="GL_DEPTH_TEST"/>
-		<value name="GL_BLEND"/>
-		<value name="GL_DITHER"/>
-		<value name="GL_COLOR_LOGIC_OP"/>
-
-		<value name="GL_POINT_SPRITE_OES" category="OES_point_sprite"/>
-		<value name="GL_MATRIX_PALETTE_OES" category="OES_matrix_palette"/>
-		<value name="GL_TEXTURE_CUBE_MAP_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_GEN_STR_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_EXTERNAL_OES" category="OES_EGL_image_external"/>
-	</desc>
-
-	<desc name="cap" category="GLES2.0">
-		<value name="GL_CULL_FACE"/>
-		<value name="GL_SCISSOR_TEST"/>
-		<value name="GL_POLYGON_OFFSET_FILL"/>
-		<value name="GL_SAMPLE_ALPHA_TO_COVERAGE"/>
-		<value name="GL_SAMPLE_COVERAGE"/>
-		<value name="GL_STENCIL_TEST"/>
-		<value name="GL_DEPTH_TEST"/>
-		<value name="GL_DITHER"/>
-		<value name="GL_BLEND"/>
-	</desc>
 </template>
 
 <!-- it is exactly the same as Disable -->
@@ -850,56 +271,6 @@
 		<return type="void"/>
 		<param name="cap" type="GLenum"/>
 	</proto>
-
-	<desc name="cap" category="GLES1.1">
-		<value name="GL_NORMALIZE"/>
-		<value name="GL_RESCALE_NORMAL"/>
-
-		<range base="GL_CLIP_PLANE" from="0" to="5"/>
-		<value name="GL_CLIP_PLANE0+6"/>
-		<value name="GL_CLIP_PLANE0+7"/>
-
-		<value name="GL_FOG"/>
-		<value name="GL_LIGHTING"/>
-		<value name="GL_COLOR_MATERIAL"/>
-
-		<range base="GL_LIGHT" from="0" to="7"/>
-
-		<value name="GL_POINT_SMOOTH"/>
-		<value name="GL_LINE_SMOOTH"/>
-		<value name="GL_CULL_FACE"/>
-		<value name="GL_POLYGON_OFFSET_FILL"/>
-		<value name="GL_MULTISAMPLE"/>
-		<value name="GL_SAMPLE_ALPHA_TO_COVERAGE"/>
-		<value name="GL_SAMPLE_ALPHA_TO_ONE"/>
-		<value name="GL_SAMPLE_COVERAGE"/>
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_SCISSOR_TEST"/>
-		<value name="GL_ALPHA_TEST"/>
-		<value name="GL_STENCIL_TEST"/>
-		<value name="GL_DEPTH_TEST"/>
-		<value name="GL_BLEND"/>
-		<value name="GL_DITHER"/>
-		<value name="GL_COLOR_LOGIC_OP"/>
-
-		<value name="GL_POINT_SPRITE_OES" category="OES_point_sprite"/>
-		<value name="GL_MATRIX_PALETTE_OES" category="OES_matrix_palette"/>
-		<value name="GL_TEXTURE_CUBE_MAP_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_GEN_STR_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_EXTERNAL_OES" category="OES_EGL_image_external"/>
-	</desc>
-
-	<desc name="cap" category="GLES2.0">
-		<value name="GL_CULL_FACE"/>
-		<value name="GL_SCISSOR_TEST"/>
-		<value name="GL_POLYGON_OFFSET_FILL"/>
-		<value name="GL_SAMPLE_ALPHA_TO_COVERAGE"/>
-		<value name="GL_SAMPLE_COVERAGE"/>
-		<value name="GL_STENCIL_TEST"/>
-		<value name="GL_DEPTH_TEST"/>
-		<value name="GL_DITHER"/>
-		<value name="GL_BLEND"/>
-	</desc>
 </template>
 
 <template name="Finish">
@@ -920,16 +291,6 @@
 		<param name="func" type="GLenum"/>
 		<param name="ref" type="GLtype"/>
 	</proto>
-	<desc name="func">
-		<value name="GL_NEVER"/>
-		<value name="GL_LESS"/>
-		<value name="GL_EQUAL"/>
-		<value name="GL_LEQUAL"/>
-		<value name="GL_GREATER"/>
-		<value name="GL_NOTEQUAL"/>
-		<value name="GL_GEQUAL"/>
-		<value name="GL_ALWAYS"/>
-	</desc>
 </template>
 
 <template name="BlendFunc">
@@ -938,43 +299,6 @@
 		<param name="sfactor" type="GLenum"/>
 		<param name="dfactor" type="GLenum"/>
 	</proto>
-
-	<desc name="sfactor">
-		<value name="GL_ZERO"/>
-		<value name="GL_ONE"/>
-		<value name="GL_SRC_COLOR"/>
-		<value name="GL_ONE_MINUS_SRC_COLOR"/>
-		<value name="GL_SRC_ALPHA"/>
-		<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		<value name="GL_DST_ALPHA"/>
-		<value name="GL_ONE_MINUS_DST_ALPHA"/>
-		<value name="GL_DST_COLOR"/>
-		<value name="GL_ONE_MINUS_DST_COLOR"/>
-		<value name="GL_SRC_ALPHA_SATURATE"/>
-
-		<value name="GL_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_CONSTANT_ALPHA" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_ALPHA" category="GLES2.0"/>
-	</desc>
-
-	<desc name="dfactor">
-		<value name="GL_ZERO"/>
-		<value name="GL_ONE"/>
-		<value name="GL_SRC_COLOR"/>
-		<value name="GL_ONE_MINUS_SRC_COLOR"/>
-		<value name="GL_SRC_ALPHA"/>
-		<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		<value name="GL_DST_ALPHA"/>
-		<value name="GL_ONE_MINUS_DST_ALPHA"/>
-		<value name="GL_DST_COLOR"/>
-		<value name="GL_ONE_MINUS_DST_COLOR"/>
-
-		<value name="GL_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_CONSTANT_ALPHA" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_ALPHA" category="GLES2.0"/>
-	</desc>
 </template>
 
 <template name="LogicOp">
@@ -982,25 +306,6 @@
 		<return type="void"/>
 		<param name="opcode" type="GLenum"/>
 	</proto>
-
-	<desc name="opcode">
-		<value name="GL_CLEAR"/>
-		<value name="GL_SET"/>
-		<value name="GL_COPY"/>
-		<value name="GL_COPY_INVERTED"/>
-		<value name="GL_NOOP"/>
-		<value name="GL_INVERT"/>
-		<value name="GL_AND"/>
-		<value name="GL_NAND"/>
-		<value name="GL_OR"/>
-		<value name="GL_NOR"/>
-		<value name="GL_XOR"/>
-		<value name="GL_EQUIV"/>
-		<value name="GL_AND_REVERSE"/>
-		<value name="GL_AND_INVERTED"/>
-		<value name="GL_OR_REVERSE"/>
-		<value name="GL_OR_INVERTED"/>
-	</desc>
 </template>
 
 <template name="StencilFunc">
@@ -1010,17 +315,6 @@
 		<param name="ref" type="GLint"/>
 		<param name="mask" type="GLuint"/>
 	</proto>
-
-	<desc name="func">
-		<value name="GL_NEVER"/>
-		<value name="GL_LESS"/>
-		<value name="GL_LEQUAL"/>
-		<value name="GL_GREATER"/>
-		<value name="GL_GEQUAL"/>
-		<value name="GL_EQUAL"/>
-		<value name="GL_NOTEQUAL"/>
-		<value name="GL_ALWAYS"/>
-	</desc>
 </template>
 
 <template name="StencilFuncSeparate">
@@ -1031,23 +325,6 @@
 		<param name="ref" type="GLint"/>
 		<param name="mask" type="GLuint"/>
 	</proto>
-
-	<desc name="face">
-		<value name="GL_FRONT"/>
-		<value name="GL_BACK"/>
-		<value name="GL_FRONT_AND_BACK"/>
-	</desc>
-
-	<desc name="func">
-		<value name="GL_NEVER"/>
-		<value name="GL_LESS"/>
-		<value name="GL_LEQUAL"/>
-		<value name="GL_GREATER"/>
-		<value name="GL_GEQUAL"/>
-		<value name="GL_EQUAL"/>
-		<value name="GL_NOTEQUAL"/>
-		<value name="GL_ALWAYS"/>
-	</desc>
 </template>
 
 <template name="StencilOp">
@@ -1057,45 +334,6 @@
 		<param name="zfail" type="GLenum"/>
 		<param name="zpass" type="GLenum"/>
 	</proto>
-
-	<desc name="fail">
-		<value name="GL_KEEP"/>
-		<value name="GL_ZERO"/>
-		<value name="GL_REPLACE"/>
-		<value name="GL_INCR"/>
-		<value name="GL_DECR"/>
-		<value name="GL_INVERT"/>
-		<value name="GL_INCR_WRAP" category="GLES2.0"/>
-		<value name="GL_DECR_WRAP" category="GLES2.0"/>
-		<value name="GL_INCR_WRAP_OES" category="OES_stencil_wrap"/>
-		<value name="GL_DECR_WRAP_OES" category="OES_stencil_wrap"/>
-	</desc>
-
-	<desc name="zfail">
-		<value name="GL_KEEP"/>
-		<value name="GL_ZERO"/>
-		<value name="GL_REPLACE"/>
-		<value name="GL_INCR"/>
-		<value name="GL_DECR"/>
-		<value name="GL_INVERT"/>
-		<value name="GL_INCR_WRAP" category="GLES2.0"/>
-		<value name="GL_DECR_WRAP" category="GLES2.0"/>
-		<value name="GL_INCR_WRAP_OES" category="OES_stencil_wrap"/>
-		<value name="GL_DECR_WRAP_OES" category="OES_stencil_wrap"/>
-	</desc>
-
-	<desc name="zpass">
-		<value name="GL_KEEP"/>
-		<value name="GL_ZERO"/>
-		<value name="GL_REPLACE"/>
-		<value name="GL_INCR"/>
-		<value name="GL_DECR"/>
-		<value name="GL_INVERT"/>
-		<value name="GL_INCR_WRAP" category="GLES2.0"/>
-		<value name="GL_DECR_WRAP" category="GLES2.0"/>
-		<value name="GL_INCR_WRAP_OES" category="OES_stencil_wrap"/>
-		<value name="GL_DECR_WRAP_OES" category="OES_stencil_wrap"/>
-	</desc>
 </template>
 
 <template name="StencilOpSeparate">
@@ -1106,45 +344,6 @@
 		<param name="zfail" type="GLenum"/>
 		<param name="zpass" type="GLenum"/>
 	</proto>
-
-	<desc name="face">
-		<value name="GL_FRONT"/>
-		<value name="GL_BACK"/>
-		<value name="GL_FRONT_AND_BACK"/>
-	</desc>
-
-	<desc name="fail">
-		<value name="GL_KEEP"/>
-		<value name="GL_ZERO"/>
-		<value name="GL_REPLACE"/>
-		<value name="GL_INCR"/>
-		<value name="GL_DECR"/>
-		<value name="GL_INVERT"/>
-		<value name="GL_INCR_WRAP"/>
-		<value name="GL_DECR_WRAP"/>
-	</desc>
-
-	<desc name="zfail">
-		<value name="GL_KEEP"/>
-		<value name="GL_ZERO"/>
-		<value name="GL_REPLACE"/>
-		<value name="GL_INCR"/>
-		<value name="GL_DECR"/>
-		<value name="GL_INVERT"/>
-		<value name="GL_INCR_WRAP"/>
-		<value name="GL_DECR_WRAP"/>
-	</desc>
-
-	<desc name="zpass">
-		<value name="GL_KEEP"/>
-		<value name="GL_ZERO"/>
-		<value name="GL_REPLACE"/>
-		<value name="GL_INCR"/>
-		<value name="GL_DECR"/>
-		<value name="GL_INVERT"/>
-		<value name="GL_INCR_WRAP"/>
-		<value name="GL_DECR_WRAP"/>
-	</desc>
 </template>
 
 <template name="DepthFunc">
@@ -1152,17 +351,6 @@
 		<return type="void"/>
 		<param name="func" type="GLenum"/>
 	</proto>
-
-	<desc name="func">
-		<value name="GL_NEVER"/>
-		<value name="GL_LESS"/>
-		<value name="GL_EQUAL"/>
-		<value name="GL_LEQUAL"/>
-		<value name="GL_GREATER"/>
-		<value name="GL_NOTEQUAL"/>
-		<value name="GL_GEQUAL"/>
-		<value name="GL_ALWAYS"/>
-	</desc>
 </template>
 
 <template name="PixelStore">
@@ -1171,33 +359,6 @@
 		<param name="pname" type="GLenum"/>
 		<param name="param" type="GLtype"/>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_PACK_ALIGNMENT"/>
-		<desc name="param" error="GL_INVALID_VALUE">
-			<value name="1"/>
-			<value name="2"/>
-			<value name="4"/>
-			<value name="8"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_UNPACK_ALIGNMENT"/>
-		<desc name="param" error="GL_INVALID_VALUE">
-			<value name="1"/>
-			<value name="2"/>
-			<value name="4"/>
-			<value name="8"/>
-		</desc>
-	</desc>
-
-	<desc name="pname" category="EXT_unpack_subimage">
-		<value name="GL_UNPACK_ROW_LENGTH"/>
-		<value name="GL_UNPACK_SKIP_PIXELS"/>
-		<value name="GL_UNPACK_SKIP_ROWS"/>
-	</desc>
-
 </template>
 
 <template name="ReadPixels" direction="get">
@@ -1211,59 +372,6 @@
 		<param name="type" type="GLenum"/>
 		<param name="pixels" type="GLvoid *"/>
 	</proto>
-
-	<!-- Technically, only two combinations are actually allowed:
-	     GL_RGBA/GL_UNSIGNED_BYTE, and some implementation-specific
-	     internal preferred combination.  I don't know what that is, so I'm
-	     allowing any valid combination for now; the underlying support
-	     should fail when necessary.-->
-	<desc name="format">
-		<value name="GL_ALPHA"/>
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGB"/>
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_5_6_5"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGBA"/>
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_4_4_4_4"/>
-			<value name="GL_UNSIGNED_SHORT_5_5_5_1"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE"/>
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE_ALPHA"/>
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-		</desc>
-	</desc>
-
-	<desc name="format" category="EXT_read_format_bgra">
-		<value name="GL_BGRA_EXT"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT"/>
-			<value name="GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="GetClipPlane" direction="get">
@@ -1297,35 +405,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="light">
-		<range base="GL_LIGHT" from="0" to="7"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_AMBIENT"/>
-		<value name="GL_DIFFUSE"/>
-		<value name="GL_SPECULAR"/>
-		<value name="GL_POSITION"/>
-
-		<desc name="params" vector_size="4"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_SPOT_DIRECTION"/>
-
-		<desc name="params" vector_size="3"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_SPOT_EXPONENT"/>
-		<value name="GL_SPOT_CUTOFF"/>
-		<value name="GL_CONSTANT_ATTENUATION"/>
-		<value name="GL_LINEAR_ATTENUATION"/>
-		<value name="GL_QUADRATIC_ATTENUATION"/>
-
-		<desc name="params" vector_size="1"/>
-	</desc>
 </template>
 
 <template name="GetMaterial" direction="get">
@@ -1337,26 +416,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="face">
-		<value name="GL_FRONT"/>
-		<value name="GL_BACK"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_SHININESS"/>
-		<desc name="params" vector_size="1"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_AMBIENT"/>
-		<value name="GL_DIFFUSE"/>
-		<value name="GL_AMBIENT_AND_DIFFUSE"/>
-		<value name="GL_SPECULAR"/>
-		<value name="GL_EMISSION"/>
-
-		<desc name="params" vector_size="4"/>
-	</desc>
 </template>
 
 <template name="GetString" direction="get">
@@ -1364,14 +423,6 @@
 		<return type="const GLubyte *"/>
 		<param name="name" type="GLenum"/>
 	</proto>
-
-	<desc name="name">
-		<value name="GL_VENDOR"/>
-		<value name="GL_RENDERER"/>
-		<value name="GL_VERSION"/>
-		<value name="GL_EXTENSIONS"/>
-		<value name="GL_SHADING_LANGUAGE_VERSION" category="GLES2.0"/>
-	</desc>
 </template>
 
 <template name="GetTexEnv" direction="get">
@@ -1381,88 +432,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="target" category="OES_point_sprite">
-		<value name="GL_POINT_SPRITE_OES"/>
-		<desc name="pname">
-			<value name="GL_COORD_REPLACE_OES"/>
-		</desc>
-	</desc>
-
-	<desc name="pname" category="OES_point_sprite">
-		<value name="GL_COORD_REPLACE_OES"/>
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
-
-	<desc name="target" category="EXT_texture_lod_bias">
-		<value name="GL_TEXTURE_FILTER_CONTROL_EXT"/>
-
-		<desc name="pname">
-			<value name="GL_TEXTURE_LOD_BIAS_EXT"/>
-		</desc>
-	</desc>
-
-	<desc name="pname" category="EXT_texture_lod_bias">
-		<value name="GL_TEXTURE_LOD_BIAS_EXT"/>
-		<desc name="params" vector_size="1"/>
-	</desc>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_ENV"/>
-
-		<desc name="pname">
-			<value name="GL_TEXTURE_ENV_COLOR"/>
-			<value name="GL_RGB_SCALE"/>
-			<value name="GL_ALPHA_SCALE"/>
-			<value name="GL_TEXTURE_ENV_MODE"/>
-			<value name="GL_COMBINE_RGB"/>
-			<value name="GL_COMBINE_ALPHA"/>
-			<value name="GL_SRC0_RGB"/>
-			<value name="GL_SRC1_RGB"/>
-			<value name="GL_SRC2_RGB"/>
-			<value name="GL_SRC0_ALPHA"/>
-			<value name="GL_SRC1_ALPHA"/>
-			<value name="GL_SRC2_ALPHA"/>
-			<value name="GL_OPERAND0_RGB"/>
-			<value name="GL_OPERAND1_RGB"/>
-			<value name="GL_OPERAND2_RGB"/>
-			<value name="GL_OPERAND0_ALPHA"/>
-			<value name="GL_OPERAND1_ALPHA"/>
-			<value name="GL_OPERAND2_ALPHA"/>
-		</desc>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_ENV_COLOR"/>
-		<desc name="params" vector_size="4"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_RGB_SCALE"/>
-		<value name="GL_ALPHA_SCALE"/>
-
-		<desc name="params" vector_size="1"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_ENV_MODE"/>
-		<value name="GL_COMBINE_RGB"/>
-		<value name="GL_COMBINE_ALPHA"/>
-		<value name="GL_SRC0_RGB"/>
-		<value name="GL_SRC1_RGB"/>
-		<value name="GL_SRC2_RGB"/>
-		<value name="GL_SRC0_ALPHA"/>
-		<value name="GL_SRC1_ALPHA"/>
-		<value name="GL_SRC2_ALPHA"/>
-		<value name="GL_OPERAND0_RGB"/>
-		<value name="GL_OPERAND1_RGB"/>
-		<value name="GL_OPERAND2_RGB"/>
-		<value name="GL_OPERAND0_ALPHA"/>
-		<value name="GL_OPERAND1_ALPHA"/>
-		<value name="GL_OPERAND2_ALPHA"/>
-
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
 </template>
 
 <template name="GetTexGen" direction="get">
@@ -1472,14 +441,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="coord">
-		<value name="GL_TEXTURE_GEN_STR_OES"/>
-	</desc>
-	<desc name="pname">
-		<value name="GL_TEXTURE_GEN_MODE_OES"/>
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
 </template>
 
 <template name="GetTexParameter" direction="get">
@@ -1489,30 +450,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_3D_OES" category="OES_texture_3D"/>
-		<value name="GL_TEXTURE_EXTERNAL_OES" category="OES_EGL_image_external"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_TEXTURE_WRAP_S"/>
-		<value name="GL_TEXTURE_WRAP_T"/>
-		<value name="GL_TEXTURE_WRAP_R_OES" category="OES_texture_3D"/>
-		<value name="GL_TEXTURE_MIN_FILTER"/>
-		<value name="GL_TEXTURE_MAG_FILTER"/>
-		<value name="GL_GENERATE_MIPMAP" category="GLES1.1"/>
-
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
-
-	<desc name="pname" category="OES_draw_texture">
-		<value name="GL_TEXTURE_CROP_RECT_OES"/>
-		<desc name="params" vector_size="4"/>
-	</desc>
 </template>
 
 <template name="IsEnabled" direction="get">
@@ -1520,63 +457,6 @@
 		<return type="GLboolean"/>
 		<param name="cap" type="GLenum"/>
 	</proto>
-
-	<desc name="cap" category="GLES1.1">
-		<value name="GL_NORMALIZE"/>
-		<value name="GL_RESCALE_NORMAL"/>
-
-		<range base="GL_CLIP_PLANE" from="0" to="5"/>
-		<value name="GL_CLIP_PLANE0+6"/>
-		<value name="GL_CLIP_PLANE0+7"/>
-
-		<value name="GL_FOG"/>
-		<value name="GL_LIGHTING"/>
-		<value name="GL_COLOR_MATERIAL"/>
-
-		<range base="GL_LIGHT" from="0" to="7"/>
-
-		<value name="GL_POINT_SMOOTH"/>
-		<value name="GL_LINE_SMOOTH"/>
-		<value name="GL_CULL_FACE"/>
-		<value name="GL_POLYGON_OFFSET_FILL"/>
-		<value name="GL_MULTISAMPLE"/>
-		<value name="GL_SAMPLE_ALPHA_TO_COVERAGE"/>
-		<value name="GL_SAMPLE_ALPHA_TO_ONE"/>
-		<value name="GL_SAMPLE_COVERAGE"/>
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_SCISSOR_TEST"/>
-		<value name="GL_ALPHA_TEST"/>
-		<value name="GL_STENCIL_TEST"/>
-		<value name="GL_DEPTH_TEST"/>
-		<value name="GL_BLEND"/>
-		<value name="GL_DITHER"/>
-		<value name="GL_COLOR_LOGIC_OP"/>
-
-		<value name="GL_POINT_SPRITE_OES" category="OES_point_sprite"/>
-		<value name="GL_TEXTURE_CUBE_MAP_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_GEN_STR_OES" category="OES_texture_cube_map"/>
-
-		<value name="GL_VERTEX_ARRAY"/>
-		<value name="GL_NORMAL_ARRAY"/>
-		<value name="GL_COLOR_ARRAY"/>
-		<value name="GL_TEXTURE_COORD_ARRAY"/>
-		<value name="GL_MATRIX_INDEX_ARRAY_OES" category="OES_matrix_palette"/>
-		<value name="GL_WEIGHT_ARRAY_OES" category="OES_matrix_palette"/>
-		<value name="GL_POINT_SIZE_ARRAY_OES" category="OES_point_size_array"/>
-		<value name="GL_TEXTURE_EXTERNAL_OES" category="OES_EGL_image_external"/>
-	</desc>
-
-	<desc name="cap" category="GLES2.0">
-		<value name="GL_CULL_FACE"/>
-		<value name="GL_SCISSOR_TEST"/>
-		<value name="GL_POLYGON_OFFSET_FILL"/>
-		<value name="GL_SAMPLE_ALPHA_TO_COVERAGE"/>
-		<value name="GL_SAMPLE_COVERAGE"/>
-		<value name="GL_STENCIL_TEST"/>
-		<value name="GL_DEPTH_TEST"/>
-		<value name="GL_DITHER"/>
-		<value name="GL_BLEND"/>
-	</desc>
 </template>
 
 <template name="DepthRange">
@@ -1617,13 +497,6 @@
 		<return type="void"/>
 		<param name="mode" type="GLenum"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_MODELVIEW"/>
-		<value name="GL_PROJECTION"/>
-		<value name="GL_TEXTURE"/>
-		<value name="GL_MATRIX_PALETTE_OES" category="OES_matrix_palette"/>
-	</desc>
 </template>
 
 <template name="MultMatrix">
@@ -1703,17 +576,6 @@
 		<param name="stride" type="GLsizei"/>
 		<param name="pointer" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="size" error="GL_INVALID_VALUE">
-		<value name="4"/>
-	</desc>
-
-	<desc name="type">
-		<value name="GL_UNSIGNED_BYTE"/>
-		<value name="GL_FLOAT"/>
-		<value name="GL_FIXED"/>
-		<value name="GL_HALF_FLOAT_OES" category="OES_vertex_half_float"/>
-	</desc>
 </template>
 
 <template name="DisableClientState">
@@ -1721,16 +583,6 @@
 		<return type="void"/>
 		<param name="array" type="GLenum"/>
 	</proto>
-
-	<desc name="array">
-		<value name="GL_VERTEX_ARRAY"/>
-		<value name="GL_NORMAL_ARRAY"/>
-		<value name="GL_COLOR_ARRAY"/>
-		<value name="GL_TEXTURE_COORD_ARRAY"/>
-		<value name="GL_MATRIX_INDEX_ARRAY_OES" category="OES_matrix_palette"/>
-		<value name="GL_WEIGHT_ARRAY_OES" category="OES_matrix_palette"/>
-		<value name="GL_POINT_SIZE_ARRAY_OES" category="OES_point_size_array"/>
-	</desc>
 </template>
 
 <template name="DrawArrays">
@@ -1740,16 +592,6 @@
 		<param name="first" type="GLint"/>
 		<param name="count" type="GLsizei"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_POINTS"/>
-		<value name="GL_LINES"/>
-		<value name="GL_LINE_LOOP"/>
-		<value name="GL_LINE_STRIP"/>
-		<value name="GL_TRIANGLES"/>
-		<value name="GL_TRIANGLE_STRIP"/>
-		<value name="GL_TRIANGLE_FAN"/>
-	</desc>
 </template>
 
 <template name="DrawElements">
@@ -1760,22 +602,6 @@
 		<param name="type" type="GLenum"/>
 		<param name="indices" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_POINTS"/>
-		<value name="GL_LINES"/>
-		<value name="GL_LINE_LOOP"/>
-		<value name="GL_LINE_STRIP"/>
-		<value name="GL_TRIANGLES"/>
-		<value name="GL_TRIANGLE_STRIP"/>
-		<value name="GL_TRIANGLE_FAN"/>
-	</desc>
-
-	<desc name="type">
-		<value name="GL_UNSIGNED_BYTE"/>
-		<value name="GL_UNSIGNED_SHORT"/>
-		<value name="GL_UNSIGNED_INT" category="OES_element_index_uint"/>
-	</desc>
 </template>
 
 <template name="EnableClientState">
@@ -1783,16 +609,6 @@
 		<return type="void"/>
 		<param name="array" type="GLenum"/>
 	</proto>
-
-	<desc name="array">
-		<value name="GL_VERTEX_ARRAY"/>
-		<value name="GL_NORMAL_ARRAY"/>
-		<value name="GL_COLOR_ARRAY"/>
-		<value name="GL_TEXTURE_COORD_ARRAY"/>
-		<value name="GL_MATRIX_INDEX_ARRAY_OES" category="OES_matrix_palette"/>
-		<value name="GL_WEIGHT_ARRAY_OES" category="OES_matrix_palette"/>
-		<value name="GL_POINT_SIZE_ARRAY_OES" category="OES_point_size_array"/>
-	</desc>
 </template>
 
 <template name="GetPointer" direction="get">
@@ -1801,16 +617,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLvoid **" size="dynamic"/>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_VERTEX_ARRAY_POINTER"/>
-		<value name="GL_NORMAL_ARRAY_POINTER"/>
-		<value name="GL_COLOR_ARRAY_POINTER"/>
-		<value name="GL_TEXTURE_COORD_ARRAY_POINTER"/>
-		<value name="GL_MATRIX_INDEX_ARRAY_POINTER_OES" category="OES_matrix_palette"/>
-		<value name="GL_WEIGHT_ARRAY_POINTER_OES" category="OES_matrix_palette"/>
-		<value name="GL_POINT_SIZE_ARRAY_POINTER_OES" category="OES_point_size_array"/>
-	</desc>
 </template>
 
 <template name="Normal">
@@ -1831,14 +637,6 @@
 		<param name="stride" type="GLsizei"/>
 		<param name="pointer" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="type">
-		<value name="GL_BYTE"/>
-		<value name="GL_SHORT"/>
-		<value name="GL_FLOAT"/>
-		<value name="GL_FIXED"/>
-		<value name="GL_HALF_FLOAT_OES" category="OES_vertex_half_float"/>
-	</desc>
 </template>
 
 <template name="TexCoordPointer">
@@ -1849,20 +647,6 @@
 		<param name="stride" type="GLsizei"/>
 		<param name="pointer" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="size" error="GL_INVALID_VALUE">
-		<value name="2"/>
-		<value name="3"/>
-		<value name="4"/>
-	</desc>
-
-	<desc name="type">
-		<value name="GL_BYTE"/>
-		<value name="GL_SHORT"/>
-		<value name="GL_FLOAT"/>
-		<value name="GL_FIXED"/>
-		<value name="GL_HALF_FLOAT_OES" category="OES_vertex_half_float"/>
-	</desc>
 </template>
 
 <template name="VertexPointer">
@@ -1873,20 +657,6 @@
 		<param name="stride" type="GLsizei"/>
 		<param name="pointer" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="size" error="GL_INVALID_VALUE">
-		<value name="2"/>
-		<value name="3"/>
-		<value name="4"/>
-	</desc>
-
-	<desc name="type">
-		<value name="GL_BYTE"/>
-		<value name="GL_SHORT"/>
-		<value name="GL_FLOAT"/>
-		<value name="GL_FIXED"/>
-		<value name="GL_HALF_FLOAT_OES" category="OES_vertex_half_float"/>
-	</desc>
 </template>
 
 <template name="PolygonOffset">
@@ -1909,34 +679,6 @@
 		<param name="height" type="GLsizei"/>
 		<param name="border" type="GLint"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES" category="OES_texture_cube_map"/>
-	</desc>
-
-	<desc name="internalFormat" error="GL_INVALID_VALUE">
-		<value name="GL_ALPHA"/>
-		<value name="GL_RGB"/>
-		<value name="GL_RGBA"/>
-		<value name="GL_LUMINANCE"/>
-		<value name="GL_LUMINANCE_ALPHA"/>
-	</desc>
-
-	<desc name="border" error="GL_INVALID_VALUE">
-		<value name="0"/>
-	</desc>
 </template>
 
 <template name="CopyTexSubImage2D">
@@ -1951,22 +693,6 @@
 		<param name="width" type="GLsizei"/>
 		<param name="height" type="GLsizei"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES" category="OES_texture_cube_map"/>
-	</desc>
 </template>
 
 <template name="TexSubImage2D">
@@ -1982,101 +708,6 @@
 		<param name="type" type="GLenum"/>
 		<param name="pixels" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES" category="OES_texture_cube_map"/>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGB"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_5_6_5"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGBA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_4_4_4_4"/>
-			<value name="GL_UNSIGNED_SHORT_5_5_5_1"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-			<value name="GL_UNSIGNED_INT_2_10_10_10_REV_EXT" category="EXT_texture_type_2_10_10_10_REV"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format" category="OES_depth_texture">
-		<value name="GL_DEPTH_COMPONENT"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_SHORT"/>
-			<value name="GL_UNSIGNED_INT"/>
-		</desc>
-	</desc>
-
-	<desc name="format" category="OES_packed_depth_stencil">
-		<value name="GL_DEPTH_STENCIL_OES"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_INT_24_8_OES"/>
-		</desc>
-	</desc>
-
-	<desc name="format" category="EXT_texture_format_BGRA8888">
-		<value name="GL_BGRA_EXT"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="BindTexture">
@@ -2085,14 +716,6 @@
 		<param name="target" type="GLenum"/>
 		<param name="texture" type="GLuint"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_3D_OES" category="OES_texture_3D"/>
-		<value name="GL_TEXTURE_EXTERNAL_OES" category="OES_EGL_image_external"/>
-	</desc>
 </template>
 
 <template name="DeleteTextures">
@@ -2133,18 +756,6 @@
 		<return type="void"/>
 		<param name="mode" type="GLenum"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_FUNC_ADD" category="GLES2.0"/>
-		<value name="GL_FUNC_SUBTRACT" category="GLES2.0"/>
-		<value name="GL_FUNC_REVERSE_SUBTRACT" category="GLES2.0"/>
-		<value name="GL_FUNC_ADD_OES" category="OES_blend_subtract"/>
-		<value name="GL_FUNC_SUBTRACT_OES" category="OES_blend_subtract"/>
-		<value name="GL_FUNC_REVERSE_SUBTRACT_OES" category="OES_blend_subtract"/>
-
-		<value name="GL_MIN_EXT" category="EXT_blend_minmax"/>
-		<value name="GL_MAX_EXT" category="EXT_blend_minmax"/>
-	</desc>
 </template>
 
 <template name="BlendEquationSeparate">
@@ -2153,30 +764,6 @@
 		<param name="modeRGB" type="GLenum"/>
 		<param name="modeAlpha" type="GLenum"/>
 	</proto>
-
-	<desc name="modeRGB">
-		<value name="GL_FUNC_ADD" category="GLES2.0"/>
-		<value name="GL_FUNC_SUBTRACT" category="GLES2.0"/>
-		<value name="GL_FUNC_REVERSE_SUBTRACT" category="GLES2.0"/>
-		<value name="GL_FUNC_ADD_OES" category="OES_blend_subtract"/>
-		<value name="GL_FUNC_SUBTRACT_OES" category="OES_blend_subtract"/>
-		<value name="GL_FUNC_REVERSE_SUBTRACT_OES" category="OES_blend_subtract"/>
-
-		<value name="GL_MIN_EXT" category="EXT_blend_minmax"/>
-		<value name="GL_MAX_EXT" category="EXT_blend_minmax"/>
-	</desc>
-
-	<desc name="modeAlpha">
-		<value name="GL_FUNC_ADD" category="GLES2.0"/>
-		<value name="GL_FUNC_SUBTRACT" category="GLES2.0"/>
-		<value name="GL_FUNC_REVERSE_SUBTRACT" category="GLES2.0"/>
-		<value name="GL_FUNC_ADD_OES" category="OES_blend_subtract"/>
-		<value name="GL_FUNC_SUBTRACT_OES" category="OES_blend_subtract"/>
-		<value name="GL_FUNC_REVERSE_SUBTRACT_OES" category="OES_blend_subtract"/>
-
-		<value name="GL_MIN_EXT" category="EXT_blend_minmax"/>
-		<value name="GL_MAX_EXT" category="EXT_blend_minmax"/>
-	</desc>
 </template>
 
 <template name="TexImage3D">
@@ -2194,71 +781,6 @@
 		<param name="pixels" type="const GLvoid *"/>
 	</proto>
 
-	<desc name="target">
-		<value name="GL_TEXTURE_3D_OES"/>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_ALPHA"/>
-		<value name="GL_RGB"/>
-		<value name="GL_RGBA"/>
-		<value name="GL_LUMINANCE"/>
-		<value name="GL_LUMINANCE_ALPHA"/>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGB"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_5_6_5"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGBA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_4_4_4_4"/>
-			<value name="GL_UNSIGNED_SHORT_5_5_5_1"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-			<value name="GL_UNSIGNED_INT_2_10_10_10_REV_EXT" category="EXT_texture_type_2_10_10_10_REV"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="TexSubImage3D">
@@ -2276,64 +798,6 @@
 		<param name="type" type="GLenum"/>
 		<param name="pixels" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_3D_OES"/>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGB"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_5_6_5"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_RGBA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_UNSIGNED_SHORT_4_4_4_4"/>
-			<value name="GL_UNSIGNED_SHORT_5_5_5_1"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-			<value name="GL_UNSIGNED_INT_2_10_10_10_REV_EXT" category="EXT_texture_type_2_10_10_10_REV"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_LUMINANCE_ALPHA"/>
-
-		<desc name="type" error="GL_INVALID_OPERATION">
-			<value name="GL_UNSIGNED_BYTE"/>
-			<value name="GL_FLOAT" category="OES_texture_float"/>
-			<value name="GL_HALF_FLOAT_OES" category="OES_texture_half_float"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="CopyTexSubImage3D">
@@ -2349,10 +813,6 @@
 		<param name="width" type="GLsizei"/>
 		<param name="height" type="GLsizei"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_3D_OES"/>
-	</desc>
 </template>
 
 <template name="MultiTexCoord">
@@ -2366,10 +826,6 @@
 			<param name="q" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="texture">
-		<range base="GL_TEXTURE" from="0" to="31"/>
-	</desc>
 </template>
 
 <template name="CompressedTexImage3D">
@@ -2385,18 +841,6 @@
 		<param name="imagesize" type="GLsizei"/>
 		<param name="data" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_3D_OES"/>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_3DC_X_AMD" category="AMD_compressed_3DC_texture"/>
-		<value name="GL_3DC_XY_AMD" category="AMD_compressed_3DC_texture"/>
-		<value name="GL_ATC_RGB_AMD" category="AMD_compressed_ATC_texture"/>
-		<value name="GL_ATC_RGBA_EXPLICIT_ALPHA_AMD" category="AMD_compressed_ATC_texture"/>
-		<value name="GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD" category="AMD_compressed_ATC_texture"/>
-	</desc>
 </template>
 
 <template name="CompressedTexSubImage3D">
@@ -2414,10 +858,6 @@
 		<param name="imagesize" type="GLsizei"/>
 		<param name="data" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_3D_OES"/>
-	</desc>
 </template>
 
 <template name="ActiveTexture">
@@ -2425,10 +865,6 @@
 		<return type="void"/>
 		<param name="texture" type="GLenum"/>
 	</proto>
-
-	<desc name="texture">
-		<range base="GL_TEXTURE" from="0" to="31"/>
-	</desc>
 </template>
 
 <template name="ClientActiveTexture">
@@ -2436,10 +872,6 @@
 		<return type="void"/>
 		<param name="texture" type="GLenum"/>
 	</proto>
-
-	<desc name="texture">
-		<range base="GL_TEXTURE" from="0" to="31"/>
-	</desc>
 </template>
 
 <template name="SampleCoverage">
@@ -2462,51 +894,6 @@
 		<param name="imageSize" type="GLsizei"/>
 		<param name="data" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES" category="OES_texture_cube_map"/>
-	</desc>
-
-	<desc name="internalFormat">
-		<value name="GL_ETC1_RGB8_OES" category="OES_compressed_ETC1_RGB8_texture"/>
-
-		<value name="GL_PALETTE4_RGB8_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE4_RGBA8_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE4_R5_G6_B5_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE4_RGBA4_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE4_RGB5_A1_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE8_RGB8_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE8_RGBA8_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE8_R5_G6_B5_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE8_RGBA4_OES" category="OES_compressed_paletted_texture"/>
-		<value name="GL_PALETTE8_RGB5_A1_OES" category="OES_compressed_paletted_texture"/>
-
-		<value name="GL_3DC_X_AMD" category="AMD_compressed_3DC_texture"/>
-		<value name="GL_3DC_XY_AMD" category="AMD_compressed_3DC_texture"/>
-
-		<value name="GL_ATC_RGB_AMD" category="AMD_compressed_ATC_texture"/>
-		<value name="GL_ATC_RGBA_EXPLICIT_ALPHA_AMD" category="AMD_compressed_ATC_texture"/>
-		<value name="GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD" category="AMD_compressed_ATC_texture"/>
-
-		<value name="GL_COMPRESSED_RGB_S3TC_DXT1_EXT" category="EXT_texture_compression_dxt1"/>
-		<value name="GL_COMPRESSED_RGBA_S3TC_DXT1_EXT" category="EXT_texture_compression_dxt1"/>
-	</desc>
-
-	<desc name="border" error="GL_INVALID_VALUE">
-		<value name="0"/>
-	</desc>
 </template>
 
 <template name="CompressedTexSubImage2D">
@@ -2522,27 +909,6 @@
 		<param name="imageSize" type="GLsizei"/>
 		<param name="data" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES" category="OES_texture_cube_map"/>
-	</desc>
-
-	<desc name="format">
-		<value name="GL_COMPRESSED_RGB_S3TC_DXT1_EXT" category="EXT_texture_compression_dxt1"/>
-		<value name="GL_COMPRESSED_RGBA_S3TC_DXT1_EXT" category="EXT_texture_compression_dxt1"/>
-	</desc>
 </template>
 
 <template name="BlendFuncSeparate">
@@ -2553,80 +919,6 @@
 		<param name="srcAlpha" type="GLenum"/>
 		<param name="dstAlpha" type="GLenum"/>
 	</proto>
-
-	<desc name="srcRGB">
-		<value name="GL_ZERO"/>
-		<value name="GL_ONE"/>
-		<value name="GL_SRC_COLOR"/>
-		<value name="GL_ONE_MINUS_SRC_COLOR"/>
-		<value name="GL_SRC_ALPHA"/>
-		<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		<value name="GL_DST_ALPHA"/>
-		<value name="GL_ONE_MINUS_DST_ALPHA"/>
-		<value name="GL_DST_COLOR"/>
-		<value name="GL_ONE_MINUS_DST_COLOR"/>
-		<value name="GL_SRC_ALPHA_SATURATE"/>
-
-		<value name="GL_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_CONSTANT_ALPHA" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_ALPHA" category="GLES2.0"/>
-	</desc>
-
-	<desc name="dstRGB">
-		<value name="GL_ZERO"/>
-		<value name="GL_ONE"/>
-		<value name="GL_SRC_COLOR"/>
-		<value name="GL_ONE_MINUS_SRC_COLOR"/>
-		<value name="GL_SRC_ALPHA"/>
-		<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		<value name="GL_DST_ALPHA"/>
-		<value name="GL_ONE_MINUS_DST_ALPHA"/>
-		<value name="GL_DST_COLOR"/>
-		<value name="GL_ONE_MINUS_DST_COLOR"/>
-
-		<value name="GL_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_CONSTANT_ALPHA" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_ALPHA" category="GLES2.0"/>
-	</desc>
-
-	<desc name="srcAlpha">
-		<value name="GL_ZERO"/>
-		<value name="GL_ONE"/>
-		<value name="GL_SRC_COLOR"/>
-		<value name="GL_ONE_MINUS_SRC_COLOR"/>
-		<value name="GL_SRC_ALPHA"/>
-		<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		<value name="GL_DST_ALPHA"/>
-		<value name="GL_ONE_MINUS_DST_ALPHA"/>
-		<value name="GL_DST_COLOR"/>
-		<value name="GL_ONE_MINUS_DST_COLOR"/>
-		<value name="GL_SRC_ALPHA_SATURATE"/>
-
-		<value name="GL_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_CONSTANT_ALPHA" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_ALPHA" category="GLES2.0"/>
-	</desc>
-
-	<desc name="dstAlpha">
-		<value name="GL_ZERO"/>
-		<value name="GL_ONE"/>
-		<value name="GL_SRC_COLOR"/>
-		<value name="GL_ONE_MINUS_SRC_COLOR"/>
-		<value name="GL_SRC_ALPHA"/>
-		<value name="GL_ONE_MINUS_SRC_ALPHA"/>
-		<value name="GL_DST_ALPHA"/>
-		<value name="GL_ONE_MINUS_DST_ALPHA"/>
-		<value name="GL_DST_COLOR"/>
-		<value name="GL_ONE_MINUS_DST_COLOR"/>
-
-		<value name="GL_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_COLOR" category="GLES2.0"/>
-		<value name="GL_CONSTANT_ALPHA" category="GLES2.0"/>
-		<value name="GL_ONE_MINUS_CONSTANT_ALPHA" category="GLES2.0"/>
-	</desc>
 </template>
 
 <template name="PointParameter">
@@ -2637,19 +929,6 @@
 			<param name="param" type="GLtype"/>
 		</vector>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_POINT_SIZE_MIN"/>
-		<value name="GL_POINT_SIZE_MAX"/>
-		<value name="GL_POINT_FADE_THRESHOLD_SIZE"/>
-
-		<desc name="params" vector_size="1"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_POINT_DISTANCE_ATTENUATION"/>
-		<desc name="params" vector_size="3"/>
-	</desc>
 </template>
 
 <template name="VertexAttrib">
@@ -2675,35 +954,6 @@
 		<param name="stride" type="GLsizei"/>
 		<param name="pointer" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="size" error="GL_INVALID_VALUE">
-		<value name="1"/>
-		<value name="2"/>
-		<value name="3"/>
-		<value name="4"/>
-	</desc>
-
-	<desc name="type" error="GL_INVALID_VALUE">
-		<value name="GL_BYTE"/>
-		<value name="GL_UNSIGNED_BYTE"/>
-		<value name="GL_SHORT"/>
-		<value name="GL_UNSIGNED_SHORT"/>
-		<value name="GL_FLOAT"/>
-		<value name="GL_FIXED"/>
-		<value name="GL_HALF_FLOAT_OES" category="OES_vertex_half_float"/>
-		<value name="GL_UNSIGNED_INT_10_10_10_2_OES" category="OES_vertex_type_10_10_10_2"/>
-		<value name="GL_INT_10_10_10_2_OES" category="OES_vertex_type_10_10_10_2"/>
-	</desc>
-
-	<desc name="type" category="OES_vertex_type_10_10_10_2">
-		<value name="GL_UNSIGNED_INT_10_10_10_2_OES"/>
-		<value name="GL_INT_10_10_10_2_OES"/>
-
-		<desc name="size">
-			<value name="3"/>
-			<value name="4"/>
-		</desc>
-	</desc>
 </template>
 
 <template name="EnableVertexAttribArray">
@@ -2734,21 +984,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_DELETE_STATUS"/>
-		<value name="GL_LINK_STATUS"/>
-		<value name="GL_VALIDATE_STATUS"/>
-		<value name="GL_INFO_LOG_LENGTH"/>
-		<value name="GL_ATTACHED_SHADERS"/>
-		<value name="GL_ACTIVE_ATTRIBUTES"/>
-		<value name="GL_ACTIVE_ATTRIBUTE_MAX_LENGTH"/>
-		<value name="GL_ACTIVE_UNIFORMS"/>
-		<value name="GL_ACTIVE_UNIFORM_MAX_LENGTH"/>
-		<value name="GL_PROGRAM_BINARY_LENGTH_OES" category="OES_get_program_binary"/>
-
-		<desc name="params" convert="false"/>
-	</desc>
 </template>
 
 <template name="GetVertexAttrib" direction="get">
@@ -2758,22 +993,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>
-		<value name="GL_VERTEX_ATTRIB_ARRAY_SIZE"/>
-		<value name="GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>
-		<value name="GL_VERTEX_ATTRIB_ARRAY_TYPE"/>
-		<value name="GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>
-		<value name="GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>
-
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_CURRENT_VERTEX_ATTRIB"/>
-		<desc name="params" vector_size="16?" convert="false"/>
-	</desc>
 </template>
 
 <template name="GetVertexAttribPointer" direction="get">
@@ -2783,10 +1002,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="pointer" type="GLvoid **" size="dynamic"/>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_VERTEX_ATTRIB_ARRAY_POINTER"/>
-	</desc>
 </template>
 
 <template name="GetBufferPointer" direction="get">
@@ -2796,15 +1011,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLvoid **" size="dynamic"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_ARRAY_BUFFER"/>
-		<value name="GL_ELEMENT_ARRAY_BUFFER"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_BUFFER_MAP_POINTER_OES"/>
-	</desc>
 </template>
 
 <template name="MapBuffer" direction="get">
@@ -2813,15 +1019,6 @@
 		<param name="target" type="GLenum"/>
 		<param name="access" type="GLenum"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_ARRAY_BUFFER"/>
-		<value name="GL_ELEMENT_ARRAY_BUFFER"/>
-	</desc>
-
-	<desc name="access">
-		<value name="GL_WRITE_ONLY_OES"/>
-	</desc>
 </template>
 
 <template name="UnmapBuffer" direction="get">
@@ -2829,11 +1026,6 @@
 		<return type="GLboolean"/>
 		<param name="target" type="GLenum"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_ARRAY_BUFFER"/>
-		<value name="GL_ELEMENT_ARRAY_BUFFER"/>
-	</desc>
 </template>
 
 <template name="BindBuffer">
@@ -2842,11 +1034,6 @@
 		<param name="target" type="GLenum"/>
 		<param name="buffer" type="GLuint"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_ARRAY_BUFFER"/>
-		<value name="GL_ELEMENT_ARRAY_BUFFER"/>
-	</desc>
 </template>
 
 <template name="BufferData">
@@ -2857,17 +1044,6 @@
 		<param name="data" type="const GLvoid *"/>
 		<param name="usage" type="GLenum"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_ARRAY_BUFFER"/>
-		<value name="GL_ELEMENT_ARRAY_BUFFER"/>
-	</desc>
-
-	<desc name="usage">
-		<value name="GL_STATIC_DRAW"/>
-		<value name="GL_DYNAMIC_DRAW"/>
-		<value name="GL_STREAM_DRAW" category="GLES2.0"/>
-	</desc>
 </template>
 
 <template name="BufferSubData">
@@ -2878,11 +1054,6 @@
 		<param name="size" type="GLsizeiptr"/>
 		<param name="data" type="const GLvoid *"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_ARRAY_BUFFER"/>
-		<value name="GL_ELEMENT_ARRAY_BUFFER"/>
-	</desc>
 </template>
 
 <template name="DeleteBuffers">
@@ -2908,18 +1079,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_ARRAY_BUFFER"/>
-		<value name="GL_ELEMENT_ARRAY_BUFFER"/>
-	</desc>
-
-	<desc name="pname">
-		<value name="GL_BUFFER_SIZE"/>
-		<value name="GL_BUFFER_USAGE"/>
-		<value name="GL_BUFFER_ACCESS_OES" category="OES_mapbuffer"/>
-		<value name="GL_BUFFER_MAPPED_OES" category="OES_mapbuffer"/>
-	</desc>
 </template>
 
 <template name="IsBuffer" direction="get">
@@ -2934,11 +1093,6 @@
 		<return type="GLuint"/>
 		<param name="type" type="GLenum"/>
 	</proto>
-
-	<desc name="type">
-		<value name="GL_VERTEX_SHADER"/>
-		<value name="GL_FRAGMENT_SHADER"/>
-	</desc>
 </template>
 
 <template name="ShaderSource">
@@ -3112,13 +1266,6 @@
 		<return type="void"/>
 		<param name="target" type="GLenum"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_3D_OES" category="OES_texture_3D"/>
-	</desc>
 </template>
 
 <template name="BindFramebuffer">
@@ -3177,28 +1324,6 @@
 		<param name="width" type="GLsizei"/>
 		<param name="height" type="GLsizei"/>
 	</proto>
-
-	<desc name="internalFormat">
-		<value name="GL_DEPTH_COMPONENT16_OES" category="OES_framebuffer_object"/>
-		<value name="GL_RGBA4_OES" category="OES_framebuffer_object"/>
-		<value name="GL_RGB5_A1_OES" category="OES_framebuffer_object"/>
-		<value name="GL_RGB565_OES" category="OES_framebuffer_object"/>
-		<value name="GL_STENCIL_INDEX8_OES" category="OES_stencil8"/>
-
-		<value name="GL_DEPTH_COMPONENT16" category="GLES2.0"/>
-		<value name="GL_RGBA4" category="GLES2.0"/>
-		<value name="GL_RGB5_A1" category="GLES2.0"/>
-		<value name="GL_RGB565" category="GLES2.0"/>
-		<value name="GL_STENCIL_INDEX8" category="GLES2.0"/>
-
-		<value name="GL_DEPTH_COMPONENT24_OES" category="OES_depth24"/>
-		<value name="GL_DEPTH_COMPONENT32_OES" category="OES_depth32"/>
-		<value name="GL_RGB8_OES" category="OES_rgb8_rgba8"/>
-		<value name="GL_RGBA8_OES" category="OES_rgb8_rgba8"/>
-		<value name="GL_STENCIL_INDEX1_OES" category="OES_stencil1"/>
-		<value name="GL_STENCIL_INDEX4_OES" category="OES_stencil4"/>
-		<value name="GL_DEPTH24_STENCIL8_OES" category="OES_packed_depth_stencil"/>
-	</desc>
 </template>
 
 <template name="FramebufferRenderbuffer">
@@ -3220,22 +1345,6 @@
 		<param name="texture" type="GLuint"/>
 		<param name="level" type="GLint"/>
 	</proto>
-
-	<desc name="textarget" error="GL_INVALID_OPERATION">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" category="GLES2.0"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES" category="OES_texture_cube_map"/>
-		<value name="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES" category="OES_texture_cube_map"/>
-	</desc>
 	<!-- According to the base specification, "level" must be 0.  But
 	     extension GL_OES_fbo_render_mipmap lifts that restriction,
 	     so no restriction is placed here. -->
@@ -3251,10 +1360,6 @@
 		<param name="level" type="GLint"/>
 		<param name="zoffset" type="GLint"/>
 	</proto>
-
-	<desc name="textarget" error="GL_INVALID_OPERATION">
-		<value name="GL_TEXTURE_3D_OES" category="OES_texture_3D"/>
-	</desc>
 </template>
 
 <template name="CheckFramebufferStatus" direction="get">
@@ -3272,21 +1377,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES" category="OES_framebuffer_object"/>
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES" category="OES_framebuffer_object"/>
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES" category="OES_framebuffer_object"/>
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES" category="OES_framebuffer_object"/>
-
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE" category="GLES2.0"/>
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME" category="GLES2.0"/>
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL" category="GLES2.0"/>
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE" category="GLES2.0"/>
-		<value name="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES" category="OES_texture_3D"/>
-
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
 </template>
 
 <template name="GetRenderbufferParameter" direction="get">
@@ -3296,34 +1386,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="pname" category="OES_framebuffer_object">
-		<value name="GL_RENDERBUFFER_WIDTH_OES"/>
-		<value name="GL_RENDERBUFFER_HEIGHT_OES"/>
-		<value name="GL_RENDERBUFFER_INTERNAL_FORMAT_OES"/>
-		<value name="GL_RENDERBUFFER_RED_SIZE_OES"/>
-		<value name="GL_RENDERBUFFER_GREEN_SIZE_OES"/>
-		<value name="GL_RENDERBUFFER_BLUE_SIZE_OES"/>
-		<value name="GL_RENDERBUFFER_ALPHA_SIZE_OES"/>
-		<value name="GL_RENDERBUFFER_DEPTH_SIZE_OES"/>
-		<value name="GL_RENDERBUFFER_STENCIL_SIZE_OES"/>
-
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
-
-	<desc name="pname" category="GLES2.0">
-		<value name="GL_RENDERBUFFER_WIDTH"/>
-		<value name="GL_RENDERBUFFER_HEIGHT"/>
-		<value name="GL_RENDERBUFFER_INTERNAL_FORMAT"/>
-		<value name="GL_RENDERBUFFER_RED_SIZE"/>
-		<value name="GL_RENDERBUFFER_GREEN_SIZE"/>
-		<value name="GL_RENDERBUFFER_BLUE_SIZE"/>
-		<value name="GL_RENDERBUFFER_ALPHA_SIZE"/>
-		<value name="GL_RENDERBUFFER_DEPTH_SIZE"/>
-		<value name="GL_RENDERBUFFER_STENCIL_SIZE"/>
-
-		<desc name="params" vector_size="1" convert="false"/>
-	</desc>
 </template>
 
 <template name="IsRenderbuffer" direction="get">
@@ -3354,14 +1416,6 @@
 		<param name="pname" type="GLenum"/>
 		<vector name="params" type="GLtype *" size="dynamic"/>
 	</proto>
-
-	<desc name="pname">
-		<value name="GL_SHADER_TYPE"/>
-		<value name="GL_COMPILE_STATUS"/>
-		<value name="GL_DELETE_STATUS"/>
-		<value name="GL_INFO_LOG_LENGTH"/>
-		<value name="GL_SHADER_SOURCE_LENGTH"/>
-	</desc>
 </template>
 
 <template name="GetAttachedShaders" direction="get">
@@ -3412,20 +1466,6 @@
 		<param name="range" type="GLint *"/>
 		<param name="precision" type="GLint *"/>
 	</proto>
-
-	<desc name="shadertype">
-		<value name="GL_VERTEX_SHADER"/>
-		<value name="GL_FRAGMENT_SHADER"/>
-	</desc>
-
-	<desc name="precisiontype">
-		<value name="GL_LOW_FLOAT"/>
-		<value name="GL_MEDIUM_FLOAT"/>
-		<value name="GL_HIGH_FLOAT"/>
-		<value name="GL_LOW_INT"/>
-		<value name="GL_MEDIUM_INT"/>
-		<value name="GL_HIGH_INT"/>
-	</desc>
 </template>
 
 <template name="GetUniform" direction="get">
@@ -3466,16 +1506,6 @@
 		<param name="count" type="const GLsizei *"/>
 		<param name="primcount" type="GLsizei"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_POINTS"/>
-		<value name="GL_LINES"/>
-		<value name="GL_LINE_LOOP"/>
-		<value name="GL_LINE_STRIP"/>
-		<value name="GL_TRIANGLES"/>
-		<value name="GL_TRIANGLE_STRIP"/>
-		<value name="GL_TRIANGLE_FAN"/>
-	</desc>
 </template>
 
 <template name="MultiDrawElements">
@@ -3487,22 +1517,6 @@
 		<param name="indices" type="const GLvoid **"/>
 		<param name="primcount" type="GLsizei"/>
 	</proto>
-
-	<desc name="mode">
-		<value name="GL_POINTS"/>
-		<value name="GL_LINES"/>
-		<value name="GL_LINE_LOOP"/>
-		<value name="GL_LINE_STRIP"/>
-		<value name="GL_TRIANGLES"/>
-		<value name="GL_TRIANGLE_STRIP"/>
-		<value name="GL_TRIANGLE_FAN"/>
-	</desc>
-
-	<desc name="type">
-		<value name="GL_UNSIGNED_BYTE"/>
-		<value name="GL_UNSIGNED_SHORT"/>
-		<value name="GL_UNSIGNED_INT" category="OES_element_index_uint"/>
-	</desc>
 </template>
 
 <template name="EGLImageTargetTexture2D">
@@ -3511,11 +1525,6 @@
 		<param name="target" type="GLenum"/>
 		<param name="image" type="GLeglImageOES"/>
 	</proto>
-
-	<desc name="target">
-		<value name="GL_TEXTURE_2D"/>
-		<value name="GL_TEXTURE_EXTERNAL_OES" category="OES_EGL_image_external"/>
-	</desc>
 </template>
 
 <template name="EGLImageTargetRenderbufferStorage">
diff --git a/src/mesa/main/api_exec.c b/src/mesa/main/api_exec.c
index f366f5f..36127b0 100644
--- a/src/mesa/main/api_exec.c
+++ b/src/mesa/main/api_exec.c
@@ -106,7 +106,7 @@
 #include "main/dispatch.h"
 
 
-#if FEATURE_GL
+#if FEATURE_GL || FEATURE_ES2
 
 
 /**
@@ -133,7 +133,7 @@ _mesa_create_exec_table(struct gl_context *ctx)
 #endif
 
    /* load the dispatch slots we understand */
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_AlphaFunc(exec, _mesa_AlphaFunc);
    }
 
@@ -145,14 +145,16 @@ _mesa_create_exec_table(struct gl_context *ctx)
    SET_CullFace(exec, _mesa_CullFace);
    SET_Disable(exec, _mesa_Disable);
 #if FEATURE_draw_read_buffer
-   SET_DrawBuffer(exec, _mesa_DrawBuffer);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30)
+      SET_DrawBuffer(exec, _mesa_DrawBuffer);
+
    SET_ReadBuffer(exec, _mesa_ReadBuffer);
 #endif
    SET_Enable(exec, _mesa_Enable);
    SET_Finish(exec, _mesa_Finish);
    SET_Flush(exec, _mesa_Flush);
    SET_FrontFace(exec, _mesa_FrontFace);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_Frustum(exec, _mesa_Frustum);
    }
    SET_GetError(exec, _mesa_GetError);
@@ -162,37 +164,39 @@ _mesa_create_exec_table(struct gl_context *ctx)
       SET_LineStipple(exec, _mesa_LineStipple);
    }
    SET_LineWidth(exec, _mesa_LineWidth);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_LoadIdentity(exec, _mesa_LoadIdentity);
       SET_LoadMatrixf(exec, _mesa_LoadMatrixf);
    }
-   SET_LogicOp(exec, _mesa_LogicOp);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGLES2) {
+      SET_LogicOp(exec, _mesa_LogicOp);
+   }
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_MatrixMode(exec, _mesa_MatrixMode);
       SET_MultMatrixf(exec, _mesa_MultMatrixf);
       SET_Ortho(exec, _mesa_Ortho);
    }
    SET_PixelStorei(exec, _mesa_PixelStorei);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_PopMatrix(exec, _mesa_PopMatrix);
       SET_PushMatrix(exec, _mesa_PushMatrix);
       SET_Rotatef(exec, _mesa_Rotatef);
       SET_Scalef(exec, _mesa_Scalef);
    }
    SET_Scissor(exec, _mesa_Scissor);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_ShadeModel(exec, _mesa_ShadeModel);
    }
    SET_StencilFunc(exec, _mesa_StencilFunc);
    SET_StencilMask(exec, _mesa_StencilMask);
    SET_StencilOp(exec, _mesa_StencilOp);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_TexEnvfv(exec, _mesa_TexEnvfv);
       SET_TexEnvi(exec, _mesa_TexEnvi);
    }
    SET_TexImage2D(exec, _mesa_TexImage2D);
    SET_TexParameteri(exec, _mesa_TexParameteri);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_Translatef(exec, _mesa_Translatef);
    }
    SET_Viewport(exec, _mesa_Viewport);
@@ -212,7 +216,9 @@ _mesa_create_exec_table(struct gl_context *ctx)
    SET_DepthMask(exec, _mesa_DepthMask);
    SET_DepthRange(exec, _mesa_DepthRange);
 
-   _mesa_init_drawpix_dispatch(exec);
+   if (ctx->API != API_OPENGLES2) {
+      _mesa_init_drawpix_dispatch(exec);
+   }
    if (ctx->API == API_OPENGL) {
       _mesa_init_feedback_dispatch(exec);
    }
@@ -228,7 +234,7 @@ _mesa_create_exec_table(struct gl_context *ctx)
    SET_GetBooleanv(exec, _mesa_GetBooleanv);
    SET_GetDoublev(exec, _mesa_GetDoublev);
    SET_GetIntegerv(exec, _mesa_GetIntegerv);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_GetLightfv(exec, _mesa_GetLightfv);
       SET_GetLightiv(exec, _mesa_GetLightiv);
       SET_GetMaterialfv(exec, _mesa_GetMaterialfv);
@@ -237,17 +243,21 @@ _mesa_create_exec_table(struct gl_context *ctx)
       SET_GetTexEnvfv(exec, _mesa_GetTexEnvfv);
       SET_GetTexEnviv(exec, _mesa_GetTexEnviv);
    }
-   SET_GetTexLevelParameterfv(exec, _mesa_GetTexLevelParameterfv);
-   SET_GetTexLevelParameteriv(exec, _mesa_GetTexLevelParameteriv);
+   if (ctx->API != API_OPENGLES2) {
+      SET_GetTexLevelParameterfv(exec, _mesa_GetTexLevelParameterfv);
+      SET_GetTexLevelParameteriv(exec, _mesa_GetTexLevelParameteriv);
+   }
    SET_GetTexParameterfv(exec, _mesa_GetTexParameterfv);
    SET_GetTexParameteriv(exec, _mesa_GetTexParameteriv);
-   SET_GetTexImage(exec, _mesa_GetTexImage);
+   if (ctx->API != API_OPENGLES2) {
+      SET_GetTexImage(exec, _mesa_GetTexImage);
+   }
    SET_Hint(exec, _mesa_Hint);
    if (ctx->API == API_OPENGL) {
       SET_IndexMask(exec, _mesa_IndexMask);
    }
    SET_IsEnabled(exec, _mesa_IsEnabled);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_LightModelf(exec, _mesa_LightModelf);
       SET_LightModelfv(exec, _mesa_LightModelfv);
       SET_LightModeli(exec, _mesa_LightModeli);
@@ -265,19 +275,25 @@ _mesa_create_exec_table(struct gl_context *ctx)
       _mesa_init_pixel_dispatch(exec);
    }
 
-   SET_PixelStoref(exec, _mesa_PixelStoref);
+   if (ctx->API != API_OPENGLES2) {
+      SET_PixelStoref(exec, _mesa_PixelStoref);
+   }
+
    SET_PointSize(exec, _mesa_PointSize);
-   SET_PolygonMode(exec, _mesa_PolygonMode);
+
+   if (ctx->API != API_OPENGLES2) {
+      SET_PolygonMode(exec, _mesa_PolygonMode);
+   }
+
    SET_PolygonOffset(exec, _mesa_PolygonOffset);
    if (ctx->API == API_OPENGL) {
       SET_PolygonStipple(exec, _mesa_PolygonStipple);
-
       _mesa_init_attrib_dispatch(exec);
       _mesa_init_rastpos_dispatch(exec);
    }
 
    SET_ReadPixels(exec, _mesa_ReadPixels);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_Rotated(exec, _mesa_Rotated);
       SET_Scaled(exec, _mesa_Scaled);
       SET_SecondaryColorPointerEXT(exec, _mesa_SecondaryColorPointerEXT);
@@ -285,11 +301,13 @@ _mesa_create_exec_table(struct gl_context *ctx)
       SET_TexEnviv(exec, _mesa_TexEnviv);
    }
 
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       _mesa_init_texgen_dispatch(exec);
    }
 
-   SET_TexImage1D(exec, _mesa_TexImage1D);
+   if (ctx->API != API_OPENGLES2) {
+      SET_TexImage1D(exec, _mesa_TexImage1D);
+   }
    SET_TexParameterf(exec, _mesa_TexParameterf);
    SET_TexParameterfv(exec, _mesa_TexParameterfv);
    SET_TexParameteriv(exec, _mesa_TexParameteriv);
@@ -306,11 +324,17 @@ _mesa_create_exec_table(struct gl_context *ctx)
       SET_AreTexturesResident(exec, _mesa_AreTexturesResident);
       SET_ColorPointer(exec, _mesa_ColorPointer);
    }
-   SET_CopyTexImage1D(exec, _mesa_CopyTexImage1D);
+   if (ctx->API != API_OPENGLES2) {
+      SET_CopyTexImage1D(exec, _mesa_CopyTexImage1D);
+      SET_CopyTexSubImage1D(exec, _mesa_CopyTexSubImage1D);
+      SET_TexSubImage1D(exec, _mesa_TexSubImage1D);
+   }
+
    SET_CopyTexImage2D(exec, _mesa_CopyTexImage2D);
-   SET_CopyTexSubImage1D(exec, _mesa_CopyTexSubImage1D);
    SET_CopyTexSubImage2D(exec, _mesa_CopyTexSubImage2D);
-   if (ctx->API != API_OPENGL_CORE) {
+   SET_TexSubImage2D(exec, _mesa_TexSubImage2D);
+
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_DisableClientState(exec, _mesa_DisableClientState);
       SET_EdgeFlagPointer(exec, _mesa_EdgeFlagPointer);
       SET_EnableClientState(exec, _mesa_EnableClientState);
@@ -319,13 +343,11 @@ _mesa_create_exec_table(struct gl_context *ctx)
       SET_InterleavedArrays(exec, _mesa_InterleavedArrays);
    }
    SET_IsTexture(exec, _mesa_IsTexture);
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API != API_OPENGL_CORE && ctx->API != API_OPENGLES2) {
       SET_NormalPointer(exec, _mesa_NormalPointer);
       SET_PrioritizeTextures(exec, _mesa_PrioritizeTextures);
       SET_TexCoordPointer(exec, _mesa_TexCoordPointer);
    }
-   SET_TexSubImage1D(exec, _mesa_TexSubImage1D);
-   SET_TexSubImage2D(exec, _mesa_TexSubImage2D);
    if (ctx->API != API_OPENGL_CORE) {
       SET_VertexPointer(exec, _mesa_VertexPointer);
    }
@@ -392,7 +414,7 @@ _mesa_create_exec_table(struct gl_context *ctx)
 
    /* 14. SGI_color_table */
 #if 0
-   if (ctx->API != API_OPENGL_CORE) {
+   if (ctx->API == API_OPENGL) {
       SET_ColorTableSGI(exec, _mesa_ColorTable);
       SET_ColorSubTableSGI(exec, _mesa_ColorSubTable);
       SET_GetColorTableSGI(exec, _mesa_GetColorTable);
@@ -456,8 +478,10 @@ _mesa_create_exec_table(struct gl_context *ctx)
 
    /* 200. GL_IBM_multimode_draw_arrays */
 #if _HAVE_FULL_GL
-   SET_MultiModeDrawArraysIBM(exec, _mesa_MultiModeDrawArraysIBM);
-   SET_MultiModeDrawElementsIBM(exec, _mesa_MultiModeDrawElementsIBM);
+   if (ctx->API != API_OPENGLES2) {
+      SET_MultiModeDrawArraysIBM(exec, _mesa_MultiModeDrawArraysIBM);
+      SET_MultiModeDrawElementsIBM(exec, _mesa_MultiModeDrawElementsIBM);
+   }
 #endif
 
    /* 233. GL_NV_vertex_program */
@@ -477,7 +501,6 @@ _mesa_create_exec_table(struct gl_context *ctx)
       SET_GetVertexAttribdvNV(exec, _mesa_GetVertexAttribdvNV);
       SET_GetVertexAttribfvNV(exec, _mesa_GetVertexAttribfvNV);
       SET_GetVertexAttribivNV(exec, _mesa_GetVertexAttribivNV);
-      SET_GetVertexAttribPointervNV(exec, _mesa_GetVertexAttribPointervNV);
       SET_IsProgramNV(exec, _mesa_IsProgramARB);
       SET_LoadProgramNV(exec, _mesa_LoadProgramNV);
       SET_ProgramEnvParameter4dARB(exec, _mesa_ProgramEnvParameter4dARB); /* alias to ProgramParameter4dNV */
@@ -491,6 +514,7 @@ _mesa_create_exec_table(struct gl_context *ctx)
       /* glVertexAttrib*NV functions handled in api_loopback.c */
    }
 #endif
+   SET_GetVertexAttribPointervNV(exec, _mesa_GetVertexAttribPointervNV);
 
    /* 273. GL_APPLE_vertex_array_object */
    if (ctx->API == API_OPENGL) {
@@ -498,8 +522,10 @@ _mesa_create_exec_table(struct gl_context *ctx)
       SET_GenVertexArraysAPPLE(exec, _mesa_GenVertexArraysAPPLE);
    }
    /* Reused by ARB_vertex_array_object */
-   SET_DeleteVertexArraysAPPLE(exec, _mesa_DeleteVertexArraysAPPLE);
-   SET_IsVertexArrayAPPLE(exec, _mesa_IsVertexArrayAPPLE);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      SET_DeleteVertexArraysAPPLE(exec, _mesa_DeleteVertexArraysAPPLE);
+      SET_IsVertexArrayAPPLE(exec, _mesa_IsVertexArrayAPPLE);
+   }
 
    /* 282. GL_NV_fragment_program */
 #if FEATURE_NV_fragment_program
@@ -533,22 +559,32 @@ _mesa_create_exec_table(struct gl_context *ctx)
 #endif
 
    /* 285. GL_NV_primitive_restart */
-   SET_PrimitiveRestartIndexNV(exec, _mesa_PrimitiveRestartIndex);
+   if (ctx->API != API_OPENGLES2) {
+      SET_PrimitiveRestartIndexNV(exec, _mesa_PrimitiveRestartIndex);
+   }
 
    /* ???. GL_EXT_depth_bounds_test */
-   SET_DepthBoundsEXT(exec, _mesa_DepthBoundsEXT);
+   if (ctx->API != API_OPENGLES2) {
+      SET_DepthBoundsEXT(exec, _mesa_DepthBoundsEXT);
+   }
 
    /* 352. GL_EXT_transform_feedback */
    /* ARB 93. GL_ARB_transform_feedback2 */
-   _mesa_init_transform_feedback_dispatch(exec);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      _mesa_init_transform_feedback_dispatch(exec);
+   }
 
    /* 364. GL_EXT_provoking_vertex */
-   SET_ProvokingVertexEXT(exec, _mesa_ProvokingVertexEXT);
+   if (ctx->API != API_OPENGLES2) {
+      SET_ProvokingVertexEXT(exec, _mesa_ProvokingVertexEXT);
+   }
 
    /* ARB 1. GL_ARB_multitexture */
 #if _HAVE_FULL_GL
    SET_ActiveTextureARB(exec, _mesa_ActiveTextureARB);
-   SET_ClientActiveTextureARB(exec, _mesa_ClientActiveTextureARB);
+   if (ctx->API != API_OPENGLES2) {
+      SET_ClientActiveTextureARB(exec, _mesa_ClientActiveTextureARB);
+   }
 #endif
 
    /* ARB 3. GL_ARB_transpose_matrix */
@@ -568,16 +604,21 @@ _mesa_create_exec_table(struct gl_context *ctx)
 
    /* ARB 12. GL_ARB_texture_compression */
 #if _HAVE_FULL_GL
+   if (ctx->API != API_OPENGLES2) {
+      SET_CompressedTexImage1DARB(exec, _mesa_CompressedTexImage1DARB);
+      SET_CompressedTexSubImage1DARB(exec, _mesa_CompressedTexSubImage1DARB);
+      SET_GetCompressedTexImageARB(exec, _mesa_GetCompressedTexImageARB);
+   }
+
    SET_CompressedTexImage3DARB(exec, _mesa_CompressedTexImage3DARB);
    SET_CompressedTexImage2DARB(exec, _mesa_CompressedTexImage2DARB);
-   SET_CompressedTexImage1DARB(exec, _mesa_CompressedTexImage1DARB);
    SET_CompressedTexSubImage3DARB(exec, _mesa_CompressedTexSubImage3DARB);
    SET_CompressedTexSubImage2DARB(exec, _mesa_CompressedTexSubImage2DARB);
-   SET_CompressedTexSubImage1DARB(exec, _mesa_CompressedTexSubImage1DARB);
-   SET_GetCompressedTexImageARB(exec, _mesa_GetCompressedTexImageARB);
 
    /* ARB 104. GL_ARB_robustness */
-   SET_GetnCompressedTexImageARB(exec, _mesa_GetnCompressedTexImageARB);
+   if (ctx->API != API_OPENGLES2) {
+      SET_GetnCompressedTexImageARB(exec, _mesa_GetnCompressedTexImageARB);
+   }
 #endif
 
    /* ARB 14. GL_ARB_point_parameters */
@@ -625,12 +666,15 @@ _mesa_create_exec_table(struct gl_context *ctx)
    SET_VertexAttribPointerARB(exec, _mesa_VertexAttribPointerARB);
    SET_EnableVertexAttribArrayARB(exec, _mesa_EnableVertexAttribArrayARB);
    SET_DisableVertexAttribArrayARB(exec, _mesa_DisableVertexAttribArrayARB);
-   SET_ProgramStringARB(exec, _mesa_ProgramStringARB);
-   /* glBindProgramARB aliases glBindProgramNV */
-   /* glDeleteProgramsARB aliases glDeleteProgramsNV */
-   /* glGenProgramsARB aliases glGenProgramsNV */
-   /* glIsProgramARB aliases glIsProgramNV */
-   SET_GetVertexAttribdvARB(exec, _mesa_GetVertexAttribdvARB);
+   if (ctx->API != API_OPENGLES2) {
+      SET_ProgramStringARB(exec, _mesa_ProgramStringARB);
+      /* glBindProgramARB aliases glBindProgramNV */
+      /* glDeleteProgramsARB aliases glDeleteProgramsNV */
+      /* glGenProgramsARB aliases glGenProgramsNV */
+      /* glIsProgramARB aliases glIsProgramNV */
+      SET_GetVertexAttribdvARB(exec, _mesa_GetVertexAttribdvARB);
+   }
+
    SET_GetVertexAttribfvARB(exec, _mesa_GetVertexAttribfvARB);
    SET_GetVertexAttribivARB(exec, _mesa_GetVertexAttribivARB);
    /* glGetVertexAttribPointervARB aliases glGetVertexAttribPointervNV */
@@ -656,7 +700,9 @@ _mesa_create_exec_table(struct gl_context *ctx)
    _mesa_init_bufferobj_dispatch(exec);
 
    /* ARB 29. GL_ARB_occlusion_query */
-   _mesa_init_queryobj_dispatch(exec);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      _mesa_init_queryobj_dispatch(exec);
+   }
 
    /* ARB 37. GL_ARB_draw_buffers */
 #if FEATURE_draw_read_buffer
@@ -664,16 +710,22 @@ _mesa_create_exec_table(struct gl_context *ctx)
 #endif
 
    /* ARB 66. GL_ARB_sync */
-   _mesa_init_sync_dispatch(exec);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      _mesa_init_sync_dispatch(exec);
+   }
 
    /* ARB 104. GL_ARB_debug_output */
-   _mesa_init_errors_dispatch(exec);
+   if (ctx->API != API_OPENGLES2) {
+      _mesa_init_errors_dispatch(exec);
+   }
 
    /* ARB 105. GL_ARB_robustness */
-   SET_GetGraphicsResetStatusARB(exec, _mesa_GetGraphicsResetStatusARB);
-   SET_GetnPolygonStippleARB(exec, _mesa_GetnPolygonStippleARB);
-   SET_GetnTexImageARB(exec, _mesa_GetnTexImageARB);
-   SET_ReadnPixelsARB(exec, _mesa_ReadnPixelsARB);
+   if (ctx->API != API_OPENGLES2) {
+      SET_GetGraphicsResetStatusARB(exec, _mesa_GetGraphicsResetStatusARB);
+      SET_GetnPolygonStippleARB(exec, _mesa_GetnPolygonStippleARB);
+      SET_GetnTexImageARB(exec, _mesa_GetnTexImageARB);
+      SET_ReadnPixelsARB(exec, _mesa_ReadnPixelsARB);
+   }
 
   /* GL_ATI_fragment_shader */
    if (ctx->API == API_OPENGL) {
@@ -700,7 +752,9 @@ _mesa_create_exec_table(struct gl_context *ctx)
    SET_DeleteFramebuffersEXT(exec, _mesa_DeleteFramebuffersEXT);
    SET_GenFramebuffersEXT(exec, _mesa_GenFramebuffersEXT);
    SET_CheckFramebufferStatusEXT(exec, _mesa_CheckFramebufferStatusEXT);
-   SET_FramebufferTexture1DEXT(exec, _mesa_FramebufferTexture1DEXT);
+   if (ctx->API != API_OPENGLES2) {
+      SET_FramebufferTexture1DEXT(exec, _mesa_FramebufferTexture1DEXT);
+   }
    SET_FramebufferTexture2DEXT(exec, _mesa_FramebufferTexture2DEXT);
    SET_FramebufferTexture3DEXT(exec, _mesa_FramebufferTexture3DEXT);
    SET_FramebufferRenderbufferEXT(exec, _mesa_FramebufferRenderbufferEXT);
@@ -709,7 +763,9 @@ _mesa_create_exec_table(struct gl_context *ctx)
 #endif
 
 #if FEATURE_EXT_framebuffer_blit
-   SET_BlitFramebufferEXT(exec, _mesa_BlitFramebufferEXT);
+   if (ctx->API != API_OPENGLES2) {
+      SET_BlitFramebufferEXT(exec, _mesa_BlitFramebufferEXT);
+   }
 #endif
 
    /* GL_EXT_gpu_program_parameters */
@@ -722,7 +778,9 @@ _mesa_create_exec_table(struct gl_context *ctx)
 
    /* GL_MESA_texture_array / GL_EXT_texture_array */
 #if FEATURE_EXT_framebuffer_object
-   SET_FramebufferTextureLayerEXT(exec, _mesa_FramebufferTextureLayerEXT);
+   if (ctx->API != API_OPENGLES2) {
+      SET_FramebufferTextureLayerEXT(exec, _mesa_FramebufferTextureLayerEXT);
+   }
 #endif
 
    /* GL_ATI_separate_stencil */
@@ -734,32 +792,44 @@ _mesa_create_exec_table(struct gl_context *ctx)
    /* The ARB_fbo functions are the union of
     * GL_EXT_fbo, GL_EXT_framebuffer_blit, GL_EXT_texture_array
     */
-   SET_RenderbufferStorageMultisample(exec, _mesa_RenderbufferStorageMultisample);
+   if (ctx->API != API_OPENGLES2) {
+      SET_RenderbufferStorageMultisample(exec, _mesa_RenderbufferStorageMultisample);
+   }
 #endif
 
 #if FEATURE_ARB_map_buffer_range
-   SET_MapBufferRange(exec, _mesa_MapBufferRange);
-   SET_FlushMappedBufferRange(exec, _mesa_FlushMappedBufferRange);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      SET_MapBufferRange(exec, _mesa_MapBufferRange);
+      SET_FlushMappedBufferRange(exec, _mesa_FlushMappedBufferRange);
+   }
 #endif
 
    /* GL_ARB_copy_buffer */
-   SET_CopyBufferSubData(exec, _mesa_CopyBufferSubData);
+   if (ctx->API != API_OPENGLES2) {
+      SET_CopyBufferSubData(exec, _mesa_CopyBufferSubData);
+   }
 
    /* GL_ARB_vertex_array_object */
-   SET_BindVertexArray(exec, _mesa_BindVertexArray);
-   SET_GenVertexArrays(exec, _mesa_GenVertexArrays);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      SET_BindVertexArray(exec, _mesa_BindVertexArray);
+      SET_GenVertexArrays(exec, _mesa_GenVertexArrays);
+   }
 
    /* GL_EXT_draw_buffers2 */
-   SET_ColorMaskIndexedEXT(exec, _mesa_ColorMaskIndexed);
-   SET_GetBooleanIndexedvEXT(exec, _mesa_GetBooleanIndexedv);
-   SET_GetIntegerIndexedvEXT(exec, _mesa_GetIntegerIndexedv);
-   SET_EnableIndexedEXT(exec, _mesa_EnableIndexed);
-   SET_DisableIndexedEXT(exec, _mesa_DisableIndexed);
-   SET_IsEnabledIndexedEXT(exec, _mesa_IsEnabledIndexed);
+   if (ctx->API == API_OPENGL) {
+      SET_ColorMaskIndexedEXT(exec, _mesa_ColorMaskIndexed);
+      SET_GetBooleanIndexedvEXT(exec, _mesa_GetBooleanIndexedv);
+      SET_GetIntegerIndexedvEXT(exec, _mesa_GetIntegerIndexedv);
+      SET_EnableIndexedEXT(exec, _mesa_EnableIndexed);
+      SET_DisableIndexedEXT(exec, _mesa_DisableIndexed);
+      SET_IsEnabledIndexedEXT(exec, _mesa_IsEnabledIndexed);
+   }
 
    /* GL_NV_conditional_render */
-   SET_BeginConditionalRenderNV(exec, _mesa_BeginConditionalRender);
-   SET_EndConditionalRenderNV(exec, _mesa_EndConditionalRender);
+   if (ctx->API != API_OPENGLES2) {
+      SET_BeginConditionalRenderNV(exec, _mesa_BeginConditionalRender);
+      SET_EndConditionalRenderNV(exec, _mesa_EndConditionalRender);
+   }
 
 #if FEATURE_OES_EGL_image
    SET_EGLImageTargetTexture2DOES(exec, _mesa_EGLImageTargetTexture2DOES);
@@ -767,67 +837,95 @@ _mesa_create_exec_table(struct gl_context *ctx)
 #endif
 
 #if FEATURE_APPLE_object_purgeable
-   SET_ObjectPurgeableAPPLE(exec, _mesa_ObjectPurgeableAPPLE);
-   SET_ObjectUnpurgeableAPPLE(exec, _mesa_ObjectUnpurgeableAPPLE);
-   SET_GetObjectParameterivAPPLE(exec, _mesa_GetObjectParameterivAPPLE);
+   if (ctx->API != API_OPENGLES2) {
+      SET_ObjectPurgeableAPPLE(exec, _mesa_ObjectPurgeableAPPLE);
+      SET_ObjectUnpurgeableAPPLE(exec, _mesa_ObjectUnpurgeableAPPLE);
+      SET_GetObjectParameterivAPPLE(exec, _mesa_GetObjectParameterivAPPLE);
+   }
 #endif
 
 #if FEATURE_ARB_geometry_shader4
-   SET_FramebufferTextureARB(exec, _mesa_FramebufferTextureARB);
-   SET_FramebufferTextureFaceARB(exec, _mesa_FramebufferTextureFaceARB);
+   if (ctx->API != API_OPENGLES2) {
+      SET_FramebufferTextureARB(exec, _mesa_FramebufferTextureARB);
+      SET_FramebufferTextureFaceARB(exec, _mesa_FramebufferTextureFaceARB);
+   }
 #endif
 
-   SET_ClampColorARB(exec, _mesa_ClampColorARB);
+   if (ctx->API != API_OPENGLES2) {
+      SET_ClampColorARB(exec, _mesa_ClampColorARB);
+   }
 
    /* GL_EXT_texture_integer */
-   SET_ClearColorIiEXT(exec, _mesa_ClearColorIiEXT);
-   SET_ClearColorIuiEXT(exec, _mesa_ClearColorIuiEXT);
-   SET_GetTexParameterIivEXT(exec, _mesa_GetTexParameterIiv);
-   SET_GetTexParameterIuivEXT(exec, _mesa_GetTexParameterIuiv);
-   SET_TexParameterIivEXT(exec, _mesa_TexParameterIiv);
-   SET_TexParameterIuivEXT(exec, _mesa_TexParameterIuiv);
+   if (ctx->API == API_OPENGLES2) {
+      SET_ClearColorIiEXT(exec, _mesa_ClearColorIiEXT);
+      SET_ClearColorIuiEXT(exec, _mesa_ClearColorIuiEXT);
+   }
+   if (ctx->API != API_OPENGLES2) {
+      SET_GetTexParameterIivEXT(exec, _mesa_GetTexParameterIiv);
+      SET_GetTexParameterIuivEXT(exec, _mesa_GetTexParameterIuiv);
+      SET_TexParameterIivEXT(exec, _mesa_TexParameterIiv);
+      SET_TexParameterIuivEXT(exec, _mesa_TexParameterIuiv);
+   }
 
    /* GL_EXT_gpu_shader4 / OpenGL 3.0 */
-   SET_GetVertexAttribIivEXT(exec, _mesa_GetVertexAttribIiv);
-   SET_GetVertexAttribIuivEXT(exec, _mesa_GetVertexAttribIuiv);
-   SET_VertexAttribIPointerEXT(exec, _mesa_VertexAttribIPointer);
+   if (ctx->API != API_OPENGLES2) {
+      SET_GetVertexAttribIivEXT(exec, _mesa_GetVertexAttribIiv);
+      SET_GetVertexAttribIuivEXT(exec, _mesa_GetVertexAttribIuiv);
+      SET_VertexAttribIPointerEXT(exec, _mesa_VertexAttribIPointer);
+   }
 
    /* GL 3.0 (functions not covered by other extensions) */
-   SET_ClearBufferiv(exec, _mesa_ClearBufferiv);
-   SET_ClearBufferuiv(exec, _mesa_ClearBufferuiv);
-   SET_ClearBufferfv(exec, _mesa_ClearBufferfv);
-   SET_ClearBufferfi(exec, _mesa_ClearBufferfi);
-   SET_GetStringi(exec, _mesa_GetStringi);
-   SET_ClampColor(exec, _mesa_ClampColorARB);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      SET_ClearBufferiv(exec, _mesa_ClearBufferiv);
+      SET_ClearBufferuiv(exec, _mesa_ClearBufferuiv);
+      SET_ClearBufferfv(exec, _mesa_ClearBufferfv);
+      SET_ClearBufferfi(exec, _mesa_ClearBufferfi);
+      SET_GetStringi(exec, _mesa_GetStringi);
+   }
+
+   if (ctx->API != API_OPENGLES2)
+      SET_ClampColor(exec, _mesa_ClampColorARB);
 
    /* GL_ARB_instanced_arrays */
-   SET_VertexAttribDivisorARB(exec, _mesa_VertexAttribDivisor);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      SET_VertexAttribDivisorARB(exec, _mesa_VertexAttribDivisor);
+   }
 
    /* GL_ARB_draw_buffer_blend */
-   SET_BlendFunciARB(exec, _mesa_BlendFunci);
-   SET_BlendFuncSeparateiARB(exec, _mesa_BlendFuncSeparatei);
-   SET_BlendEquationiARB(exec, _mesa_BlendEquationi);
-   SET_BlendEquationSeparateiARB(exec, _mesa_BlendEquationSeparatei);
+   if (ctx->API != API_OPENGLES2) {
+      SET_BlendFunciARB(exec, _mesa_BlendFunci);
+      SET_BlendFuncSeparateiARB(exec, _mesa_BlendFuncSeparatei);
+      SET_BlendEquationiARB(exec, _mesa_BlendEquationi);
+      SET_BlendEquationSeparateiARB(exec, _mesa_BlendEquationSeparatei);
+   }
 
    /* GL_NV_texture_barrier */
-   SET_TextureBarrierNV(exec, _mesa_TextureBarrierNV);
+   if (ctx->API != API_OPENGLES2) {
+      SET_TextureBarrierNV(exec, _mesa_TextureBarrierNV);
+   }
  
    /* GL_ARB_texture_buffer_object */
-   SET_TexBufferARB(exec, _mesa_TexBuffer);
+   if (ctx->API != API_OPENGLES2) {
+      SET_TexBufferARB(exec, _mesa_TexBuffer);
+   }
 
    /* GL_ARB_texture_storage */
-   SET_TexStorage1D(exec, _mesa_TexStorage1D);
+   if (ctx->API != API_OPENGLES2) {
+      SET_TexStorage1D(exec, _mesa_TexStorage1D);
+      SET_TextureStorage1DEXT(exec, _mesa_TextureStorage1DEXT);
+   }
    SET_TexStorage2D(exec, _mesa_TexStorage2D);
    SET_TexStorage3D(exec, _mesa_TexStorage3D);
-   SET_TextureStorage1DEXT(exec, _mesa_TextureStorage1DEXT);
    SET_TextureStorage2DEXT(exec, _mesa_TextureStorage2DEXT);
    SET_TextureStorage3DEXT(exec, _mesa_TextureStorage3DEXT);
 
 #if FEATURE_ARB_sampler_objects
-   _mesa_init_sampler_object_dispatch(exec);
+   if (ctx->API != API_OPENGLES2 || ctx->Version > 30) {
+      _mesa_init_sampler_object_dispatch(exec);
+   }
 #endif
 
    return exec;
 }
 
-#endif /* FEATURE_GL */
+#endif /* FEATURE_GL || FEATURE_ES2 */
diff --git a/src/mesa/main/api_validate.c b/src/mesa/main/api_validate.c
index eaf614b..e1f367d 100644
--- a/src/mesa/main/api_validate.c
+++ b/src/mesa/main/api_validate.c
@@ -22,6 +22,7 @@
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#include <stdbool.h>
 #include "glheader.h"
 #include "api_validate.h"
 #include "bufferobj.h"
@@ -208,12 +209,36 @@ check_index_bounds(struct gl_context *ctx, GLsizei count, GLenum type,
 GLboolean
 _mesa_valid_prim_mode(struct gl_context *ctx, GLenum mode, const char *name)
 {
-   if (ctx->Extensions.ARB_geometry_shader4 &&
-       mode > GL_TRIANGLE_STRIP_ADJACENCY_ARB) {
-      _mesa_error(ctx, GL_INVALID_ENUM, "%s(mode=%x)", name, mode);
-      return GL_FALSE;
+   bool valid_enum;
+
+   switch (mode) {
+   case GL_POINTS:
+   case GL_LINES:
+   case GL_LINE_LOOP:
+   case GL_LINE_STRIP:
+   case GL_TRIANGLES:
+   case GL_TRIANGLE_STRIP:
+   case GL_TRIANGLE_FAN:
+      valid_enum = true;
+      break;
+   case GL_QUADS:
+   case GL_QUAD_STRIP:
+   case GL_POLYGON:
+      valid_enum = (ctx->API == API_OPENGL);
+      break;
+   case GL_LINES_ADJACENCY:
+   case GL_LINE_STRIP_ADJACENCY:
+   case GL_TRIANGLES_ADJACENCY:
+   case GL_TRIANGLE_STRIP_ADJACENCY:
+      valid_enum = (ctx->API == API_OPENGL)
+         && ctx->Extensions.ARB_geometry_shader4;
+      break;
+   default:
+      valid_enum = false;
+      break;
    }
-   else if (mode > GL_POLYGON) {
+
+   if (!valid_enum) {
       _mesa_error(ctx, GL_INVALID_ENUM, "%s(mode=%x)", name, mode);
       return GL_FALSE;
    }
@@ -262,6 +287,25 @@ _mesa_valid_prim_mode(struct gl_context *ctx, GLenum mode, const char *name)
    return GL_TRUE;
 }
 
+/**
+ * Verify that the element type is valid.
+ *
+ * Generates \c GL_INVALID_ENUM and returns \c false if it is not.
+ */
+static bool
+_mesa_valid_element_type(struct gl_context *ctx, GLenum type, const char *name)
+{
+   switch (type) {
+   case GL_UNSIGNED_BYTE:
+   case GL_UNSIGNED_SHORT:
+   case GL_UNSIGNED_INT:
+      return true;
+
+   default:
+      _mesa_error(ctx, GL_INVALID_ENUM, "%s(type = 0x%04x)", name, type);
+      return false;
+   }
+}
 
 /**
  * Error checking for glDrawElements().  Includes parameter checking
@@ -286,13 +330,8 @@ _mesa_validate_DrawElements(struct gl_context *ctx,
       return GL_FALSE;
    }
 
-   if (type != GL_UNSIGNED_INT &&
-       type != GL_UNSIGNED_BYTE &&
-       type != GL_UNSIGNED_SHORT)
-   {
-      _mesa_error(ctx, GL_INVALID_ENUM, "glDrawElements(type)" );
+   if (!_mesa_valid_element_type(ctx, type, "glDrawElements"))
       return GL_FALSE;
-   }
 
    if (!check_valid_to_render(ctx, "glDrawElements"))
       return GL_FALSE;
@@ -348,13 +387,8 @@ _mesa_validate_MultiDrawElements(struct gl_context *ctx,
       return GL_FALSE;
    }
 
-   if (type != GL_UNSIGNED_INT &&
-       type != GL_UNSIGNED_BYTE &&
-       type != GL_UNSIGNED_SHORT)
-   {
-      _mesa_error(ctx, GL_INVALID_ENUM, "glMultiDrawElements(type)" );
+   if (!_mesa_valid_element_type(ctx, type, "glMultiDrawElements"))
       return GL_FALSE;
-   }
 
    if (!check_valid_to_render(ctx, "glMultiDrawElements"))
       return GL_FALSE;
@@ -419,12 +453,8 @@ _mesa_validate_DrawRangeElements(struct gl_context *ctx, GLenum mode,
       return GL_FALSE;
    }
 
-   if (type != GL_UNSIGNED_INT &&
-       type != GL_UNSIGNED_BYTE &&
-       type != GL_UNSIGNED_SHORT) {
-      _mesa_error(ctx, GL_INVALID_ENUM, "glDrawRangeElements(type)" );
+   if (!_mesa_valid_element_type(ctx, type, "glDrawRangeElements"))
       return GL_FALSE;
-   }
 
    if (!check_valid_to_render(ctx, "glDrawRangeElements"))
       return GL_FALSE;
@@ -548,13 +578,8 @@ _mesa_validate_DrawElementsInstanced(struct gl_context *ctx,
       return GL_FALSE;
    }
 
-   if (type != GL_UNSIGNED_INT &&
-       type != GL_UNSIGNED_BYTE &&
-       type != GL_UNSIGNED_SHORT) {
-      _mesa_error(ctx, GL_INVALID_ENUM,
-                  "glDrawElementsInstanced(type=0x%x)", type);
+   if (!_mesa_valid_element_type(ctx, type, "glDrawElementsInstanced"))
       return GL_FALSE;
-   }
 
    if (numInstances <= 0) {
       if (numInstances < 0)
diff --git a/src/mesa/main/blend.c b/src/mesa/main/blend.c
index 5bc40a0..94b2f3f 100644
--- a/src/mesa/main/blend.c
+++ b/src/mesa/main/blend.c
@@ -58,16 +58,17 @@ legal_src_factor(const struct gl_context *ctx, GLenum factor)
    case GL_DST_ALPHA:
    case GL_ONE_MINUS_DST_ALPHA:
    case GL_SRC_ALPHA_SATURATE:
+      return GL_TRUE;
    case GL_CONSTANT_COLOR:
    case GL_ONE_MINUS_CONSTANT_COLOR:
    case GL_CONSTANT_ALPHA:
    case GL_ONE_MINUS_CONSTANT_ALPHA:
-      return GL_TRUE;
+      return ctx->API == API_OPENGL || ctx->API == API_OPENGLES2;
    case GL_SRC1_COLOR:
    case GL_SRC1_ALPHA:
    case GL_ONE_MINUS_SRC1_COLOR:
    case GL_ONE_MINUS_SRC1_ALPHA:
-      return ctx->Extensions.ARB_blend_func_extended;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_blend_func_extended;
    default:
       return GL_FALSE;
    }
@@ -93,17 +94,18 @@ legal_dst_factor(const struct gl_context *ctx, GLenum factor)
    case GL_ONE_MINUS_SRC_ALPHA:
    case GL_DST_ALPHA:
    case GL_ONE_MINUS_DST_ALPHA:
+      return GL_TRUE;
    case GL_CONSTANT_COLOR:
    case GL_ONE_MINUS_CONSTANT_COLOR:
    case GL_CONSTANT_ALPHA:
    case GL_ONE_MINUS_CONSTANT_ALPHA:
-      return GL_TRUE;
+      return ctx->API == API_OPENGL || ctx->API == API_OPENGLES2;
    case GL_SRC_ALPHA_SATURATE:
    case GL_SRC1_COLOR:
    case GL_SRC1_ALPHA:
    case GL_ONE_MINUS_SRC1_COLOR:
    case GL_ONE_MINUS_SRC1_ALPHA:
-      return ctx->Extensions.ARB_blend_func_extended;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_blend_func_extended;
    default:
       return GL_FALSE;
    }
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index 22d7927..13dc81d 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -30,7 +30,7 @@
  * \author Brian Paul, Ian Romanick
  */
 
-
+#include <stdbool.h>
 #include "glheader.h"
 #include "enums.h"
 #include "hash.h"
@@ -68,6 +68,12 @@ static struct gl_buffer_object DummyBufferObject;
 static inline struct gl_buffer_object **
 get_buffer_target(struct gl_context *ctx, GLenum target)
 {
+   /* Other targets are only supported in desktop OpenGL
+    */
+   if (ctx->API != API_OPENGL
+       && target != GL_ARRAY_BUFFER && target != GL_ELEMENT_ARRAY_BUFFER)
+      return NULL;
+
    switch (target) {
    case GL_ARRAY_BUFFER_ARB:
       return &ctx->Array.ArrayBufferObj;
@@ -1002,6 +1008,7 @@ _mesa_BufferDataARB(GLenum target, GLsizeiptrARB size,
 {
    GET_CURRENT_CONTEXT(ctx);
    struct gl_buffer_object *bufObj;
+   bool valid_usage;
    ASSERT_OUTSIDE_BEGIN_END(ctx);
 
    if (MESA_VERBOSE & VERBOSE_API)
@@ -1017,18 +1024,31 @@ _mesa_BufferDataARB(GLenum target, GLsizeiptrARB size,
 
    switch (usage) {
    case GL_STREAM_DRAW_ARB:
+      valid_usage = (ctx->API != API_OPENGLES);
+      break;
+
+   case GL_STATIC_DRAW_ARB:
+   case GL_DYNAMIC_DRAW_ARB:
+      valid_usage = true;
+      break;
+
    case GL_STREAM_READ_ARB:
    case GL_STREAM_COPY_ARB:
-   case GL_STATIC_DRAW_ARB:
    case GL_STATIC_READ_ARB:
    case GL_STATIC_COPY_ARB:
-   case GL_DYNAMIC_DRAW_ARB:
    case GL_DYNAMIC_READ_ARB:
    case GL_DYNAMIC_COPY_ARB:
-      /* OK */
+      valid_usage = (ctx->API == API_OPENGL
+                     || (ctx->API == API_OPENGLES2 && ctx->Version >= 30));
       break;
+
    default:
-      _mesa_error(ctx, GL_INVALID_ENUM, "glBufferDataARB(usage)");
+      valid_usage = false;
+      break;
+   }
+
+   if (!valid_usage) {
+      _mesa_error(ctx, GL_INVALID_ENUM, "glBufferData(usage)");
       return;
    }
 
@@ -1115,20 +1135,29 @@ _mesa_MapBufferARB(GLenum target, GLenum access)
    struct gl_buffer_object * bufObj;
    GLbitfield accessFlags;
    void *map;
+   bool valid_access;
 
    ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, NULL);
 
    switch (access) {
    case GL_READ_ONLY_ARB:
       accessFlags = GL_MAP_READ_BIT;
+      valid_access = (ctx->API == API_OPENGL);
       break;
    case GL_WRITE_ONLY_ARB:
       accessFlags = GL_MAP_WRITE_BIT;
+      valid_access = true;
       break;
    case GL_READ_WRITE_ARB:
       accessFlags = GL_MAP_READ_BIT | GL_MAP_WRITE_BIT;
+      valid_access = (ctx->API == API_OPENGL);
       break;
    default:
+      valid_access = false;
+      break;
+   }
+
+   if (!valid_access) {
       _mesa_error(ctx, GL_INVALID_ENUM, "glMapBufferARB(access)");
       return NULL;
    }
@@ -1282,17 +1311,17 @@ _mesa_GetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
       *params = _mesa_bufferobj_mapped(bufObj);
       return;
    case GL_BUFFER_ACCESS_FLAGS:
-      if (!ctx->Extensions.ARB_map_buffer_range)
+      if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_map_buffer_range)
          goto invalid_pname;
       *params = bufObj->AccessFlags;
       return;
    case GL_BUFFER_MAP_OFFSET:
-      if (!ctx->Extensions.ARB_map_buffer_range)
+      if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_map_buffer_range)
          goto invalid_pname;
       *params = (GLint) bufObj->Offset;
       return;
    case GL_BUFFER_MAP_LENGTH:
-      if (!ctx->Extensions.ARB_map_buffer_range)
+      if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_map_buffer_range)
          goto invalid_pname;
       *params = (GLint) bufObj->Length;
       return;
@@ -2214,6 +2243,9 @@ _mesa_init_bufferobj_dispatch(struct _glapi_table *disp)
    SET_IsBufferARB(disp, _mesa_IsBufferARB);
    SET_MapBufferARB(disp, _mesa_MapBufferARB);
    SET_UnmapBufferARB(disp, _mesa_UnmapBufferARB);
+
+   /* FINISHME: These functions are not available in OpenGL ES.
+    */
    SET_BindBufferRangeEXT(disp, _mesa_BindBufferRange);
    SET_BindBufferBaseEXT(disp, _mesa_BindBufferBase);
 }
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index b78bcee..0a52a1a 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -431,7 +431,7 @@ one_time_init( struct gl_context *ctx )
        * when an app is linked to libGLES*, there are not enough dynamic
        * entries.
        */
-      if (_mesa_is_desktop_gl(ctx))
+      if (_mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES2)
          _mesa_init_remap_table();
    }
 
@@ -964,9 +964,10 @@ _mesa_initialize_context(struct gl_context *ctx,
 #if FEATURE_dispatch
    /* setup the API dispatch tables */
    switch (ctx->API) {
-#if FEATURE_GL
+#if FEATURE_GL || FEATURE_ES2
    case API_OPENGL:
    case API_OPENGL_CORE:
+   case API_OPENGLES2:
       ctx->Exec = _mesa_create_exec_table(ctx);
       break;
 #endif
@@ -975,11 +976,6 @@ _mesa_initialize_context(struct gl_context *ctx,
       ctx->Exec = _mesa_create_exec_table_es1();
       break;
 #endif
-#if FEATURE_ES2
-   case API_OPENGLES2:
-      ctx->Exec = _mesa_create_exec_table_es2();
-      break;
-#endif
    default:
       _mesa_problem(ctx, "unknown or unsupported API");
       break;
diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index f811057..89626d5 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -209,8 +209,6 @@ _mesa_DisableClientState( GLenum cap )
       goto invalid_enum_error;						\
    }
 
-
-
 /**
  * Return pointer to current texture unit for setting/getting coordinate
  * state.
@@ -274,12 +272,16 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
    switch (cap) {
       case GL_ALPHA_TEST:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Color.AlphaEnabled == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_COLOR);
          ctx->Color.AlphaEnabled = state;
          break;
       case GL_AUTO_NORMAL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.AutoNormal == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
@@ -327,6 +329,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          break;
 #endif
       case GL_COLOR_MATERIAL:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Light.ColorMaterialEnabled == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_LIGHT);
@@ -350,6 +354,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->Depth.Test = state;
          break;
       case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          ctx->Debug.SyncOutput = state;
          break;
       case GL_DITHER:
@@ -359,6 +365,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->Color.DitherFlag = state;
          break;
       case GL_FOG:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Fog.Enabled == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_FOG);
@@ -372,6 +380,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
       case GL_LIGHT5:
       case GL_LIGHT6:
       case GL_LIGHT7:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Light.Light[cap-GL_LIGHT0].Enabled == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_LIGHT);
@@ -385,6 +395,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          }
          break;
       case GL_LIGHTING:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Light.Enabled == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_LIGHT);
@@ -395,6 +407,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
             ctx->_TriangleCaps &= ~DD_TRI_LIGHT_TWOSIDE;
          break;
       case GL_LINE_SMOOTH:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Line.SmoothFlag == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_LINE);
@@ -402,6 +416,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->_TriangleCaps ^= DD_LINE_SMOOTH;
          break;
       case GL_LINE_STIPPLE:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Line.StippleFlag == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_LINE);
@@ -409,132 +425,176 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->_TriangleCaps ^= DD_LINE_STIPPLE;
          break;
       case GL_INDEX_LOGIC_OP:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Color.IndexLogicOpEnabled == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_COLOR);
          ctx->Color.IndexLogicOpEnabled = state;
          break;
       case GL_COLOR_LOGIC_OP:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Color.ColorLogicOpEnabled == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_COLOR);
          ctx->Color.ColorLogicOpEnabled = state;
          break;
       case GL_MAP1_COLOR_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1Color4 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1Color4 = state;
          break;
       case GL_MAP1_INDEX:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1Index == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1Index = state;
          break;
       case GL_MAP1_NORMAL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1Normal == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1Normal = state;
          break;
       case GL_MAP1_TEXTURE_COORD_1:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1TextureCoord1 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1TextureCoord1 = state;
          break;
       case GL_MAP1_TEXTURE_COORD_2:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1TextureCoord2 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1TextureCoord2 = state;
          break;
       case GL_MAP1_TEXTURE_COORD_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1TextureCoord3 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1TextureCoord3 = state;
          break;
       case GL_MAP1_TEXTURE_COORD_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1TextureCoord4 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1TextureCoord4 = state;
          break;
       case GL_MAP1_VERTEX_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1Vertex3 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1Vertex3 = state;
          break;
       case GL_MAP1_VERTEX_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map1Vertex4 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map1Vertex4 = state;
          break;
       case GL_MAP2_COLOR_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2Color4 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2Color4 = state;
          break;
       case GL_MAP2_INDEX:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2Index == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2Index = state;
          break;
       case GL_MAP2_NORMAL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2Normal == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2Normal = state;
          break;
       case GL_MAP2_TEXTURE_COORD_1:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2TextureCoord1 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2TextureCoord1 = state;
          break;
       case GL_MAP2_TEXTURE_COORD_2:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2TextureCoord2 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2TextureCoord2 = state;
          break;
       case GL_MAP2_TEXTURE_COORD_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2TextureCoord3 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2TextureCoord3 = state;
          break;
       case GL_MAP2_TEXTURE_COORD_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2TextureCoord4 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2TextureCoord4 = state;
          break;
       case GL_MAP2_VERTEX_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2Vertex3 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2Vertex3 = state;
          break;
       case GL_MAP2_VERTEX_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Eval.Map2Vertex4 == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_EVAL);
          ctx->Eval.Map2Vertex4 = state;
          break;
       case GL_NORMALIZE:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Transform.Normalize == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
          ctx->Transform.Normalize = state;
          break;
       case GL_POINT_SMOOTH:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Point.SmoothFlag == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_POINT);
@@ -542,6 +602,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->_TriangleCaps ^= DD_POINT_SMOOTH;
          break;
       case GL_POLYGON_SMOOTH:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Polygon.SmoothFlag == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_POLYGON);
@@ -549,6 +611,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->_TriangleCaps ^= DD_TRI_SMOOTH;
          break;
       case GL_POLYGON_STIPPLE:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Polygon.StippleFlag == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_POLYGON);
@@ -556,12 +620,16 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->_TriangleCaps ^= DD_TRI_STIPPLE;
          break;
       case GL_POLYGON_OFFSET_POINT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Polygon.OffsetPoint == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_POLYGON);
          ctx->Polygon.OffsetPoint = state;
          break;
       case GL_POLYGON_OFFSET_LINE:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Polygon.OffsetLine == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_POLYGON);
@@ -574,6 +642,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->Polygon.OffsetFill = state;
          break;
       case GL_RESCALE_NORMAL_EXT:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Transform.RescaleNormals == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
@@ -592,16 +662,22 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->Stencil.Enabled = state;
          break;
       case GL_TEXTURE_1D:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (!enable_texture(ctx, state, TEXTURE_1D_BIT)) {
             return;
          }
          break;
       case GL_TEXTURE_2D:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (!enable_texture(ctx, state, TEXTURE_2D_BIT)) {
             return;
          }
          break;
       case GL_TEXTURE_3D:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (!enable_texture(ctx, state, TEXTURE_3D_BIT)) {
             return;
          }
@@ -612,6 +688,10 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
       case GL_TEXTURE_GEN_Q:
          {
             struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
+
+            if (ctx->API != API_OPENGL)
+               goto invalid_enum_error;
+
             if (texUnit) {
                GLbitfield coordBit = S_BIT << (cap - GL_TEXTURE_GEN_S);
                GLbitfield newenabled = texUnit->TexGenEnabled & ~coordBit;
@@ -630,6 +710,10 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 	 /* disable S, T, and R at the same time */
 	 {
             struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
+
+            if (ctx->API != API_OPENGLES)
+               goto invalid_enum_error;
+
             if (texUnit) {
                GLuint newenabled =
 		  texUnit->TexGenEnabled & ~STR_BITS;
@@ -659,6 +743,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_ARB_texture_cube_map */
       case GL_TEXTURE_CUBE_MAP_ARB:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          CHECK_EXTENSION(ARB_texture_cube_map, cap);
          if (!enable_texture(ctx, state, TEXTURE_CUBE_BIT)) {
             return;
@@ -667,6 +753,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_EXT_secondary_color */
       case GL_COLOR_SUM_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(EXT_secondary_color, ARB_vertex_program, cap);
          if (ctx->Fog.ColorSumEnabled == state)
             return;
@@ -688,6 +776,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->Multisample.SampleAlphaToCoverage = state;
          break;
       case GL_SAMPLE_ALPHA_TO_ONE_ARB:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          if (ctx->Multisample.SampleAlphaToOne == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
@@ -700,6 +790,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->Multisample.SampleCoverage = state;
          break;
       case GL_SAMPLE_COVERAGE_INVERT_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (ctx->Multisample.SampleCoverageInvert == state)
             return;
          FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
@@ -708,6 +800,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_IBM_rasterpos_clip */
       case GL_RASTER_POSITION_UNCLIPPED_IBM:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(IBM_rasterpos_clip, cap);
          if (ctx->Transform.RasterPositionUnclipped == state)
             return;
@@ -717,6 +811,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_NV_point_sprite */
       case GL_POINT_SPRITE_NV:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(NV_point_sprite, ARB_point_sprite, cap);
          if (ctx->Point.PointSprite == state)
             return;
@@ -726,6 +822,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
 #if FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program
       case GL_VERTEX_PROGRAM_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program, cap);
          if (ctx->VertexProgram.Enabled == state)
             return;
@@ -733,6 +831,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->VertexProgram.Enabled = state;
          break;
       case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program, cap);
          if (ctx->VertexProgram.PointSizeEnabled == state)
             return;
@@ -740,6 +840,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          ctx->VertexProgram.PointSizeEnabled = state;
          break;
       case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program, cap);
          if (ctx->VertexProgram.TwoSideEnabled == state)
             return;
@@ -764,6 +866,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
       case GL_MAP1_VERTEX_ATTRIB13_4_NV:
       case GL_MAP1_VERTEX_ATTRIB14_4_NV:
       case GL_MAP1_VERTEX_ATTRIB15_4_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_vertex_program, cap);
          {
             const GLuint map = (GLuint) (cap - GL_MAP1_VERTEX_ATTRIB0_4_NV);
@@ -787,6 +891,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
       case GL_MAP2_VERTEX_ATTRIB13_4_NV:
       case GL_MAP2_VERTEX_ATTRIB14_4_NV:
       case GL_MAP2_VERTEX_ATTRIB15_4_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_vertex_program, cap);
          {
             const GLuint map = (GLuint) (cap - GL_MAP2_VERTEX_ATTRIB0_4_NV);
@@ -798,6 +904,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
 #if FEATURE_NV_fragment_program
       case GL_FRAGMENT_PROGRAM_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_fragment_program, cap);
          if (ctx->FragmentProgram.Enabled == state)
             return;
@@ -808,6 +916,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_NV_texture_rectangle */
       case GL_TEXTURE_RECTANGLE_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_texture_rectangle, cap);
          if (!enable_texture(ctx, state, TEXTURE_RECT_BIT)) {
             return;
@@ -816,6 +926,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_EXT_stencil_two_side */
       case GL_STENCIL_TEST_TWO_SIDE_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(EXT_stencil_two_side, cap);
          if (ctx->Stencil.TestTwoSide == state)
             return;
@@ -830,6 +942,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
 #if FEATURE_ARB_fragment_program
       case GL_FRAGMENT_PROGRAM_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(ARB_fragment_program, cap);
          if (ctx->FragmentProgram.Enabled == state)
             return;
@@ -840,6 +954,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_EXT_depth_bounds_test */
       case GL_DEPTH_BOUNDS_TEST_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(EXT_depth_bounds_test, cap);
          if (ctx->Depth.BoundsTest == state)
             return;
@@ -848,15 +964,19 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          break;
 
       case GL_DEPTH_CLAMP:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
+	 CHECK_EXTENSION(ARB_depth_clamp, cap);
          if (ctx->Transform.DepthClamp == state)
             return;
-	 CHECK_EXTENSION(ARB_depth_clamp, cap);
          FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
 	 ctx->Transform.DepthClamp = state;
 	 break;
 
 #if FEATURE_ATI_fragment_shader
       case GL_FRAGMENT_SHADER_ATI:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
         CHECK_EXTENSION(ATI_fragment_shader, cap);
 	if (ctx->ATIFragmentShader.Enabled == state)
 	  return;
@@ -867,6 +987,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_MESA_texture_array */
       case GL_TEXTURE_1D_ARRAY_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(MESA_texture_array, cap);
          if (!enable_texture(ctx, state, TEXTURE_1D_ARRAY_BIT)) {
             return;
@@ -874,6 +996,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          break;
 
       case GL_TEXTURE_2D_ARRAY_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(MESA_texture_array, cap);
          if (!enable_texture(ctx, state, TEXTURE_2D_ARRAY_BIT)) {
             return;
@@ -881,6 +1005,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
          break;
 
       case GL_TEXTURE_CUBE_MAP_SEAMLESS:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 CHECK_EXTENSION(ARB_seamless_cube_map, cap);
 	 if (ctx->Texture.CubeMapSeamless != state) {
 	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
@@ -890,6 +1016,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
 #if FEATURE_EXT_transform_feedback
       case GL_RASTERIZER_DISCARD:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 CHECK_EXTENSION(EXT_transform_feedback, cap);
          if (ctx->RasterDiscard != state) {
             FLUSH_VERTICES(ctx, _NEW_RASTERIZER_DISCARD);
@@ -902,7 +1030,7 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
        * GL_PRIMITIVE_RESTART_NV (which is client state).
        */
       case GL_PRIMITIVE_RESTART:
-         if (ctx->Version < 31) {
+         if (ctx->API != API_OPENGL || ctx->Version < 31) {
             goto invalid_enum_error;
          }
          if (ctx->Array.PrimitiveRestart != state) {
@@ -913,6 +1041,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL3.0 - GL_framebuffer_sRGB */
       case GL_FRAMEBUFFER_SRGB_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(EXT_framebuffer_sRGB, cap);
          FLUSH_VERTICES(ctx, _NEW_BUFFERS);
          ctx->Color.sRGBEnabled = state;
@@ -920,6 +1050,8 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
 
       /* GL_OES_EGL_image_external */
       case GL_TEXTURE_EXTERNAL_OES:
+         if (ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2)
+            goto invalid_enum_error;
          CHECK_EXTENSION(OES_EGL_image_external, cap);
          if (!enable_texture(ctx, state, TEXTURE_EXTERNAL_BIT)) {
             return;
@@ -1092,8 +1224,12 @@ _mesa_IsEnabled( GLenum cap )
 
    switch (cap) {
       case GL_ALPHA_TEST:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return ctx->Color.AlphaEnabled;
       case GL_AUTO_NORMAL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.AutoNormal;
       case GL_BLEND:
          return ctx->Color.BlendEnabled & 1;  /* return state for buffer[0] */
@@ -1113,18 +1249,26 @@ _mesa_IsEnabled( GLenum cap )
 	 return (ctx->Transform.ClipPlanesEnabled >> p) & 1;
       }
       case GL_COLOR_MATERIAL:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
 	 return ctx->Light.ColorMaterialEnabled;
       case GL_CULL_FACE:
          return ctx->Polygon.CullFlag;
       case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          return ctx->Debug.SyncOutput;
       case GL_DEPTH_TEST:
          return ctx->Depth.Test;
       case GL_DITHER:
 	 return ctx->Color.DitherFlag;
       case GL_FOG:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
 	 return ctx->Fog.Enabled;
       case GL_LIGHTING:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return ctx->Light.Enabled;
       case GL_LIGHT0:
       case GL_LIGHT1:
@@ -1134,76 +1278,142 @@ _mesa_IsEnabled( GLenum cap )
       case GL_LIGHT5:
       case GL_LIGHT6:
       case GL_LIGHT7:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return ctx->Light.Light[cap-GL_LIGHT0].Enabled;
       case GL_LINE_SMOOTH:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
 	 return ctx->Line.SmoothFlag;
       case GL_LINE_STIPPLE:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Line.StippleFlag;
       case GL_INDEX_LOGIC_OP:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Color.IndexLogicOpEnabled;
       case GL_COLOR_LOGIC_OP:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
 	 return ctx->Color.ColorLogicOpEnabled;
       case GL_MAP1_COLOR_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1Color4;
       case GL_MAP1_INDEX:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1Index;
       case GL_MAP1_NORMAL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1Normal;
       case GL_MAP1_TEXTURE_COORD_1:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1TextureCoord1;
       case GL_MAP1_TEXTURE_COORD_2:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1TextureCoord2;
       case GL_MAP1_TEXTURE_COORD_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1TextureCoord3;
       case GL_MAP1_TEXTURE_COORD_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1TextureCoord4;
       case GL_MAP1_VERTEX_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1Vertex3;
       case GL_MAP1_VERTEX_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map1Vertex4;
       case GL_MAP2_COLOR_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2Color4;
       case GL_MAP2_INDEX:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2Index;
       case GL_MAP2_NORMAL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2Normal;
       case GL_MAP2_TEXTURE_COORD_1:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2TextureCoord1;
       case GL_MAP2_TEXTURE_COORD_2:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2TextureCoord2;
       case GL_MAP2_TEXTURE_COORD_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2TextureCoord3;
       case GL_MAP2_TEXTURE_COORD_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2TextureCoord4;
       case GL_MAP2_VERTEX_3:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2Vertex3;
       case GL_MAP2_VERTEX_4:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Eval.Map2Vertex4;
       case GL_NORMALIZE:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
 	 return ctx->Transform.Normalize;
       case GL_POINT_SMOOTH:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
 	 return ctx->Point.SmoothFlag;
       case GL_POLYGON_SMOOTH:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Polygon.SmoothFlag;
       case GL_POLYGON_STIPPLE:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Polygon.StippleFlag;
       case GL_POLYGON_OFFSET_POINT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Polygon.OffsetPoint;
       case GL_POLYGON_OFFSET_LINE:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 return ctx->Polygon.OffsetLine;
       case GL_POLYGON_OFFSET_FILL:
 	 return ctx->Polygon.OffsetFill;
       case GL_RESCALE_NORMAL_EXT:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return ctx->Transform.RescaleNormals;
       case GL_SCISSOR_TEST:
 	 return ctx->Scissor.Enabled;
       case GL_STENCIL_TEST:
 	 return ctx->Stencil.Enabled;
       case GL_TEXTURE_1D:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          return is_texture_enabled(ctx, TEXTURE_1D_BIT);
       case GL_TEXTURE_2D:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return is_texture_enabled(ctx, TEXTURE_2D_BIT);
       case GL_TEXTURE_3D:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return is_texture_enabled(ctx, TEXTURE_3D_BIT);
       case GL_TEXTURE_GEN_S:
       case GL_TEXTURE_GEN_T:
@@ -1211,6 +1421,10 @@ _mesa_IsEnabled( GLenum cap )
       case GL_TEXTURE_GEN_Q:
          {
             const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
+
+            if (ctx->API != API_OPENGL)
+               goto invalid_enum_error;
+
             if (texUnit) {
                GLbitfield coordBit = S_BIT << (cap - GL_TEXTURE_GEN_S);
                return (texUnit->TexGenEnabled & coordBit) ? GL_TRUE : GL_FALSE;
@@ -1221,6 +1435,10 @@ _mesa_IsEnabled( GLenum cap )
       case GL_TEXTURE_GEN_STR_OES:
 	 {
             const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
+
+            if (ctx->API != API_OPENGLES)
+               goto invalid_enum_error;
+
             if (texUnit) {
                return (texUnit->TexGenEnabled & STR_BITS) == STR_BITS
                   ? GL_TRUE : GL_FALSE;
@@ -1230,26 +1448,44 @@ _mesa_IsEnabled( GLenum cap )
 
       /* client-side state */
       case GL_VERTEX_ARRAY:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled != 0);
       case GL_NORMAL_ARRAY:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled != 0);
       case GL_COLOR_ARRAY:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled != 0);
       case GL_INDEX_ARRAY:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled != 0);
       case GL_TEXTURE_COORD_ARRAY:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)]
                  .Enabled != 0);
       case GL_EDGE_FLAG_ARRAY:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled != 0);
       case GL_FOG_COORDINATE_ARRAY_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(EXT_fog_coord);
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled != 0);
       case GL_SECONDARY_COLOR_ARRAY_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(EXT_secondary_color);
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled != 0);
 #if FEATURE_point_size_array
       case GL_POINT_SIZE_ARRAY_OES:
+         if (ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return (ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled != 0);
 #endif
 
@@ -1260,39 +1496,57 @@ _mesa_IsEnabled( GLenum cap )
 
       /* GL_EXT_secondary_color */
       case GL_COLOR_SUM_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(EXT_secondary_color, ARB_vertex_program);
          return ctx->Fog.ColorSumEnabled;
 
       /* GL_ARB_multisample */
       case GL_MULTISAMPLE_ARB:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return ctx->Multisample.Enabled;
       case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
          return ctx->Multisample.SampleAlphaToCoverage;
       case GL_SAMPLE_ALPHA_TO_ONE_ARB:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          return ctx->Multisample.SampleAlphaToOne;
       case GL_SAMPLE_COVERAGE_ARB:
          return ctx->Multisample.SampleCoverage;
       case GL_SAMPLE_COVERAGE_INVERT_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          return ctx->Multisample.SampleCoverageInvert;
 
       /* GL_IBM_rasterpos_clip */
       case GL_RASTER_POSITION_UNCLIPPED_IBM:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(IBM_rasterpos_clip);
          return ctx->Transform.RasterPositionUnclipped;
 
       /* GL_NV_point_sprite */
       case GL_POINT_SPRITE_NV:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(NV_point_sprite, ARB_point_sprite)
          return ctx->Point.PointSprite;
 
 #if FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program
       case GL_VERTEX_PROGRAM_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program);
          return ctx->VertexProgram.Enabled;
       case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program);
          return ctx->VertexProgram.PointSizeEnabled;
       case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program);
          return ctx->VertexProgram.TwoSideEnabled;
 #endif
@@ -1313,6 +1567,8 @@ _mesa_IsEnabled( GLenum cap )
       case GL_VERTEX_ATTRIB_ARRAY13_NV:
       case GL_VERTEX_ATTRIB_ARRAY14_NV:
       case GL_VERTEX_ATTRIB_ARRAY15_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_vertex_program);
          {
             GLint n = (GLint) cap - GL_VERTEX_ATTRIB_ARRAY0_NV;
@@ -1335,6 +1591,8 @@ _mesa_IsEnabled( GLenum cap )
       case GL_MAP1_VERTEX_ATTRIB13_4_NV:
       case GL_MAP1_VERTEX_ATTRIB14_4_NV:
       case GL_MAP1_VERTEX_ATTRIB15_4_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_vertex_program);
          {
             const GLuint map = (GLuint) (cap - GL_MAP1_VERTEX_ATTRIB0_4_NV);
@@ -1356,6 +1614,8 @@ _mesa_IsEnabled( GLenum cap )
       case GL_MAP2_VERTEX_ATTRIB13_4_NV:
       case GL_MAP2_VERTEX_ATTRIB14_4_NV:
       case GL_MAP2_VERTEX_ATTRIB15_4_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_vertex_program);
          {
             const GLuint map = (GLuint) (cap - GL_MAP2_VERTEX_ATTRIB0_4_NV);
@@ -1365,72 +1625,94 @@ _mesa_IsEnabled( GLenum cap )
 
 #if FEATURE_NV_fragment_program
       case GL_FRAGMENT_PROGRAM_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_fragment_program);
          return ctx->FragmentProgram.Enabled;
 #endif /* FEATURE_NV_fragment_program */
 
       /* GL_NV_texture_rectangle */
       case GL_TEXTURE_RECTANGLE_NV:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(NV_texture_rectangle);
          return is_texture_enabled(ctx, TEXTURE_RECT_BIT);
 
       /* GL_EXT_stencil_two_side */
       case GL_STENCIL_TEST_TWO_SIDE_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(EXT_stencil_two_side);
          return ctx->Stencil.TestTwoSide;
 
 #if FEATURE_ARB_fragment_program
       case GL_FRAGMENT_PROGRAM_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          return ctx->FragmentProgram.Enabled;
 #endif /* FEATURE_ARB_fragment_program */
 
       /* GL_EXT_depth_bounds_test */
       case GL_DEPTH_BOUNDS_TEST_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(EXT_depth_bounds_test);
          return ctx->Depth.BoundsTest;
 
       /* GL_ARB_depth_clamp */
       case GL_DEPTH_CLAMP:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          CHECK_EXTENSION(ARB_depth_clamp);
          return ctx->Transform.DepthClamp;
 
 #if FEATURE_ATI_fragment_shader
       case GL_FRAGMENT_SHADER_ATI:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 CHECK_EXTENSION(ATI_fragment_shader);
 	 return ctx->ATIFragmentShader.Enabled;
 #endif /* FEATURE_ATI_fragment_shader */
 
       case GL_TEXTURE_CUBE_MAP_SEAMLESS:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 CHECK_EXTENSION(ARB_seamless_cube_map);
 	 return ctx->Texture.CubeMapSeamless;
 
 #if FEATURE_EXT_transform_feedback
       case GL_RASTERIZER_DISCARD:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 CHECK_EXTENSION(EXT_transform_feedback);
          return ctx->RasterDiscard;
 #endif
 
       /* GL_NV_primitive_restart */
       case GL_PRIMITIVE_RESTART_NV:
-	 if (!ctx->Extensions.NV_primitive_restart) {
+         if (ctx->API != API_OPENGL || !ctx->Extensions.NV_primitive_restart) {
             goto invalid_enum_error;
          }
          return ctx->Array.PrimitiveRestart;
 
       /* GL 3.1 primitive restart */
       case GL_PRIMITIVE_RESTART:
-         if (ctx->Version < 31) {
+         if (ctx->API != API_OPENGL || ctx->Version < 31) {
             goto invalid_enum_error;
          }
          return ctx->Array.PrimitiveRestart;
 
       /* GL3.0 - GL_framebuffer_sRGB */
       case GL_FRAMEBUFFER_SRGB_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 CHECK_EXTENSION(EXT_framebuffer_sRGB);
 	 return ctx->Color.sRGBEnabled;
 
       /* GL_OES_EGL_image_external */
       case GL_TEXTURE_EXTERNAL_OES:
+         if (ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2)
+            goto invalid_enum_error;
 	 CHECK_EXTENSION(OES_EGL_image_external);
          return is_texture_enabled(ctx, TEXTURE_EXTERNAL_BIT);
 
diff --git a/src/mesa/main/es1_conversion.c b/src/mesa/main/es1_conversion.c
new file mode 100644
index 0000000..7129129
--- /dev/null
+++ b/src/mesa/main/es1_conversion.c
@@ -0,0 +1,943 @@
+#include <stdbool.h>
+#include "main/mfeatures.h"
+
+#ifdef FEATURE_ES1
+
+#include "api_loopback.h"
+#include "api_exec.h"
+#include "blend.h"
+#include "clear.h"
+#include "clip.h"
+#include "context.h"
+#include "depth.h"
+#include "fog.h"
+#include "imports.h"
+#include "light.h"
+#include "lines.h"
+#include "matrix.h"
+#include "multisample.h"
+#include "pixelstore.h"
+#include "points.h"
+#include "polygon.h"
+#include "readpix.h"
+#include "texenv.h"
+#include "texgen.h"
+#include "texobj.h"
+#include "texparam.h"
+#include "mtypes.h"
+#include "viewport.h"
+#include "main/drawtex.h"
+#include "vbo/vbo.h"
+
+#ifndef GL_APIENTRY
+#define GL_APIENTRY GLAPIENTRY
+#endif
+
+#include "main/es1_conversion.h"
+
+void GL_APIENTRY
+_es_AlphaFuncx(GLenum func, GLclampx ref)
+{
+   _mesa_AlphaFunc(func, (GLclampf) (ref / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_ClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
+{
+   _mesa_ClearColor((GLclampf) (red / 65536.0f),
+                    (GLclampf) (green / 65536.0f),
+                    (GLclampf) (blue / 65536.0f),
+                    (GLclampf) (alpha / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_ClearDepthx(GLclampx depth)
+{
+   _mesa_ClearDepthf((GLclampf) (depth / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_ClipPlanef(GLenum plane, const GLfloat *equation)
+{
+   unsigned int i;
+   GLdouble converted_equation[4];
+
+   for (i = 0; i < Elements(converted_equation); i++) {
+      converted_equation[i] = (GLdouble) (equation[i]);
+   }
+
+   _mesa_ClipPlane(plane, converted_equation);
+}
+
+void GL_APIENTRY
+_es_ClipPlanex(GLenum plane, const GLfixed *equation)
+{
+   unsigned int i;
+   GLdouble converted_equation[4];
+
+   for (i = 0; i < Elements(converted_equation); i++) {
+      converted_equation[i] = (GLdouble) (equation[i] / 65536.0);
+   }
+
+   _mesa_ClipPlane(plane, converted_equation);
+}
+
+void GL_APIENTRY
+_es_Color4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
+{
+    _es_Color4f((GLfloat) (red / 255.0f),
+                (GLfloat) (green / 255.0f),
+                (GLfloat) (blue / 255.0f),
+                (GLfloat) (alpha / 255.0f));
+}
+
+void GL_APIENTRY
+_es_Color4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
+{
+    _es_Color4f((GLfloat) (red / 65536.0f),
+                (GLfloat) (green / 65536.0f),
+                (GLfloat) (blue / 65536.0f),
+                (GLfloat) (alpha / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_DepthRangex(GLclampx zNear, GLclampx zFar)
+{
+    _mesa_DepthRangef((GLclampf) (zNear / 65536.0f),
+                      (GLclampf) (zFar / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_DrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w, GLfixed h)
+{
+
+    _mesa_DrawTexf((GLfloat) (x / 65536.0f),
+                   (GLfloat) (y / 65536.0f),
+                   (GLfloat) (z / 65536.0f),
+                   (GLfloat) (w / 65536.0f),
+                   (GLfloat) (h / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_DrawTexxvOES(const GLfixed *coords)
+{
+    unsigned int i;
+    GLfloat converted_coords[5];
+
+    for (i = 0; i < Elements(converted_coords); i++) {
+        converted_coords[i] = (GLfloat) (coords[i] / 65536.0f);
+    }
+
+    _mesa_DrawTexfv(converted_coords);
+}
+
+void GL_APIENTRY
+_es_Fogx(GLenum pname, GLfixed param)
+{
+   if (pname != GL_FOG_MODE) {
+      _mesa_Fogf(pname, (GLfloat) (param / 65536.0f));
+   } else {
+      _mesa_Fogf(pname, (GLfloat) param);
+   }
+
+}
+
+void GL_APIENTRY
+_es_Fogxv(GLenum pname, const GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+   bool convert_params_value = true;
+
+   switch(pname) {
+   case GL_FOG_MODE:
+      convert_params_value = false;
+      n_params = 1;
+      break;
+   case GL_FOG_COLOR:
+      n_params = 4;
+      break;
+   case GL_FOG_DENSITY:
+   case GL_FOG_START:
+   case GL_FOG_END:
+      n_params = 1;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glFogxv(pname=0x%x)", pname);
+      return;
+   }
+
+   if (convert_params_value) {
+      for (i = 0; i < n_params; i++) {
+         converted_params[i] = (GLfloat) (params[i] / 65536.0f);
+      }
+   } else {
+      for (i = 0; i < n_params; i++) {
+         converted_params[i] = (GLfloat) params[i];
+      }
+   }
+
+   _mesa_Fogfv(pname, converted_params);
+}
+
+void GL_APIENTRY
+_es_Frustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top,
+             GLfloat zNear, GLfloat zFar)
+{
+   _mesa_Frustum((GLdouble) (left),
+                 (GLdouble) (right),
+                 (GLdouble) (bottom),
+                 (GLdouble) (top),
+                 (GLdouble) (zNear),
+                 (GLdouble) (zFar));
+}
+
+void GL_APIENTRY
+_es_Frustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top,
+             GLfixed zNear, GLfixed zFar)
+{
+   _mesa_Frustum((GLdouble) (left / 65536.0),
+                 (GLdouble) (right / 65536.0),
+                 (GLdouble) (bottom / 65536.0),
+                 (GLdouble) (top / 65536.0),
+                 (GLdouble) (zNear / 65536.0),
+                 (GLdouble) (zFar / 65536.0));
+}
+
+void GL_APIENTRY
+_es_GetClipPlanef(GLenum plane, GLfloat *equation)
+{
+   unsigned int i;
+   GLdouble converted_equation[4];
+
+   _mesa_GetClipPlane(plane, converted_equation);
+   for (i = 0; i < Elements(converted_equation); i++) {
+      equation[i] = (GLfloat) (converted_equation[i]);
+   }
+}
+
+void GL_APIENTRY
+_es_GetClipPlanex(GLenum plane, GLfixed *equation)
+{
+   unsigned int i;
+   GLdouble converted_equation[4];
+
+   _mesa_GetClipPlane(plane, converted_equation);
+   for (i = 0; i < Elements(converted_equation); i++) {
+      equation[i] = (GLfixed) (converted_equation[i] * 65536);
+   }
+}
+
+void GL_APIENTRY
+_es_GetLightxv(GLenum light, GLenum pname, GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+
+   if (light < GL_LIGHT0 || light > GL_LIGHT7) {
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetLightxv(light=0x%x)", light);
+      return;
+   }
+   switch(pname) {
+   case GL_AMBIENT:
+   case GL_DIFFUSE:
+   case GL_SPECULAR:
+   case GL_POSITION:
+      n_params = 4;
+      break;
+   case GL_SPOT_DIRECTION:
+      n_params = 3;
+      break;
+   case GL_SPOT_EXPONENT:
+   case GL_SPOT_CUTOFF:
+   case GL_CONSTANT_ATTENUATION:
+   case GL_LINEAR_ATTENUATION:
+   case GL_QUADRATIC_ATTENUATION:
+      n_params = 1;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetLightxv(pname=0x%x)", pname);
+      return;
+   }
+
+   _mesa_GetLightfv(light, pname, converted_params);
+   for (i = 0; i < n_params; i++) {
+      params[i] = (GLint) (converted_params[i] * 65536);
+   }
+}
+
+void GL_APIENTRY
+_es_GetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+
+   switch(face) {
+   case GL_FRONT:
+   case GL_BACK:
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetMaterialxv(face=0x%x)", face);
+      return;
+   }
+   switch(pname) {
+   case GL_SHININESS:
+      n_params = 1;
+      break;
+   case GL_AMBIENT:
+   case GL_DIFFUSE:
+   case GL_SPECULAR:
+   case GL_EMISSION:
+      n_params = 4;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetMaterialxv(pname=0x%x)", pname);
+      return;
+   }
+
+   _mesa_GetMaterialfv(face, pname, converted_params);
+   for (i = 0; i < n_params; i++) {
+      params[i] = (GLint) (converted_params[i] * 65536);
+   }
+}
+
+void GL_APIENTRY
+_es_GetTexEnvxv(GLenum target, GLenum pname, GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+   bool convert_params_value = true;
+
+   switch(target) {
+   case GL_POINT_SPRITE:
+      if (pname != GL_COORD_REPLACE) {
+         _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                     "glGetTexEnvxv(target=0x%x)", target);
+         return;
+      }
+      break;
+   case GL_TEXTURE_FILTER_CONTROL_EXT:
+      if (pname != GL_TEXTURE_LOD_BIAS_EXT) {
+         _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                     "glGetTexEnvxv(target=0x%x)", target);
+         return;
+      }
+      break;
+   case GL_TEXTURE_ENV:
+      if (pname != GL_TEXTURE_ENV_COLOR && pname != GL_RGB_SCALE && pname != GL_ALPHA_SCALE && pname != GL_TEXTURE_ENV_MODE && pname != GL_COMBINE_RGB && pname != GL_COMBINE_ALPHA && pname != GL_SRC0_RGB && pname != GL_SRC1_RGB && pname != GL_SRC2_RGB && pname != GL_SRC0_ALPHA && pname != GL_SRC1_ALPHA && pname != GL_SRC2_ALPHA && pname != GL_OPERAND0_RGB && pname != GL_OPERAND1_RGB && pname != GL_OPERAND2_RGB && pname != GL_OPERAND0_ALPHA && pname != GL_OPERAND1_ALPHA && pname != GL_OPERAND2_ALPHA) {
+         _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                     "glGetTexEnvxv(target=0x%x)", target);
+         return;
+      }
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetTexEnvxv(target=0x%x)", target);
+      return;
+   }
+   switch(pname) {
+   case GL_COORD_REPLACE:
+      convert_params_value = false;
+      n_params = 1;
+      break;
+   case GL_TEXTURE_LOD_BIAS_EXT:
+      n_params = 1;
+      break;
+   case GL_TEXTURE_ENV_COLOR:
+      n_params = 4;
+      break;
+   case GL_RGB_SCALE:
+   case GL_ALPHA_SCALE:
+      n_params = 1;
+      break;
+   case GL_TEXTURE_ENV_MODE:
+   case GL_COMBINE_RGB:
+   case GL_COMBINE_ALPHA:
+   case GL_SRC0_RGB:
+   case GL_SRC1_RGB:
+   case GL_SRC2_RGB:
+   case GL_SRC0_ALPHA:
+   case GL_SRC1_ALPHA:
+   case GL_SRC2_ALPHA:
+   case GL_OPERAND0_RGB:
+   case GL_OPERAND1_RGB:
+   case GL_OPERAND2_RGB:
+   case GL_OPERAND0_ALPHA:
+   case GL_OPERAND1_ALPHA:
+   case GL_OPERAND2_ALPHA:
+      convert_params_value = false;
+      n_params = 1;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetTexEnvxv(pname=0x%x)", pname);
+      return;
+   }
+
+   _mesa_GetTexEnvfv(target, pname, converted_params);
+   if (convert_params_value) {
+      for (i = 0; i < n_params; i++) {
+         params[i] = (GLint) (converted_params[i] * 65536);
+      }
+   } else {
+      for (i = 0; i < n_params; i++) {
+         params[i] = (GLfixed) converted_params[i];
+      }
+   }
+}
+
+void GL_APIENTRY
+_check_GetTexGenivOES(GLenum coord, GLenum pname, GLint *params)
+{
+   _mesa_GetTexGeniv(coord, pname, params);
+}
+
+void GL_APIENTRY
+_check_GetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params)
+{
+   _mesa_GetTexGeniv(coord, pname, (GLint *) params);
+}
+
+void GL_APIENTRY
+_es_GetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+   bool convert_params_value = true;
+
+   switch(target) {
+   case GL_TEXTURE_2D:
+   case GL_TEXTURE_CUBE_MAP:
+   case GL_TEXTURE_EXTERNAL_OES:
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetTexParameterxv(target=0x%x)", target);
+      return;
+   }
+   switch(pname) {
+   case GL_TEXTURE_WRAP_S:
+   case GL_TEXTURE_WRAP_T:
+   case GL_TEXTURE_MIN_FILTER:
+   case GL_TEXTURE_MAG_FILTER:
+   case GL_GENERATE_MIPMAP:
+      convert_params_value = false;
+      n_params = 1;
+      break;
+   case GL_TEXTURE_CROP_RECT_OES:
+      n_params = 4;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glGetTexParameterxv(pname=0x%x)", pname);
+      return;
+   }
+
+   _mesa_GetTexParameterfv(target, pname, converted_params);
+   if (convert_params_value) {
+      for (i = 0; i < n_params; i++) {
+         params[i] = (GLint) (converted_params[i] * 65536);
+      }
+   } else {
+      for (i = 0; i < n_params; i++) {
+         params[i] = (GLfixed) converted_params[i];
+      }
+   }
+}
+
+void GL_APIENTRY
+_es_LightModelx(GLenum pname, GLfixed param)
+{
+   _mesa_LightModelf(pname, (GLfloat) param);
+}
+
+void GL_APIENTRY
+_es_LightModelxv(GLenum pname, const GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+   bool convert_params_value = true;
+
+   switch(pname) {
+   case GL_LIGHT_MODEL_AMBIENT:
+      n_params = 4;
+      break;
+   case GL_LIGHT_MODEL_TWO_SIDE:
+      convert_params_value = false;
+      n_params = 1;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glLightModelxv(pname=0x%x)", pname);
+      return;
+   }
+
+   if (convert_params_value) {
+      for (i = 0; i < n_params; i++) {
+         converted_params[i] = (GLfloat) (params[i] / 65536.0f);
+      }
+   } else {
+      for (i = 0; i < n_params; i++) {
+         converted_params[i] = (GLfloat) params[i];
+      }
+   }
+
+   _mesa_LightModelfv(pname, converted_params);
+}
+
+void GL_APIENTRY
+_es_Lightx(GLenum light, GLenum pname, GLfixed param)
+{
+   _mesa_Lightf(light, pname, (GLfloat) (param / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_Lightxv(GLenum light, GLenum pname, const GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+
+   if (light < GL_LIGHT0 || light > GL_LIGHT7) {
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glLightxv(light=0x%x)", light);
+      return;
+   }
+   switch(pname) {
+   case GL_AMBIENT:
+   case GL_DIFFUSE:
+   case GL_SPECULAR:
+   case GL_POSITION:
+      n_params = 4;
+      break;
+   case GL_SPOT_DIRECTION:
+      n_params = 3;
+      break;
+   case GL_SPOT_EXPONENT:
+   case GL_SPOT_CUTOFF:
+   case GL_CONSTANT_ATTENUATION:
+   case GL_LINEAR_ATTENUATION:
+   case GL_QUADRATIC_ATTENUATION:
+      n_params = 1;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glLightxv(pname=0x%x)", pname);
+      return;
+   }
+
+   for (i = 0; i < n_params; i++) {
+      converted_params[i] = (GLfloat) (params[i] / 65536.0f);
+   }
+
+   _mesa_Lightfv(light, pname, converted_params);
+}
+
+void GL_APIENTRY
+_es_LineWidthx(GLfixed width)
+{
+   _mesa_LineWidth((GLfloat) (width / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_LoadMatrixx(const GLfixed *m)
+{
+   unsigned int i;
+   GLfloat converted_m[16];
+
+   for (i = 0; i < Elements(converted_m); i++) {
+      converted_m[i] = (GLfloat) (m[i] / 65536.0f);
+   }
+
+   _mesa_LoadMatrixf(converted_m);
+}
+
+void GL_APIENTRY
+_es_Materialx(GLenum face, GLenum pname, GLfixed param)
+{
+   if (face != GL_FRONT_AND_BACK) {
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glMaterialx(face=0x%x)", face);
+      return;
+   }
+
+   if (pname != GL_SHININESS) {
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glMaterialx(pname=0x%x)", pname);
+      return;
+   }
+
+   _es_Materialf(face, pname, (GLfloat) (param / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_Materialxv(GLenum face, GLenum pname, const GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+
+   if (face != GL_FRONT_AND_BACK) {
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glMaterialxv(face=0x%x)", face);
+      return;
+   }
+
+   switch(pname) {
+   case GL_AMBIENT:
+   case GL_DIFFUSE:
+   case GL_AMBIENT_AND_DIFFUSE:
+   case GL_SPECULAR:
+   case GL_EMISSION:
+      n_params = 4;
+      break;
+   case GL_SHININESS:
+      n_params = 1;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glMaterialxv(pname=0x%x)", pname);
+      return;
+   }
+
+   for (i = 0; i < n_params; i++) {
+      converted_params[i] = (GLfloat) (params[i] / 65536.0f);
+   }
+
+   _es_Materialfv(face, pname, converted_params);
+}
+
+void GL_APIENTRY
+_es_MultMatrixx(const GLfixed *m)
+{
+   unsigned int i;
+   GLfloat converted_m[16];
+
+   for (i = 0; i < Elements(converted_m); i++) {
+      converted_m[i] = (GLfloat) (m[i] / 65536.0f);
+   }
+
+   _mesa_MultMatrixf(converted_m);
+}
+
+void GL_APIENTRY
+_es_MultiTexCoord4x(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
+{
+   _es_MultiTexCoord4f(texture,
+                       (GLfloat) (s / 65536.0f),
+                       (GLfloat) (t / 65536.0f),
+                       (GLfloat) (r / 65536.0f),
+                       (GLfloat) (q / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_Normal3x(GLfixed nx, GLfixed ny, GLfixed nz)
+{
+   _es_Normal3f((GLfloat) (nx / 65536.0f),
+                (GLfloat) (ny / 65536.0f),
+                (GLfloat) (nz / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_Orthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top,
+           GLfloat zNear, GLfloat zFar)
+{
+   _mesa_Ortho((GLdouble) (left),
+               (GLdouble) (right),
+               (GLdouble) (bottom),
+               (GLdouble) (top),
+               (GLdouble) (zNear),
+               (GLdouble) (zFar));
+}
+
+void GL_APIENTRY
+_es_Orthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top,
+           GLfixed zNear, GLfixed zFar)
+{
+   _mesa_Ortho((GLdouble) (left / 65536.0),
+               (GLdouble) (right / 65536.0),
+               (GLdouble) (bottom / 65536.0),
+               (GLdouble) (top / 65536.0),
+               (GLdouble) (zNear / 65536.0),
+               (GLdouble) (zFar / 65536.0));
+}
+
+void GL_APIENTRY
+_es_PointParameterx(GLenum pname, GLfixed param)
+{
+   _mesa_PointParameterf(pname, (GLfloat) (param / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_PointParameterxv(GLenum pname, const GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 3;
+   GLfloat converted_params[3];
+
+   switch(pname) {
+   case GL_POINT_SIZE_MIN:
+   case GL_POINT_SIZE_MAX:
+   case GL_POINT_FADE_THRESHOLD_SIZE:
+      n_params = 1;
+      break;
+   case GL_POINT_DISTANCE_ATTENUATION:
+      n_params = 3;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glPointParameterxv(pname=0x%x)", pname);
+      return;
+   }
+
+   for (i = 0; i < n_params; i++) {
+      converted_params[i] = (GLfloat) (params[i] / 65536.0f);
+   }
+
+   _mesa_PointParameterfv(pname, converted_params);
+}
+
+void GL_APIENTRY
+_es_PointSizex(GLfixed size)
+{
+   _mesa_PointSize((GLfloat) (size / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_PolygonOffsetx(GLfixed factor, GLfixed units)
+{
+   _mesa_PolygonOffset((GLfloat) (factor / 65536.0f),
+                       (GLfloat) (units / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_Rotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
+{
+   _mesa_Rotatef((GLfloat) (angle / 65536.0f),
+                 (GLfloat) (x / 65536.0f),
+                 (GLfloat) (y / 65536.0f),
+                 (GLfloat) (z / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_SampleCoveragex(GLclampx value, GLboolean invert)
+{
+   _mesa_SampleCoverageARB((GLclampf) (value / 65536.0f),
+                           invert);
+}
+
+void GL_APIENTRY
+_es_Scalex(GLfixed x, GLfixed y, GLfixed z)
+{
+   _mesa_Scalef((GLfloat) (x / 65536.0f),
+                (GLfloat) (y / 65536.0f),
+                (GLfloat) (z / 65536.0f));
+}
+
+void GL_APIENTRY
+_es_TexEnvx(GLenum target, GLenum pname, GLfixed param)
+{
+   switch(target) {
+   case GL_POINT_SPRITE:
+   case GL_TEXTURE_FILTER_CONTROL_EXT:
+   case GL_TEXTURE_ENV:
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glTexEnvx(target=0x%x)", target);
+      return;
+   }
+
+   switch(pname) {
+   case GL_COORD_REPLACE:
+   case GL_TEXTURE_ENV_MODE:
+   case GL_COMBINE_RGB:
+   case GL_COMBINE_ALPHA:
+   case GL_SRC0_RGB:
+   case GL_SRC1_RGB:
+   case GL_SRC2_RGB:
+   case GL_SRC0_ALPHA:
+   case GL_SRC1_ALPHA:
+   case GL_SRC2_ALPHA:
+   case GL_OPERAND0_RGB:
+   case GL_OPERAND1_RGB:
+   case GL_OPERAND2_RGB:
+   case GL_OPERAND0_ALPHA:
+   case GL_OPERAND1_ALPHA:
+   case GL_OPERAND2_ALPHA:
+      _mesa_TexEnvf(target, pname, (GLfloat) param);
+      break;
+   case GL_TEXTURE_LOD_BIAS_EXT:
+   case GL_RGB_SCALE:
+   case GL_ALPHA_SCALE:
+      _mesa_TexEnvf(target, pname, (GLfloat) (param / 65536.0f));
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glTexEnvx(pname=0x%x)", pname);
+      return;
+   }
+}
+
+void GL_APIENTRY
+_es_TexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
+{
+   switch(target) {
+   case GL_POINT_SPRITE:
+   case GL_TEXTURE_FILTER_CONTROL_EXT:
+   case GL_TEXTURE_ENV:
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glTexEnvxv(target=0x%x)", target);
+      return;
+   }
+
+   switch(pname) {
+   case GL_COORD_REPLACE:
+   case GL_TEXTURE_ENV_MODE:
+   case GL_COMBINE_RGB:
+   case GL_COMBINE_ALPHA:
+   case GL_SRC0_RGB:
+   case GL_SRC1_RGB:
+   case GL_SRC2_RGB:
+   case GL_SRC0_ALPHA:
+   case GL_SRC1_ALPHA:
+   case GL_SRC2_ALPHA:
+   case GL_OPERAND0_RGB:
+   case GL_OPERAND1_RGB:
+   case GL_OPERAND2_RGB:
+   case GL_OPERAND0_ALPHA:
+   case GL_OPERAND1_ALPHA:
+   case GL_OPERAND2_ALPHA:
+      _mesa_TexEnvf(target, pname, (GLfloat) params[0]);
+      break;
+   case GL_TEXTURE_LOD_BIAS_EXT:
+   case GL_RGB_SCALE:
+   case GL_ALPHA_SCALE:
+      _mesa_TexEnvf(target, pname, (GLfloat) (params[0] / 65536.0f));
+      break;
+   case GL_TEXTURE_ENV_COLOR: {
+      unsigned int i;
+      GLfloat converted_params[4];
+
+      for (i = 0; i < Elements(converted_params); i++) {
+         converted_params[i] = (GLfloat) (params[i] / 65536.0f);
+      }
+
+      _mesa_TexEnvfv(target, pname, converted_params);
+      break;
+   }
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glTexEnvxv(pname=0x%x)", pname);
+      return;
+   }
+}
+
+void GL_APIENTRY
+_check_TexGeniOES(GLenum coord, GLenum pname, GLint param)
+{
+   _es_TexGenf(coord, pname, (GLfloat) param);
+}
+
+void GL_APIENTRY
+_check_TexGenivOES(GLenum coord, GLenum pname, const GLint *params)
+{
+   _es_TexGenf(coord, pname, (GLfloat) params[0]);
+}
+
+void GL_APIENTRY
+_check_TexGenxOES(GLenum coord, GLenum pname, GLfixed param)
+{
+   _es_TexGenf(coord, pname, (GLfloat) param);
+}
+
+void GL_APIENTRY
+_check_TexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params)
+{
+   _es_TexGenf(coord, pname, (GLfloat) params[0]);
+}
+
+void GL_APIENTRY
+_es_TexParameterx(GLenum target, GLenum pname, GLfixed param)
+{
+   if (pname == GL_TEXTURE_MAX_ANISOTROPY_EXT) {
+      _mesa_TexParameterf(target, pname, (GLfloat) (param / 65536.0f));
+   } else {
+      _mesa_TexParameterf(target, pname, (GLfloat) param);
+   }
+}
+
+void GL_APIENTRY
+_es_TexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
+{
+   unsigned int i;
+   unsigned int n_params = 4;
+   GLfloat converted_params[4];
+   bool convert_params_value = true;
+
+   switch(target) {
+   case GL_TEXTURE_2D:
+   case GL_TEXTURE_CUBE_MAP:
+   case GL_TEXTURE_EXTERNAL_OES:
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glTexParameterxv(target=0x%x)", target);
+      return;
+   }
+   switch(pname) {
+   case GL_TEXTURE_WRAP_S:
+   case GL_TEXTURE_WRAP_T:
+   case GL_TEXTURE_MIN_FILTER:
+   case GL_TEXTURE_MAG_FILTER:
+   case GL_GENERATE_MIPMAP:
+      convert_params_value = false;
+      n_params = 1;
+      break;
+   case GL_TEXTURE_MAX_ANISOTROPY_EXT:
+      n_params = 1;
+      break;
+   case GL_TEXTURE_CROP_RECT_OES:
+      n_params = 4;
+      break;
+   default:
+      _mesa_error(_mesa_get_current_context(), GL_INVALID_ENUM,
+                  "glTexParameterxv(pname=0x%x)", pname);
+      return;
+   }
+
+   if (convert_params_value) {
+      for (i = 0; i < n_params; i++) {
+         converted_params[i] = (GLfloat) (params[i] / 65536.0f);
+      }
+   } else {
+      for (i = 0; i < n_params; i++) {
+         converted_params[i] = (GLfloat) params[i];
+      }
+   }
+
+   _mesa_TexParameterfv(target, pname, converted_params);
+}
+
+void GL_APIENTRY
+_es_Translatex(GLfixed x, GLfixed y, GLfixed z)
+{
+    _mesa_Translatef((GLfloat) (x / 65536.0f),
+                     (GLfloat) (y / 65536.0f),
+                     (GLfloat) (z / 65536.0f));
+}
+
+#endif /* FEATURE_ES1 */
diff --git a/src/mesa/main/es1_conversion.h b/src/mesa/main/es1_conversion.h
new file mode 100644
index 0000000..ece3893
--- /dev/null
+++ b/src/mesa/main/es1_conversion.h
@@ -0,0 +1,157 @@
+void GL_APIENTRY
+_es_AlphaFuncx(GLenum func, GLclampx ref);
+
+void GL_APIENTRY
+_es_ClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
+
+void GL_APIENTRY
+_es_ClearDepthx(GLclampx depth);
+
+void GL_APIENTRY
+_es_ClipPlanef(GLenum plane, const GLfloat *equation);
+
+void GL_APIENTRY
+_es_ClipPlanex(GLenum plane, const GLfixed *equation);
+
+void GL_APIENTRY
+_es_Color4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
+
+void GL_APIENTRY
+_es_Color4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
+
+void GL_APIENTRY
+_es_DepthRangex(GLclampx zNear, GLclampx zFar);
+
+void GL_APIENTRY
+_es_DrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w, GLfixed h);
+
+void GL_APIENTRY
+_es_DrawTexxvOES(const GLfixed *coords);
+
+void GL_APIENTRY
+_es_Fogx(GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_es_Fogxv(GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_es_Frustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top,
+             GLfloat zNear, GLfloat zFar);
+
+void GL_APIENTRY
+_es_Frustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top,
+             GLfixed zNear, GLfixed zFar);
+
+void GL_APIENTRY
+_es_GetClipPlanef(GLenum plane, GLfloat *equation);
+
+void GL_APIENTRY
+_es_GetClipPlanex(GLenum plane, GLfixed *equation);
+
+void GL_APIENTRY
+_es_GetLightxv(GLenum light, GLenum pname, GLfixed *params);
+
+void GL_APIENTRY
+_es_GetMaterialxv(GLenum face, GLenum pname, GLfixed *params);
+
+void GL_APIENTRY
+_check_GetTexGenivOES(GLenum coord, GLenum pname, GLint *params);
+
+void GL_APIENTRY
+_es_GetTexEnvxv(GLenum target, GLenum pname, GLfixed *params);
+
+void GL_APIENTRY
+_check_GetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params);
+
+void GL_APIENTRY
+_es_GetTexParameterxv(GLenum target, GLenum pname, GLfixed *params);
+
+void GL_APIENTRY
+_es_LightModelx(GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_es_LightModelxv(GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_es_Lightx(GLenum light, GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_es_Lightxv(GLenum light, GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_es_LineWidthx(GLfixed width);
+
+void GL_APIENTRY
+_es_LoadMatrixx(const GLfixed *m);
+
+void GL_APIENTRY
+_es_Materialx(GLenum face, GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_es_Materialxv(GLenum face, GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_es_MultMatrixx(const GLfixed *m);
+
+void GL_APIENTRY
+_es_MultiTexCoord4x(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
+
+void GL_APIENTRY
+_es_Normal3x(GLfixed nx, GLfixed ny, GLfixed nz);
+
+void GL_APIENTRY
+_es_Orthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top,
+           GLfloat zNear, GLfloat zFar);
+
+void GL_APIENTRY
+_es_Orthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top,
+           GLfixed zNear, GLfixed zFar);
+
+void GL_APIENTRY
+_es_PointParameterx(GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_es_PointParameterxv(GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_es_PointSizex(GLfixed size);
+
+void GL_APIENTRY
+_es_PolygonOffsetx(GLfixed factor, GLfixed units);
+
+void GL_APIENTRY
+_es_Rotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
+
+void GL_APIENTRY
+_es_SampleCoveragex(GLclampx value, GLboolean invert);
+
+void GL_APIENTRY
+_es_Scalex(GLfixed x, GLfixed y, GLfixed z);
+
+void GL_APIENTRY
+_es_TexEnvx(GLenum target, GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_es_TexEnvxv(GLenum target, GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_check_TexGeniOES(GLenum coord, GLenum pname, GLint param);
+
+void GL_APIENTRY
+_check_TexGenivOES(GLenum coord, GLenum pname, const GLint *params);
+
+void GL_APIENTRY
+_check_TexGenxOES(GLenum coord, GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_check_TexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_es_TexParameterx(GLenum target, GLenum pname, GLfixed param);
+
+void GL_APIENTRY
+_es_TexParameterxv(GLenum target, GLenum pname, const GLfixed *params);
+
+void GL_APIENTRY
+_es_Translatex(GLfixed x, GLfixed y, GLfixed z);
+
diff --git a/src/mesa/main/es_generator.py b/src/mesa/main/es_generator.py
index cad3dea..b074e9d 100644
--- a/src/mesa/main/es_generator.py
+++ b/src/mesa/main/es_generator.py
@@ -201,6 +201,10 @@ print """
 #endif
 """ % (versionHeader, versionExtHeader, shortname.upper())
 
+if version == "GLES1.1":
+    print '#include "main/es1_conversion.h"'
+    print
+
 # Everyone needs these types.
 print """
 /* These types are needed for the Mesa veneer, but are not defined in
@@ -566,6 +570,9 @@ for funcName in keys:
 
     # endfor every param
 
+    if conversionCodeOutgoing != [] or conversionCodeIncoming != []:
+        continue
+
     # Here, the passthroughDeclarationString and passthroughCallString
     # are complete; remove the extra ", " at the front of each.
     passthroughDeclarationString = passthroughDeclarationString[2:]
diff --git a/src/mesa/main/extensions.c b/src/mesa/main/extensions.c
index 521fe14..3327764 100644
--- a/src/mesa/main/extensions.c
+++ b/src/mesa/main/extensions.c
@@ -80,6 +80,7 @@ struct extension {
 static const struct extension extension_table[] = {
    /* ARB Extensions */
    { "GL_ARB_ES2_compatibility",                   o(ARB_ES2_compatibility),                   GL,             2009 },
+   { "GL_ARB_ES3_compatibility",                   o(ARB_ES3_compatibility),                   GL,             2012 },
    { "GL_ARB_base_instance",                       o(ARB_base_instance),                       GL,             2011 },
    { "GL_ARB_blend_func_extended",                 o(ARB_blend_func_extended),                 GL,             2009 },
    { "GL_ARB_color_buffer_float",                  o(ARB_color_buffer_float),                  GL,             2004 },
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index d558d7f..0d14c7f 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -1072,13 +1072,15 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_ALPHA8:
    case GL_ALPHA12:
    case GL_ALPHA16:
-      return ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_framebuffer_object
+         ? GL_ALPHA : 0;
    case GL_LUMINANCE:
    case GL_LUMINANCE4:
    case GL_LUMINANCE8:
    case GL_LUMINANCE12:
    case GL_LUMINANCE16:
-      return ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_framebuffer_object
+         ? GL_LUMINANCE : 0;
    case GL_LUMINANCE_ALPHA:
    case GL_LUMINANCE4_ALPHA4:
    case GL_LUMINANCE6_ALPHA2:
@@ -1086,99 +1088,113 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_LUMINANCE12_ALPHA4:
    case GL_LUMINANCE12_ALPHA12:
    case GL_LUMINANCE16_ALPHA16:
-      return ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_framebuffer_object
+         ? GL_LUMINANCE_ALPHA : 0;
    case GL_INTENSITY:
    case GL_INTENSITY4:
    case GL_INTENSITY8:
    case GL_INTENSITY12:
    case GL_INTENSITY16:
-      return ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_framebuffer_object
+         ? GL_INTENSITY : 0;
+   case GL_RGB8:
+      return GL_RGB;
    case GL_RGB:
    case GL_R3_G3_B2:
    case GL_RGB4:
    case GL_RGB5:
-   case GL_RGB8:
    case GL_RGB10:
    case GL_RGB12:
    case GL_RGB16:
    case GL_SRGB8_EXT:
-      return GL_RGB;
-   case GL_RGBA:
-   case GL_RGBA2:
+      return ctx->API == API_OPENGL ? GL_RGB : 0;
    case GL_RGBA4:
    case GL_RGB5_A1:
    case GL_RGBA8:
+      return GL_RGBA;
+   case GL_RGBA:
+   case GL_RGBA2:
    case GL_RGB10_A2:
    case GL_RGBA12:
    case GL_RGBA16:
    case GL_SRGB8_ALPHA8_EXT:
-      return GL_RGBA;
+      return ctx->API == API_OPENGL ? GL_RGBA : 0;
    case GL_STENCIL_INDEX:
    case GL_STENCIL_INDEX1_EXT:
    case GL_STENCIL_INDEX4_EXT:
-   case GL_STENCIL_INDEX8_EXT:
    case GL_STENCIL_INDEX16_EXT:
+      /* There are extensions for GL_STENCIL_INDEX1 and GL_STENCIL_INDEX4 in
+       * OpenGL ES, but Mesa does not currently support them.
+       */
+      return ctx->API == API_OPENGL ? GL_STENCIL_INDEX : 0;
+   case GL_STENCIL_INDEX8_EXT:
       return GL_STENCIL_INDEX;
    case GL_DEPTH_COMPONENT:
+   case GL_DEPTH_COMPONENT32:
+      return ctx->API == API_OPENGL ? GL_DEPTH_COMPONENT : 0;
    case GL_DEPTH_COMPONENT16:
    case GL_DEPTH_COMPONENT24:
-   case GL_DEPTH_COMPONENT32:
       return GL_DEPTH_COMPONENT;
    case GL_DEPTH_STENCIL_EXT:
+      return ctx->API == API_OPENGL && ctx->Extensions.EXT_packed_depth_stencil
+         ? GL_DEPTH_STENCIL_EXT : 0;
    case GL_DEPTH24_STENCIL8_EXT:
-      if (ctx->Extensions.EXT_packed_depth_stencil)
-         return GL_DEPTH_STENCIL_EXT;
-      else
-         return 0;
+      return ctx->Extensions.EXT_packed_depth_stencil
+         ? GL_DEPTH_STENCIL_EXT : 0;
    case GL_DEPTH_COMPONENT32F:
-      if (ctx->Extensions.ARB_depth_buffer_float)
-         return GL_DEPTH_COMPONENT;
-      else
-         return 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_depth_buffer_float
+         ? GL_DEPTH_COMPONENT : 0;
    case GL_DEPTH32F_STENCIL8:
-      if (ctx->Extensions.ARB_depth_buffer_float)
-         return GL_DEPTH_STENCIL;
-      else
-         return 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_depth_buffer_float
+         ? GL_DEPTH_STENCIL : 0;
    case GL_RED:
    case GL_R8:
    case GL_R16:
-      return ctx->Extensions.ARB_texture_rg ? GL_RED : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_texture_rg
+         ? GL_RED : 0;
    case GL_RG:
    case GL_RG8:
    case GL_RG16:
-      return ctx->Extensions.ARB_texture_rg ? GL_RG : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_texture_rg
+         ? GL_RG : 0;
    /* signed normalized texture formats */
    case GL_RED_SNORM:
    case GL_R8_SNORM:
    case GL_R16_SNORM:
-      return ctx->Extensions.EXT_texture_snorm ? GL_RED : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.EXT_texture_snorm
+         ? GL_RED : 0;
    case GL_RG_SNORM:
    case GL_RG8_SNORM:
    case GL_RG16_SNORM:
-      return ctx->Extensions.EXT_texture_snorm ? GL_RG : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.EXT_texture_snorm
+         ? GL_RG : 0;
    case GL_RGB_SNORM:
    case GL_RGB8_SNORM:
    case GL_RGB16_SNORM:
-      return ctx->Extensions.EXT_texture_snorm ? GL_RGB : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.EXT_texture_snorm
+         ? GL_RGB : 0;
    case GL_RGBA_SNORM:
    case GL_RGBA8_SNORM:
    case GL_RGBA16_SNORM:
-      return ctx->Extensions.EXT_texture_snorm ? GL_RGBA : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.EXT_texture_snorm
+         ? GL_RGBA : 0;
    case GL_ALPHA_SNORM:
    case GL_ALPHA8_SNORM:
    case GL_ALPHA16_SNORM:
-      return ctx->Extensions.EXT_texture_snorm &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_snorm &&
              ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
    case GL_LUMINANCE_SNORM:
    case GL_LUMINANCE8_SNORM:
    case GL_LUMINANCE16_SNORM:
-      return ctx->Extensions.EXT_texture_snorm &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_snorm &&
              ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
    case GL_LUMINANCE_ALPHA_SNORM:
    case GL_LUMINANCE8_ALPHA8_SNORM:
    case GL_LUMINANCE16_ALPHA16_SNORM:
-      return ctx->Extensions.EXT_texture_snorm &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_snorm &&
              ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
    case GL_INTENSITY_SNORM:
    case GL_INTENSITY8_SNORM:
@@ -1187,38 +1203,48 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
              ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
    case GL_R16F:
    case GL_R32F:
-      return ctx->Extensions.ARB_texture_rg &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.ARB_texture_rg &&
              ctx->Extensions.ARB_texture_float ? GL_RED : 0;
    case GL_RG16F:
    case GL_RG32F:
-      return ctx->Extensions.ARB_texture_rg &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.ARB_texture_rg &&
              ctx->Extensions.ARB_texture_float ? GL_RG : 0;
    case GL_RGB16F:
    case GL_RGB32F:
-      return ctx->Extensions.ARB_texture_float ? GL_RGB : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_texture_float
+         ? GL_RGB : 0;
    case GL_RGBA16F:
    case GL_RGBA32F:
-      return ctx->Extensions.ARB_texture_float ? GL_RGBA : 0;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_texture_float
+         ? GL_RGBA : 0;
    case GL_ALPHA16F_ARB:
    case GL_ALPHA32F_ARB:
-      return ctx->Extensions.ARB_texture_float &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.ARB_texture_float &&
              ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
    case GL_LUMINANCE16F_ARB:
    case GL_LUMINANCE32F_ARB:
-      return ctx->Extensions.ARB_texture_float &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.ARB_texture_float &&
              ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
    case GL_LUMINANCE_ALPHA16F_ARB:
    case GL_LUMINANCE_ALPHA32F_ARB:
-      return ctx->Extensions.ARB_texture_float &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.ARB_texture_float &&
              ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
    case GL_INTENSITY16F_ARB:
    case GL_INTENSITY32F_ARB:
-      return ctx->Extensions.ARB_texture_float &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.ARB_texture_float &&
              ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
    case GL_RGB9_E5:
-      return ctx->Extensions.EXT_texture_shared_exponent ? GL_RGB : 0;
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_shared_exponent ? GL_RGB : 0;
    case GL_R11F_G11F_B10F:
-      return ctx->Extensions.EXT_packed_float ? GL_RGB : 0;
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_packed_float ? GL_RGB : 0;
 
    case GL_RGBA8UI_EXT:
    case GL_RGBA16UI_EXT:
@@ -1226,8 +1252,9 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_RGBA8I_EXT:
    case GL_RGBA16I_EXT:
    case GL_RGBA32I_EXT:
-      return ctx->Version >= 30 ||
-             ctx->Extensions.EXT_texture_integer ? GL_RGBA : 0;
+      return ctx->API == API_OPENGL &&
+         (ctx->Version >= 30 ||
+          ctx->Extensions.EXT_texture_integer) ? GL_RGBA : 0;
 
    case GL_RGB8UI_EXT:
    case GL_RGB16UI_EXT:
@@ -1235,8 +1262,9 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_RGB8I_EXT:
    case GL_RGB16I_EXT:
    case GL_RGB32I_EXT:
-      return ctx->Version >= 30 ||
-             ctx->Extensions.EXT_texture_integer ? GL_RGB : 0;
+      return ctx->API == API_OPENGL &&
+         (ctx->Version >= 30 ||
+          ctx->Extensions.EXT_texture_integer) ? GL_RGB : 0;
 
    case GL_R8UI:
    case GL_R8I:
@@ -1244,9 +1272,10 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_R16I:
    case GL_R32UI:
    case GL_R32I:
-      return ctx->Version >= 30 ||
-             (ctx->Extensions.ARB_texture_rg &&
-              ctx->Extensions.EXT_texture_integer) ? GL_RED : 0;
+      return ctx->API == API_OPENGL &&
+         (ctx->Version >= 30 ||
+          (ctx->Extensions.ARB_texture_rg &&
+           ctx->Extensions.EXT_texture_integer)) ? GL_RED : 0;
 
    case GL_RG8UI:
    case GL_RG8I:
@@ -1254,9 +1283,10 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_RG16I:
    case GL_RG32UI:
    case GL_RG32I:
-      return ctx->Version >= 30 ||
-             (ctx->Extensions.ARB_texture_rg &&
-              ctx->Extensions.EXT_texture_integer) ? GL_RG : 0;
+      return ctx->API == API_OPENGL &&
+         (ctx->Version >= 30 ||
+          (ctx->Extensions.ARB_texture_rg &&
+           ctx->Extensions.EXT_texture_integer)) ? GL_RG : 0;
 
    case GL_INTENSITY8I_EXT:
    case GL_INTENSITY8UI_EXT:
@@ -1264,7 +1294,8 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_INTENSITY16UI_EXT:
    case GL_INTENSITY32I_EXT:
    case GL_INTENSITY32UI_EXT:
-      return ctx->Extensions.EXT_texture_integer &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_integer &&
              ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
 
    case GL_LUMINANCE8I_EXT:
@@ -1273,7 +1304,8 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_LUMINANCE16UI_EXT:
    case GL_LUMINANCE32I_EXT:
    case GL_LUMINANCE32UI_EXT:
-      return ctx->Extensions.EXT_texture_integer &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_integer &&
              ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
 
    case GL_LUMINANCE_ALPHA8I_EXT:
@@ -1282,7 +1314,8 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_LUMINANCE_ALPHA16UI_EXT:
    case GL_LUMINANCE_ALPHA32I_EXT:
    case GL_LUMINANCE_ALPHA32UI_EXT:
-      return ctx->Extensions.EXT_texture_integer &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_integer &&
              ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
 
    case GL_ALPHA8I_EXT:
@@ -1291,14 +1324,18 @@ _mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
    case GL_ALPHA16UI_EXT:
    case GL_ALPHA32I_EXT:
    case GL_ALPHA32UI_EXT:
-      return ctx->Extensions.EXT_texture_integer &&
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.EXT_texture_integer &&
              ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
 
    case GL_RGB10_A2UI:
-      return ctx->Extensions.ARB_texture_rgb10_a2ui ? GL_RGBA : 0;
+      return ctx->API == API_OPENGL &&
+             ctx->Extensions.ARB_texture_rgb10_a2ui ? GL_RGBA : 0;
 
    case GL_RGB565:
-      return ctx->Extensions.ARB_ES2_compatibility ? GL_RGB : 0;
+      return ctx->API == API_OPENGLES ||
+             ctx->API == API_OPENGLES2 ||
+             ctx->Extensions.ARB_ES2_compatibility ? GL_RGB : 0;
    default:
       return 0;
    }
@@ -1569,7 +1606,7 @@ _mesa_GetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
       *params = get_component_bits(pname, rb->_BaseFormat, rb->Format);
       break;
    case GL_RENDERBUFFER_SAMPLES:
-      if (ctx->Extensions.ARB_framebuffer_object) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ARB_framebuffer_object) {
          *params = rb->NumSamples;
          break;
       }
@@ -2134,7 +2171,8 @@ _mesa_FramebufferTexture2DEXT(GLenum target, GLenum attachment,
          error = GL_FALSE;
          break;
       case GL_TEXTURE_RECTANGLE:
-         error = !ctx->Extensions.NV_texture_rectangle;
+         error = ctx->API != API_OPENGL
+            || !ctx->Extensions.NV_texture_rectangle;
          break;
       case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
       case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
@@ -2145,7 +2183,7 @@ _mesa_FramebufferTexture2DEXT(GLenum target, GLenum attachment,
          error = !ctx->Extensions.ARB_texture_cube_map;
          break;
       case GL_TEXTURE_2D_ARRAY:
-         error = !ctx->Extensions.EXT_texture_array;
+         error = ctx->API != API_OPENGL || !ctx->Extensions.EXT_texture_array;
          break;
       default:
          error = GL_TRUE;
@@ -2415,7 +2453,7 @@ _mesa_GetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment,
       }
       return;
    case GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
-      if (!ctx->Extensions.ARB_framebuffer_object) {
+      if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_framebuffer_object) {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glGetFramebufferAttachmentParameterivEXT(pname)");
       }
@@ -2435,7 +2473,7 @@ _mesa_GetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment,
       }
       return;
    case GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
-      if (!ctx->Extensions.ARB_framebuffer_object) {
+      if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_framebuffer_object) {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glGetFramebufferAttachmentParameterivEXT(pname)");
          return;
@@ -2470,7 +2508,7 @@ _mesa_GetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment,
    case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
    case GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
    case GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
-      if (!ctx->Extensions.ARB_framebuffer_object) {
+      if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_framebuffer_object) {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glGetFramebufferAttachmentParameterivEXT(pname)");
       }
@@ -2521,6 +2559,8 @@ _mesa_GenerateMipmapEXT(GLenum target)
 
    switch (target) {
    case GL_TEXTURE_1D:
+      error = ctx->API != API_OPENGL;
+      break;
    case GL_TEXTURE_2D:
    case GL_TEXTURE_3D:
       error = GL_FALSE;
@@ -2530,7 +2570,7 @@ _mesa_GenerateMipmapEXT(GLenum target)
       break;
    case GL_TEXTURE_1D_ARRAY:
    case GL_TEXTURE_2D_ARRAY:
-      error = !ctx->Extensions.EXT_texture_array;
+      error = ctx->API != API_OPENGL || !ctx->Extensions.EXT_texture_array;
       break;
    default:
       error = GL_TRUE;
diff --git a/src/mesa/main/ff_fragment_shader.cpp b/src/mesa/main/ff_fragment_shader.cpp
index f743ce1..4fbbacc 100644
--- a/src/mesa/main/ff_fragment_shader.cpp
+++ b/src/mesa/main/ff_fragment_shader.cpp
@@ -1309,6 +1309,7 @@ create_new_program(struct gl_context *ctx, struct state_key *key)
    p.shader_program->InternalSeparateShader = GL_TRUE;
 
    state->language_version = 130;
+   state->es_shader = false;
    if (ctx->Extensions.OES_EGL_image_external)
       state->OES_EGL_image_external_enable = true;
    _mesa_glsl_initialize_types(state);
diff --git a/src/mesa/main/fog.c b/src/mesa/main/fog.c
index d65add9..07405fb 100644
--- a/src/mesa/main/fog.c
+++ b/src/mesa/main/fog.c
@@ -141,6 +141,8 @@ _mesa_Fogfv( GLenum pname, const GLfloat *params )
          update_fog_scale(ctx);
          break;
       case GL_FOG_INDEX:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
  	 if (ctx->Fog.Index == *params)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_FOG);
@@ -161,7 +163,7 @@ _mesa_Fogfv( GLenum pname, const GLfloat *params )
          break;
       case GL_FOG_COORDINATE_SOURCE_EXT: {
 	 GLenum p = (GLenum) (GLint) *params;
-         if (!ctx->Extensions.EXT_fog_coord ||
+         if (ctx->API != API_OPENGL || !ctx->Extensions.EXT_fog_coord ||
              (p != GL_FOG_COORDINATE_EXT && p != GL_FRAGMENT_DEPTH_EXT)) {
 	    _mesa_error(ctx, GL_INVALID_ENUM, "glFog");
 	    return;
@@ -174,7 +176,7 @@ _mesa_Fogfv( GLenum pname, const GLfloat *params )
       }
       case GL_FOG_DISTANCE_MODE_NV: {
 	 GLenum p = (GLenum) (GLint) *params;
-         if (!ctx->Extensions.NV_fog_distance ||
+         if (ctx->API != API_OPENGL || !ctx->Extensions.NV_fog_distance ||
              (p != GL_EYE_RADIAL_NV && p != GL_EYE_PLANE && p != GL_EYE_PLANE_ABSOLUTE_NV)) {
 	    _mesa_error(ctx, GL_INVALID_ENUM, "glFog");
 	    return;
@@ -186,13 +188,18 @@ _mesa_Fogfv( GLenum pname, const GLfloat *params )
 	 break;
       }
       default:
-         _mesa_error( ctx, GL_INVALID_ENUM, "glFog" );
-         return;
+         goto invalid_pname;
    }
 
    if (ctx->Driver.Fogfv) {
       (*ctx->Driver.Fogfv)( ctx, pname, params );
    }
+
+   return;
+
+invalid_pname:
+   _mesa_error( ctx, GL_INVALID_ENUM, "glFog" );
+   return;
 }
 
 
diff --git a/src/mesa/main/get.c b/src/mesa/main/get.c
index 332dfaf..3f7d223 100644
--- a/src/mesa/main/get.c
+++ b/src/mesa/main/get.c
@@ -705,6 +705,15 @@ static const struct value_desc values[] = {
    { GL_MAX_TEXTURE_COORDS_ARB, /* == GL_MAX_TEXTURE_COORDS_NV */
      CONTEXT_INT(Const.MaxTextureCoordUnits),
      extra_ARB_fragment_program_NV_fragment_program },
+   { GL_PACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Pack.ImageHeight), NO_EXTRA },
+   { GL_PACK_ROW_LENGTH, CONTEXT_INT(Pack.RowLength), NO_EXTRA },
+   { GL_PACK_SKIP_PIXELS, CONTEXT_INT(Pack.SkipPixels), NO_EXTRA },
+   { GL_PACK_SKIP_ROWS, CONTEXT_INT(Pack.SkipRows), NO_EXTRA },
+   { GL_UNPACK_ROW_LENGTH, CONTEXT_INT(Unpack.RowLength), NO_EXTRA },
+   { GL_UNPACK_SKIP_PIXELS, CONTEXT_INT(Unpack.SkipPixels), NO_EXTRA },
+   { GL_UNPACK_SKIP_ROWS, CONTEXT_INT(Unpack.SkipRows), NO_EXTRA },
+   { GL_UNPACK_SKIP_IMAGES_EXT, CONTEXT_INT(Unpack.SkipImages), NO_EXTRA },
+   { GL_UNPACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Unpack.ImageHeight), NO_EXTRA },
 
    /* GL_ARB_draw_buffers */
    { GL_MAX_DRAW_BUFFERS_ARB, CONTEXT_INT(Const.MaxDrawBuffers), NO_EXTRA },
@@ -882,11 +891,7 @@ static const struct value_desc values[] = {
    { GL_MAX_PIXEL_MAP_TABLE, CONST(MAX_PIXEL_MAP_TABLE), NO_EXTRA },
    { GL_NAME_STACK_DEPTH, CONTEXT_INT(Select.NameStackDepth), NO_EXTRA },
    { GL_PACK_LSB_FIRST, CONTEXT_BOOL(Pack.LsbFirst), NO_EXTRA },
-   { GL_PACK_ROW_LENGTH, CONTEXT_INT(Pack.RowLength), NO_EXTRA },
-   { GL_PACK_SKIP_PIXELS, CONTEXT_INT(Pack.SkipPixels), NO_EXTRA },
-   { GL_PACK_SKIP_ROWS, CONTEXT_INT(Pack.SkipRows), NO_EXTRA },
    { GL_PACK_SWAP_BYTES, CONTEXT_BOOL(Pack.SwapBytes), NO_EXTRA },
-   { GL_PACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Pack.ImageHeight), NO_EXTRA },
    { GL_PACK_INVERT_MESA, CONTEXT_BOOL(Pack.Invert), NO_EXTRA },
    { GL_PIXEL_MAP_A_TO_A_SIZE, CONTEXT_INT(PixelMaps.AtoA.Size), NO_EXTRA },
    { GL_PIXEL_MAP_B_TO_B_SIZE, CONTEXT_INT(PixelMaps.BtoB.Size), NO_EXTRA },
@@ -936,12 +941,7 @@ static const struct value_desc values[] = {
    { GL_TEXTURE_GEN_Q, LOC_TEXUNIT, TYPE_BIT_3,
      offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
    { GL_UNPACK_LSB_FIRST, CONTEXT_BOOL(Unpack.LsbFirst), NO_EXTRA },
-   { GL_UNPACK_ROW_LENGTH, CONTEXT_INT(Unpack.RowLength), NO_EXTRA },
-   { GL_UNPACK_SKIP_PIXELS, CONTEXT_INT(Unpack.SkipPixels), NO_EXTRA },
-   { GL_UNPACK_SKIP_ROWS, CONTEXT_INT(Unpack.SkipRows), NO_EXTRA },
    { GL_UNPACK_SWAP_BYTES, CONTEXT_BOOL(Unpack.SwapBytes), NO_EXTRA },
-   { GL_UNPACK_SKIP_IMAGES_EXT, CONTEXT_INT(Unpack.SkipImages), NO_EXTRA },
-   { GL_UNPACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Unpack.ImageHeight), NO_EXTRA },
    { GL_ZOOM_X, CONTEXT_FLOAT(Pixel.ZoomX), NO_EXTRA },
    { GL_ZOOM_Y, CONTEXT_FLOAT(Pixel.ZoomY), NO_EXTRA },
 
diff --git a/src/mesa/main/getstring.c b/src/mesa/main/getstring.c
index 1734fb3..5bb35a6 100644
--- a/src/mesa/main/getstring.c
+++ b/src/mesa/main/getstring.c
@@ -74,7 +74,9 @@ shading_language_version(struct gl_context *ctx)
       break;
 
    case API_OPENGLES2:
-      return (const GLubyte *) "OpenGL ES GLSL ES 1.0.16";
+      return (ctx->Version < 30)
+         ? (const GLubyte *) "OpenGL ES GLSL ES 1.0.16"
+         : (const GLubyte *) "OpenGL ES GLSL ES 3.0";
 
    case API_OPENGLES:
       /* fall-through */
@@ -129,23 +131,28 @@ _mesa_GetString( GLenum name )
          return (const GLubyte *) ctx->Extensions.String;
 #if FEATURE_ARB_shading_language_100 || FEATURE_ES2
       case GL_SHADING_LANGUAGE_VERSION:
+         if (ctx->API == API_OPENGLES)
+            break;
 	 return shading_language_version(ctx);
 #endif
 #if FEATURE_NV_fragment_program || FEATURE_ARB_fragment_program || \
     FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program
       case GL_PROGRAM_ERROR_STRING_NV:
-         if (ctx->Extensions.NV_fragment_program ||
-             ctx->Extensions.ARB_fragment_program ||
-             ctx->Extensions.NV_vertex_program ||
-             ctx->Extensions.ARB_vertex_program) {
+         if (ctx->API == API_OPENGL &&
+             (ctx->Extensions.NV_fragment_program ||
+              ctx->Extensions.ARB_fragment_program ||
+              ctx->Extensions.NV_vertex_program ||
+              ctx->Extensions.ARB_vertex_program)) {
             return (const GLubyte *) ctx->Program.ErrorString;
          }
-         /* FALL-THROUGH */
+         break;
 #endif
       default:
-         _mesa_error( ctx, GL_INVALID_ENUM, "glGetString" );
-         return (const GLubyte *) 0;
+         break;
    }
+
+   _mesa_error( ctx, GL_INVALID_ENUM, "glGetString" );
+   return (const GLubyte *) 0;
 }
 
 
@@ -212,24 +219,36 @@ _mesa_GetPointerv( GLenum pname, GLvoid **params )
          *params = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Ptr;
          break;
       case GL_SECONDARY_COLOR_ARRAY_POINTER_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Ptr;
          break;
       case GL_FOG_COORDINATE_ARRAY_POINTER_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_FOG].Ptr;
          break;
       case GL_INDEX_ARRAY_POINTER:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Ptr;
          break;
       case GL_TEXTURE_COORD_ARRAY_POINTER:
          *params = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_TEX(clientUnit)].Ptr;
          break;
       case GL_EDGE_FLAG_ARRAY_POINTER:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Ptr;
          break;
       case GL_FEEDBACK_BUFFER_POINTER:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = ctx->Feedback.Buffer;
          break;
       case GL_SELECTION_BUFFER_POINTER:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = ctx->Select.Buffer;
          break;
 #if FEATURE_point_size_array
@@ -238,15 +257,24 @@ _mesa_GetPointerv( GLenum pname, GLvoid **params )
          break;
 #endif
       case GL_DEBUG_CALLBACK_FUNCTION_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = (GLvoid *) ctx->Debug.Callback;
          break;
       case GL_DEBUG_CALLBACK_USER_PARAM_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          *params = ctx->Debug.CallbackData;
          break;
       default:
-         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPointerv" );
-         return;
+         goto invalid_pname;
    }
+
+   return;
+
+invalid_pname:
+   _mesa_error( ctx, GL_INVALID_ENUM, "glGetPointerv" );
+   return;
 }
 
 
diff --git a/src/mesa/main/glformats.c b/src/mesa/main/glformats.c
index daf1b76..80b61c1 100644
--- a/src/mesa/main/glformats.c
+++ b/src/mesa/main/glformats.c
@@ -790,37 +790,45 @@ _mesa_is_compressed_format(struct gl_context *ctx, GLenum format)
    switch (format) {
    case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
    case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+      return ctx->Extensions.EXT_texture_compression_s3tc;
    case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
-      return ctx->Extensions.EXT_texture_compression_s3tc;
+      return ctx->API == API_OPENGL
+         && ctx->Extensions.EXT_texture_compression_s3tc;
    case GL_RGB_S3TC:
    case GL_RGB4_S3TC:
    case GL_RGBA_S3TC:
    case GL_RGBA4_S3TC:
-      return ctx->Extensions.S3_s3tc;
+      return ctx->API == API_OPENGL && ctx->Extensions.S3_s3tc;
    case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
    case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
    case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
    case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
-      return ctx->Extensions.EXT_texture_sRGB
+      return ctx->API == API_OPENGL
+         && ctx->Extensions.EXT_texture_sRGB
          && ctx->Extensions.EXT_texture_compression_s3tc;
    case GL_COMPRESSED_RGB_FXT1_3DFX:
    case GL_COMPRESSED_RGBA_FXT1_3DFX:
-      return ctx->Extensions.TDFX_texture_compression_FXT1;
+      return ctx->API == API_OPENGL
+         && ctx->Extensions.TDFX_texture_compression_FXT1;
    case GL_COMPRESSED_RED_RGTC1:
    case GL_COMPRESSED_SIGNED_RED_RGTC1:
    case GL_COMPRESSED_RG_RGTC2:
    case GL_COMPRESSED_SIGNED_RG_RGTC2:
-      return ctx->Extensions.ARB_texture_compression_rgtc;
+      return ctx->API == API_OPENGL
+         && ctx->Extensions.ARB_texture_compression_rgtc;
    case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
    case GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:
    case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
    case GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:
-      return ctx->Extensions.EXT_texture_compression_latc;
+      return ctx->API == API_OPENGL
+         && ctx->Extensions.EXT_texture_compression_latc;
    case GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI:
-      return ctx->Extensions.ATI_texture_compression_3dc;
+      return ctx->API == API_OPENGL
+         && ctx->Extensions.ATI_texture_compression_3dc;
    case GL_ETC1_RGB8_OES:
-      return ctx->Extensions.OES_compressed_ETC1_RGB8_texture;
+      return (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2)
+         && ctx->Extensions.OES_compressed_ETC1_RGB8_texture;
 #if FEATURE_ES
    case GL_PALETTE4_RGB8_OES:
    case GL_PALETTE4_RGBA8_OES:
diff --git a/src/mesa/main/hint.c b/src/mesa/main/hint.c
index ff8d88f..6c2ae52 100644
--- a/src/mesa/main/hint.c
+++ b/src/mesa/main/hint.c
@@ -51,30 +51,40 @@ _mesa_Hint( GLenum target, GLenum mode )
 
    switch (target) {
       case GL_FOG_HINT:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_target;
          if (ctx->Hint.Fog == mode)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_HINT);
          ctx->Hint.Fog = mode;
          break;
       case GL_LINE_SMOOTH_HINT:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_target;
          if (ctx->Hint.LineSmooth == mode)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_HINT);
          ctx->Hint.LineSmooth = mode;
          break;
       case GL_PERSPECTIVE_CORRECTION_HINT:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_target;
          if (ctx->Hint.PerspectiveCorrection == mode)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_HINT);
          ctx->Hint.PerspectiveCorrection = mode;
          break;
       case GL_POINT_SMOOTH_HINT:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_target;
          if (ctx->Hint.PointSmooth == mode)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_HINT);
          ctx->Hint.PointSmooth = mode;
          break;
       case GL_POLYGON_SMOOTH_HINT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_target;
          if (ctx->Hint.PolygonSmooth == mode)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_HINT);
@@ -83,6 +93,8 @@ _mesa_Hint( GLenum target, GLenum mode )
 
       /* GL_EXT_clip_volume_hint */
       case GL_CLIP_VOLUME_CLIPPING_HINT_EXT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_target;
          if (ctx->Hint.ClipVolumeClipping == mode)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_HINT);
@@ -91,6 +103,8 @@ _mesa_Hint( GLenum target, GLenum mode )
 
       /* GL_ARB_texture_compression */
       case GL_TEXTURE_COMPRESSION_HINT_ARB:
+         if (ctx->API != API_OPENGL)
+            goto invalid_target;
 	 if (ctx->Hint.TextureCompression == mode)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_HINT);
@@ -107,10 +121,9 @@ _mesa_Hint( GLenum target, GLenum mode )
 
       /* GL_ARB_fragment_shader */
       case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB:
-         if (!ctx->Extensions.ARB_fragment_shader) {
-            _mesa_error(ctx, GL_INVALID_ENUM, "glHint(target)");
-            return;
-         }
+         if ((ctx->API != API_OPENGL && ctx->API != API_OPENGLES2)
+             || !ctx->Extensions.ARB_fragment_shader)
+            goto invalid_target;
          if (ctx->Hint.FragmentShaderDerivative == mode)
             return;
          FLUSH_VERTICES(ctx, _NEW_HINT);
@@ -118,13 +131,18 @@ _mesa_Hint( GLenum target, GLenum mode )
          break;
 
       default:
-         _mesa_error(ctx, GL_INVALID_ENUM, "glHint(target)");
-         return;
+         goto invalid_target;
    }
 
    if (ctx->Driver.Hint) {
       (*ctx->Driver.Hint)( ctx, target, mode );
    }
+
+   return;
+
+invalid_target:
+   _mesa_error(ctx, GL_INVALID_ENUM, "glHint(target)");
+   return;
 }
 
 
diff --git a/src/mesa/main/light.c b/src/mesa/main/light.c
index d6fbcd9..cfb53dc 100644
--- a/src/mesa/main/light.c
+++ b/src/mesa/main/light.c
@@ -466,6 +466,8 @@ _mesa_LightModelfv( GLenum pname, const GLfloat *params )
          COPY_4V( ctx->Light.Model.Ambient, params );
          break;
       case GL_LIGHT_MODEL_LOCAL_VIEWER:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          newbool = (params[0]!=0.0);
 	 if (ctx->Light.Model.LocalViewer == newbool)
 	    return;
@@ -484,6 +486,8 @@ _mesa_LightModelfv( GLenum pname, const GLfloat *params )
             ctx->_TriangleCaps &= ~DD_TRI_LIGHT_TWOSIDE;
          break;
       case GL_LIGHT_MODEL_COLOR_CONTROL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
          if (params[0] == (GLfloat) GL_SINGLE_COLOR)
 	    newenum = GL_SINGLE_COLOR;
          else if (params[0] == (GLfloat) GL_SEPARATE_SPECULAR_COLOR)
@@ -499,12 +503,17 @@ _mesa_LightModelfv( GLenum pname, const GLfloat *params )
 	 ctx->Light.Model.ColorControl = newenum;
          break;
       default:
-         _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel(pname=0x%x)", pname );
-         break;
+         goto invalid_pname;
    }
 
    if (ctx->Driver.LightModelfv)
       ctx->Driver.LightModelfv( ctx, pname, params );
+
+   return;
+
+invalid_pname:
+   _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel(pname=0x%x)", pname );
+   return;
 }
 
 
@@ -789,6 +798,10 @@ _mesa_GetMaterialfv( GLenum face, GLenum pname, GLfloat *params )
 	 *params = mat[MAT_ATTRIB_SHININESS(f)][0];
 	 break;
       case GL_COLOR_INDEXES:
+         if (ctx->API != API_OPENGL) {
+            _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
+            return;
+         }
 	 params[0] = mat[MAT_ATTRIB_INDEXES(f)][0];
 	 params[1] = mat[MAT_ATTRIB_INDEXES(f)][1];
 	 params[2] = mat[MAT_ATTRIB_INDEXES(f)][2];
@@ -807,6 +820,8 @@ _mesa_GetMaterialiv( GLenum face, GLenum pname, GLint *params )
    GLfloat (*mat)[4] = ctx->Light.Material.Attrib;
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx); /* update materials */
 
+   ASSERT(ctx->API == API_OPENGL);
+
    FLUSH_CURRENT(ctx, 0); /* update ctx->Light.Material from vertex buffer */
 
    if (face==GL_FRONT) {
diff --git a/src/mesa/main/matrix.c b/src/mesa/main/matrix.c
index b09fa4d..7157433 100644
--- a/src/mesa/main/matrix.c
+++ b/src/mesa/main/matrix.c
@@ -187,7 +187,7 @@ _mesa_MatrixMode( GLenum mode )
    case GL_MATRIX5_NV:
    case GL_MATRIX6_NV:
    case GL_MATRIX7_NV:
-      if (ctx->Extensions.NV_vertex_program) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.NV_vertex_program) {
          ctx->CurrentStack = &ctx->ProgramMatrixStack[mode - GL_MATRIX0_NV];
       }
       else {
@@ -203,8 +203,9 @@ _mesa_MatrixMode( GLenum mode )
    case GL_MATRIX5_ARB:
    case GL_MATRIX6_ARB:
    case GL_MATRIX7_ARB:
-      if (ctx->Extensions.ARB_vertex_program ||
-          ctx->Extensions.ARB_fragment_program) {
+      if (ctx->API == API_OPENGL
+          && (ctx->Extensions.ARB_vertex_program ||
+              ctx->Extensions.ARB_fragment_program)) {
          const GLuint m = mode - GL_MATRIX0_ARB;
          if (m > ctx->Const.MaxProgramMatrices) {
             _mesa_error(ctx, GL_INVALID_ENUM,
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 8fcb6b4..37dba80 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -2196,6 +2196,7 @@ struct gl_shader
    struct gl_sl_pragmas Pragmas;
 
    unsigned Version;       /**< GLSL version used for linking */
+   GLboolean IsEsShader; /**< True if this shader uses GLSL ES */
 
    /**
     * \name Sampler tracking
@@ -2398,6 +2399,7 @@ struct gl_shader_program
    GLchar *InfoLog;
 
    unsigned Version;       /**< GLSL version used for linking */
+   GLboolean IsEsProg; /**< True if this program uses GLSL ES */
 
    /**
     * Per-stage shaders resulting from the first stage of linking.
@@ -2940,6 +2942,7 @@ struct gl_extensions
    GLboolean dummy_true;  /* Set true by _mesa_init_extensions(). */
    GLboolean dummy_false; /* Set false by _mesa_init_extensions(). */
    GLboolean ARB_ES2_compatibility;
+   GLboolean ARB_ES3_compatibility;
    GLboolean ARB_base_instance;
    GLboolean ARB_blend_func_extended;
    GLboolean ARB_color_buffer_float;
diff --git a/src/mesa/main/pixelstore.c b/src/mesa/main/pixelstore.c
index 8147449..b3fab9c 100644
--- a/src/mesa/main/pixelstore.c
+++ b/src/mesa/main/pixelstore.c
@@ -45,18 +45,24 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 
    switch (pname) {
       case GL_PACK_SWAP_BYTES:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param == (GLint)ctx->Pack.SwapBytes)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
          ctx->Pack.SwapBytes = param ? GL_TRUE : GL_FALSE;
 	 break;
       case GL_PACK_LSB_FIRST:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param == (GLint)ctx->Pack.LsbFirst)
 	    return;
 	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
          ctx->Pack.LsbFirst = param ? GL_TRUE : GL_FALSE;
 	 break;
       case GL_PACK_ROW_LENGTH:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param<0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -67,6 +73,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Pack.RowLength = param;
 	 break;
       case GL_PACK_IMAGE_HEIGHT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (param<0) {
             _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -77,6 +85,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Pack.ImageHeight = param;
          break;
       case GL_PACK_SKIP_PIXELS:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param<0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -87,6 +97,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Pack.SkipPixels = param;
 	 break;
       case GL_PACK_SKIP_ROWS:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param<0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -97,6 +109,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Pack.SkipRows = param;
 	 break;
       case GL_PACK_SKIP_IMAGES:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param<0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -117,6 +131,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Pack.Alignment = param;
 	 break;
       case GL_PACK_INVERT_MESA:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (!ctx->Extensions.MESA_pack_invert) {
             _mesa_error( ctx, GL_INVALID_ENUM, "glPixelstore(pname)" );
             return;
@@ -128,6 +144,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
          break;
 
       case GL_UNPACK_SWAP_BYTES:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param == (GLint)ctx->Unpack.SwapBytes)
 	    return;
 	 if ((GLint)ctx->Unpack.SwapBytes == param)
@@ -136,6 +154,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Unpack.SwapBytes = param ? GL_TRUE : GL_FALSE;
          break;
       case GL_UNPACK_LSB_FIRST:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param == (GLint)ctx->Unpack.LsbFirst)
 	    return;
 	 if ((GLint)ctx->Unpack.LsbFirst == param)
@@ -144,6 +164,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Unpack.LsbFirst = param ? GL_TRUE : GL_FALSE;
 	 break;
       case GL_UNPACK_ROW_LENGTH:
+         if (ctx->API == API_OPENGLES)
+            goto invalid_enum_error;
 	 if (param<0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -154,6 +176,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Unpack.RowLength = param;
 	 break;
       case GL_UNPACK_IMAGE_HEIGHT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
          if (param<0) {
             _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -165,6 +189,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Unpack.ImageHeight = param;
          break;
       case GL_UNPACK_SKIP_PIXELS:
+         if (ctx->API == API_OPENGLES)
+            goto invalid_enum_error;
 	 if (param<0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -175,6 +201,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Unpack.SkipPixels = param;
 	 break;
       case GL_UNPACK_SKIP_ROWS:
+         if (ctx->API == API_OPENGLES)
+            goto invalid_enum_error;
 	 if (param<0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -185,6 +213,8 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Unpack.SkipRows = param;
 	 break;
       case GL_UNPACK_SKIP_IMAGES:
+         if (ctx->API != API_OPENGL)
+            goto invalid_enum_error;
 	 if (param < 0) {
 	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
 	    return;
@@ -205,9 +235,14 @@ _mesa_PixelStorei( GLenum pname, GLint param )
 	 ctx->Unpack.Alignment = param;
 	 break;
       default:
-	 _mesa_error( ctx, GL_INVALID_ENUM, "glPixelStore" );
-	 return;
+         goto invalid_enum_error;
    }
+
+   return;
+
+invalid_enum_error:
+   _mesa_error( ctx, GL_INVALID_ENUM, "glPixelStore" );
+   return;
 }
 
 
diff --git a/src/mesa/main/points.c b/src/mesa/main/points.c
index 87bfae2..dec3f27 100644
--- a/src/mesa/main/points.c
+++ b/src/mesa/main/points.c
@@ -104,88 +104,74 @@ _mesa_PointParameterfv( GLenum pname, const GLfloat *params)
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
 
+   /* Drivers that support point sprites must also support point parameters.
+    * If point parameters aren't supported, then this function shouldn't even
+    * exist.
+    */
+   ASSERT(!(ctx->Extensions.ARB_point_sprite
+            || ctx->Extensions.NV_point_sprite)
+          || ctx->Extensions.EXT_point_parameters);
+
+   if (!ctx->Extensions.EXT_point_parameters) {
+      _mesa_error(ctx, GL_INVALID_OPERATION,
+                  "unsupported function called (unsupported extension)");
+      return;
+   }
+
    switch (pname) {
       case GL_DISTANCE_ATTENUATION_EXT:
-         if (ctx->Extensions.EXT_point_parameters) {
-            if (TEST_EQ_3V(ctx->Point.Params, params))
-	       return;
-	    FLUSH_VERTICES(ctx, _NEW_POINT);
-            COPY_3V(ctx->Point.Params, params);
-            ctx->Point._Attenuated = (ctx->Point.Params[0] != 1.0 ||
-                                      ctx->Point.Params[1] != 0.0 ||
-                                      ctx->Point.Params[2] != 0.0);
-
-            if (ctx->Point._Attenuated)
-               ctx->_TriangleCaps |= DD_POINT_ATTEN;
-            else
-               ctx->_TriangleCaps &= ~DD_POINT_ATTEN;
-         }
-         else {
-            _mesa_error(ctx, GL_INVALID_ENUM,
-                        "glPointParameterf[v]{EXT,ARB}(pname)");
+         if (TEST_EQ_3V(ctx->Point.Params, params))
             return;
-         }
+         FLUSH_VERTICES(ctx, _NEW_POINT);
+         COPY_3V(ctx->Point.Params, params);
+         ctx->Point._Attenuated = (ctx->Point.Params[0] != 1.0 ||
+                                   ctx->Point.Params[1] != 0.0 ||
+                                   ctx->Point.Params[2] != 0.0);
+
+         if (ctx->Point._Attenuated)
+            ctx->_TriangleCaps |= DD_POINT_ATTEN;
+         else
+            ctx->_TriangleCaps &= ~DD_POINT_ATTEN;
          break;
       case GL_POINT_SIZE_MIN_EXT:
-         if (ctx->Extensions.EXT_point_parameters) {
-            if (params[0] < 0.0F) {
-               _mesa_error( ctx, GL_INVALID_VALUE,
-                            "glPointParameterf[v]{EXT,ARB}(param)" );
-               return;
-            }
-            if (ctx->Point.MinSize == params[0])
-               return;
-            FLUSH_VERTICES(ctx, _NEW_POINT);
-            ctx->Point.MinSize = params[0];
-         }
-         else {
-            _mesa_error(ctx, GL_INVALID_ENUM,
-                        "glPointParameterf[v]{EXT,ARB}(pname)");
+         if (params[0] < 0.0F) {
+            _mesa_error( ctx, GL_INVALID_VALUE,
+                         "glPointParameterf[v]{EXT,ARB}(param)" );
             return;
          }
+         if (ctx->Point.MinSize == params[0])
+            return;
+         FLUSH_VERTICES(ctx, _NEW_POINT);
+         ctx->Point.MinSize = params[0];
          break;
       case GL_POINT_SIZE_MAX_EXT:
-         if (ctx->Extensions.EXT_point_parameters) {
-            if (params[0] < 0.0F) {
-               _mesa_error( ctx, GL_INVALID_VALUE,
-                            "glPointParameterf[v]{EXT,ARB}(param)" );
-               return;
-            }
-            if (ctx->Point.MaxSize == params[0])
-               return;
-            FLUSH_VERTICES(ctx, _NEW_POINT);
-            ctx->Point.MaxSize = params[0];
-         }
-         else {
-            _mesa_error(ctx, GL_INVALID_ENUM,
-                        "glPointParameterf[v]{EXT,ARB}(pname)");
+         if (params[0] < 0.0F) {
+            _mesa_error( ctx, GL_INVALID_VALUE,
+                         "glPointParameterf[v]{EXT,ARB}(param)" );
             return;
          }
+         if (ctx->Point.MaxSize == params[0])
+            return;
+         FLUSH_VERTICES(ctx, _NEW_POINT);
+         ctx->Point.MaxSize = params[0];
          break;
       case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
-         if (ctx->Extensions.EXT_point_parameters) {
-            if (params[0] < 0.0F) {
-               _mesa_error( ctx, GL_INVALID_VALUE,
-                            "glPointParameterf[v]{EXT,ARB}(param)" );
-               return;
-            }
-            if (ctx->Point.Threshold == params[0])
-               return;
-            FLUSH_VERTICES(ctx, _NEW_POINT);
-            ctx->Point.Threshold = params[0];
-         }
-         else {
-            _mesa_error(ctx, GL_INVALID_ENUM,
-                        "glPointParameterf[v]{EXT,ARB}(pname)");
+         if (params[0] < 0.0F) {
+            _mesa_error( ctx, GL_INVALID_VALUE,
+                         "glPointParameterf[v]{EXT,ARB}(param)" );
             return;
          }
+         if (ctx->Point.Threshold == params[0])
+            return;
+         FLUSH_VERTICES(ctx, _NEW_POINT);
+         ctx->Point.Threshold = params[0];
          break;
       case GL_POINT_SPRITE_R_MODE_NV:
          /* This is one area where ARB_point_sprite and NV_point_sprite
 	  * differ.  In ARB_point_sprite the POINT_SPRITE_R_MODE is
 	  * always ZERO.  NV_point_sprite adds the S and R modes.
 	  */
-         if (ctx->Extensions.NV_point_sprite) {
+         if (ctx->API == API_OPENGL && ctx->Extensions.NV_point_sprite) {
             GLenum value = (GLenum) params[0];
             if (value != GL_ZERO && value != GL_S && value != GL_R) {
                _mesa_error(ctx, GL_INVALID_VALUE,
@@ -204,12 +190,11 @@ _mesa_PointParameterfv( GLenum pname, const GLfloat *params)
          }
          break;
       case GL_POINT_SPRITE_COORD_ORIGIN:
-	 /* This is not completely correct.  GL_POINT_SPRITE_COORD_ORIGIN was
-	  * added to point sprites when the extension was merged into OpenGL
-	  * 2.0.  It is expected that an implementation supporting OpenGL 1.4
-	  * and GL_ARB_point_sprite will generate an error here.
+	 /* GL_POINT_SPRITE_COORD_ORIGIN was added to point sprites when the
+	  * extension was merged into OpenGL 2.0.
 	  */
-         if (ctx->Extensions.ARB_point_sprite) {
+         if ((ctx->API == API_OPENGL && ctx->Version >= 20)
+             || ctx->API == API_OPENGL_CORE) {
             GLenum value = (GLenum) params[0];
             if (value != GL_LOWER_LEFT && value != GL_UPPER_LEFT) {
                _mesa_error(ctx, GL_INVALID_VALUE,
diff --git a/src/mesa/main/readpix.c b/src/mesa/main/readpix.c
index 7ac8774..f61a949 100644
--- a/src/mesa/main/readpix.c
+++ b/src/mesa/main/readpix.c
@@ -38,7 +38,13 @@
 #include "state.h"
 #include "glformats.h"
 #include "fbobject.h"
+#include "teximage.h"
 
+/* Inexplicably, GL_HALF_FLOAT_OES has a different value than GL_HALF_FLOAT.
+ */
+#ifndef GL_HALF_FLOAT_OES
+#define GL_HALF_FLOAT_OES 0x8D61
+#endif
 
 /**
  * Tries to implement glReadPixels() of GL_DEPTH_COMPONENT using memcpy of the
@@ -692,6 +698,33 @@ _mesa_ReadnPixelsARB( GLint x, GLint y, GLsizei width, GLsizei height,
       return;
    }
 
+   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
+    * combinations of format and type that can be used.
+    *
+    * Technically, only two combinations are actually allowed:
+    * GL_RGBA/GL_UNSIGNED_BYTE, and some implementation-specific internal
+    * preferred combination.  This code doesn't know what that preferred
+    * combination is, and Mesa can handle anything valid.  Just work instead.
+    */
+   if (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2) {
+      err = _mesa_es_error_check_format_and_type(format, type, 2);
+      if (err == GL_NO_ERROR) {
+         if (type == GL_FLOAT || type == GL_HALF_FLOAT_OES) {
+            err = GL_INVALID_OPERATION;
+         } else if (format == GL_DEPTH_COMPONENT
+                    || format == GL_DEPTH_STENCIL) {
+            err = GL_INVALID_ENUM;
+         }
+      }
+
+      if (err != GL_NO_ERROR) {
+         _mesa_error(ctx, err, "glReadPixels(invalid format %s and/or type %s)",
+                     _mesa_lookup_enum_by_nr(format),
+                     _mesa_lookup_enum_by_nr(type));
+         return;
+      }
+   }
+
    if (ctx->NewState)
       _mesa_update_state(ctx);
 
diff --git a/src/mesa/main/shaderapi.c b/src/mesa/main/shaderapi.c
index caeb965..307c681 100644
--- a/src/mesa/main/shaderapi.c
+++ b/src/mesa/main/shaderapi.c
@@ -177,7 +177,7 @@ validate_shader_target(const struct gl_context *ctx, GLenum type)
 #endif
 #if FEATURE_ARB_geometry_shader4
    case GL_GEOMETRY_SHADER_ARB:
-      return ctx->Extensions.ARB_geometry_shader4;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_geometry_shader4;
 #endif
    default:
       return false;
@@ -472,6 +472,7 @@ get_programiv(struct gl_context *ctx, GLuint program, GLenum pname, GLint *param
 {
    struct gl_shader_program *shProg
       = _mesa_lookup_shader_program(ctx, program);
+   const bool is_gles2 = ctx->API == API_OPENGLES2;
 
    if (!shProg) {
       _mesa_error(ctx, GL_INVALID_VALUE, "glGetProgramiv(program)");
@@ -481,28 +482,28 @@ get_programiv(struct gl_context *ctx, GLuint program, GLenum pname, GLint *param
    switch (pname) {
    case GL_DELETE_STATUS:
       *params = shProg->DeletePending;
-      break; 
+      return;
    case GL_LINK_STATUS:
       *params = shProg->LinkStatus;
-      break;
+      return;
    case GL_VALIDATE_STATUS:
       *params = shProg->Validated;
-      break;
+      return;
    case GL_INFO_LOG_LENGTH:
       *params = shProg->InfoLog ? strlen(shProg->InfoLog) + 1 : 0;
-      break;
+      return;
    case GL_ATTACHED_SHADERS:
       *params = shProg->NumShaders;
-      break;
+      return;
    case GL_ACTIVE_ATTRIBUTES:
       *params = _mesa_count_active_attribs(shProg);
-      break;
+      return;
    case GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
       *params = _mesa_longest_attribute_name_length(shProg);
-      break;
+      return;
    case GL_ACTIVE_UNIFORMS:
       *params = shProg->NumUserUniformStorage;
-      break;
+      return;
    case GL_ACTIVE_UNIFORM_MAX_LENGTH: {
       unsigned i;
       GLint max_len = 0;
@@ -517,32 +518,41 @@ get_programiv(struct gl_context *ctx, GLuint program, GLenum pname, GLint *param
       }
 
       *params = max_len;
-      break;
+      return;
    }
-   case GL_PROGRAM_BINARY_LENGTH_OES:
-      *params = 0;
-      break;
 #if FEATURE_EXT_transform_feedback
    case GL_TRANSFORM_FEEDBACK_VARYINGS:
+      if (is_gles2 || !ctx->Extensions.EXT_transform_feedback)
+         break;
       *params = shProg->TransformFeedback.NumVarying;
-      break;
+      return;
    case GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH:
+      if (is_gles2 || !ctx->Extensions.EXT_transform_feedback)
+         break;
       *params = longest_feedback_varying_name(shProg) + 1;
-      break;
+      return;
    case GL_TRANSFORM_FEEDBACK_BUFFER_MODE:
+      if (is_gles2 || !ctx->Extensions.EXT_transform_feedback)
+         break;
       *params = shProg->TransformFeedback.BufferMode;
-      break;
+      return;
 #endif
 #if FEATURE_ARB_geometry_shader4
    case GL_GEOMETRY_VERTICES_OUT_ARB:
+      if (is_gles2 || !ctx->Extensions.ARB_geometry_shader4)
+         break;
       *params = shProg->Geom.VerticesOut;
-      break;
+      return;
    case GL_GEOMETRY_INPUT_TYPE_ARB:
+      if (is_gles2 || !ctx->Extensions.ARB_geometry_shader4)
+         break;
       *params = shProg->Geom.InputType;
-      break;
+      return;
    case GL_GEOMETRY_OUTPUT_TYPE_ARB:
+      if (is_gles2 || !ctx->Extensions.ARB_geometry_shader4)
+         break;
       *params = shProg->Geom.OutputType;
-      break;
+      return;
 #endif
    case GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: {
       unsigned i;
@@ -574,9 +584,11 @@ get_programiv(struct gl_context *ctx, GLuint program, GLenum pname, GLint *param
       *params = shProg->NumUniformBlocks;
       break;
    default:
-      _mesa_error(ctx, GL_INVALID_ENUM, "glGetProgramiv(pname)");
-      return;
+      break;
    }
+
+   _mesa_error(ctx, GL_INVALID_ENUM, "glGetProgramiv(pname)");
+   return;
 }
 
 
diff --git a/src/mesa/main/texenv.c b/src/mesa/main/texenv.c
index e5f1bd3..f1064c5 100644
--- a/src/mesa/main/texenv.c
+++ b/src/mesa/main/texenv.c
@@ -122,7 +122,8 @@ set_combiner_mode(struct gl_context *ctx,
       break;
    case GL_DOT3_RGB_EXT:
    case GL_DOT3_RGBA_EXT:
-      legal = (ctx->Extensions.EXT_texture_env_dot3 &&
+      legal = (ctx->API == API_OPENGL &&
+               ctx->Extensions.EXT_texture_env_dot3 &&
                pname == GL_COMBINE_RGB);
       break;
    case GL_DOT3_RGB:
@@ -133,10 +134,12 @@ set_combiner_mode(struct gl_context *ctx,
    case GL_MODULATE_ADD_ATI:
    case GL_MODULATE_SIGNED_ADD_ATI:
    case GL_MODULATE_SUBTRACT_ATI:
-      legal = ctx->Extensions.ATI_texture_env_combine3;
+      legal = (ctx->API == API_OPENGL &&
+               ctx->Extensions.ATI_texture_env_combine3);
       break;
    case GL_BUMP_ENVMAP_ATI:
-      legal = (ctx->Extensions.ATI_envmap_bumpmap &&
+      legal = (ctx->API == API_OPENGL &&
+               ctx->Extensions.ATI_envmap_bumpmap &&
                pname == GL_COMBINE_RGB);
       break;
    default:
@@ -203,7 +206,8 @@ set_combiner_source(struct gl_context *ctx,
       return;
    }
 
-   if ((term == 3) && !ctx->Extensions.NV_texture_env_combine4) {
+   if ((term == 3) && (ctx->API != API_OPENGL
+                       || !ctx->Extensions.NV_texture_env_combine4)) {
       TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
       return;
    }
@@ -232,11 +236,13 @@ set_combiner_source(struct gl_context *ctx,
                param - GL_TEXTURE0 < ctx->Const.MaxTextureUnits);
       break;
    case GL_ZERO:
-      legal = (ctx->Extensions.ATI_texture_env_combine3 ||
-               ctx->Extensions.NV_texture_env_combine4);
+      legal = (ctx->API == API_OPENGL &&
+               (ctx->Extensions.ATI_texture_env_combine3 ||
+                ctx->Extensions.NV_texture_env_combine4));
       break;
    case GL_ONE:
-      legal = ctx->Extensions.ATI_texture_env_combine3;
+      legal = (ctx->API == API_OPENGL &&
+               ctx->Extensions.ATI_texture_env_combine3);
       break;
    default:
       legal = GL_FALSE;
@@ -287,7 +293,8 @@ set_combiner_operand(struct gl_context *ctx,
       return;
    }
 
-   if ((term == 3) && !ctx->Extensions.NV_texture_env_combine4) {
+   if ((term == 3) && (ctx->API != API_OPENGL
+                       || !ctx->Extensions.NV_texture_env_combine4)) {
       TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
       return;
    }
@@ -301,8 +308,8 @@ set_combiner_operand(struct gl_context *ctx,
    case GL_SRC_COLOR:
    case GL_ONE_MINUS_SRC_COLOR:
       /* The color input can only be used with GL_OPERAND[01]_RGB in the EXT
-       * version.  In the ARB and NV versions they can be used for any RGB
-       * operand.
+       * version.  In the ARB and NV versions and OpenGL ES 1.x they can be
+       * used for any RGB operand.
        */
       legal = !alpha
 	 && ((term < 2) || ctx->Extensions.ARB_texture_env_combine
@@ -311,7 +318,7 @@ set_combiner_operand(struct gl_context *ctx,
    case GL_ONE_MINUS_SRC_ALPHA:
       /* GL_ONE_MINUS_SRC_ALPHA can only be used with
        * GL_OPERAND[01]_(RGB|ALPHA) in the EXT version.  In the ARB and NV
-       * versions it can be used for any operand.
+       * versions and OpenGL ES 1.x it can be used for any operand.
        */
       legal = (term < 2) || ctx->Extensions.ARB_texture_env_combine
 	 || ctx->Extensions.NV_texture_env_combine4;
@@ -435,7 +442,7 @@ _mesa_TexEnvfv( GLenum target, GLenum pname, const GLfloat *param )
          set_combiner_scale(ctx, texUnit, pname, param[0]);
 	 break;
       case GL_BUMP_TARGET_ATI:
-         if (!ctx->Extensions.ATI_envmap_bumpmap) {
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ATI_envmap_bumpmap) {
 	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
 	    return;
 	 }
@@ -581,7 +588,7 @@ get_texenvi(struct gl_context *ctx, const struct gl_texture_unit *texUnit,
       return texUnit->Combine.SourceRGB[rgb_idx];
    }
    case GL_SOURCE3_RGB_NV:
-      if (ctx->Extensions.NV_texture_env_combine4) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.NV_texture_env_combine4) {
          return texUnit->Combine.SourceRGB[3];
       }
       else {
@@ -595,7 +602,7 @@ get_texenvi(struct gl_context *ctx, const struct gl_texture_unit *texUnit,
       return texUnit->Combine.SourceA[alpha_idx];
    }
    case GL_SOURCE3_ALPHA_NV:
-      if (ctx->Extensions.NV_texture_env_combine4) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.NV_texture_env_combine4) {
          return texUnit->Combine.SourceA[3];
       }
       else {
@@ -609,7 +616,7 @@ get_texenvi(struct gl_context *ctx, const struct gl_texture_unit *texUnit,
       return texUnit->Combine.OperandRGB[op_rgb];
    }
    case GL_OPERAND3_RGB_NV:
-      if (ctx->Extensions.NV_texture_env_combine4) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.NV_texture_env_combine4) {
          return texUnit->Combine.OperandRGB[3];
       }
       else {
@@ -623,7 +630,7 @@ get_texenvi(struct gl_context *ctx, const struct gl_texture_unit *texUnit,
       return texUnit->Combine.OperandA[op_alpha];
    }
    case GL_OPERAND3_ALPHA_NV:
-      if (ctx->Extensions.NV_texture_env_combine4) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.NV_texture_env_combine4) {
          return texUnit->Combine.OperandA[3];
       }
       else {
@@ -636,7 +643,7 @@ get_texenvi(struct gl_context *ctx, const struct gl_texture_unit *texUnit,
       return 1 << texUnit->Combine.ScaleShiftA;
    case GL_BUMP_TARGET_ATI:
       /* spec doesn't say so, but I think this should be queryable */
-      if (ctx->Extensions.ATI_envmap_bumpmap) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ATI_envmap_bumpmap) {
          return texUnit->BumpTarget;
       }
       else {
diff --git a/src/mesa/main/texgen.c b/src/mesa/main/texgen.c
index 0ace0b9..3788669 100644
--- a/src/mesa/main/texgen.c
+++ b/src/mesa/main/texgen.c
@@ -48,8 +48,14 @@
  * Return texgen state for given coordinate
  */
 static struct gl_texgen *
-get_texgen(struct gl_texture_unit *texUnit, GLenum coord)
+get_texgen(struct gl_context *ctx, struct gl_texture_unit *texUnit,
+           GLenum coord)
 {
+   if (ctx->API == API_OPENGLES) {
+      return (coord == GL_TEXTURE_GEN_STR_OES)
+         ? &texUnit->GenS : NULL;
+   }
+
    switch (coord) {
    case GL_S:
       return &texUnit->GenS;
@@ -87,7 +93,7 @@ _mesa_TexGenfv( GLenum coord, GLenum pname, const GLfloat *params )
 
    texUnit = _mesa_get_current_tex_unit(ctx);
 
-   texgen = get_texgen(texUnit, coord);
+   texgen = get_texgen(ctx, texUnit, coord);
    if (!texgen) {
       _mesa_error(ctx, GL_INVALID_ENUM, "glTexGen(coord)");
       return;
@@ -126,6 +132,12 @@ _mesa_TexGenfv( GLenum coord, GLenum pname, const GLfloat *params )
             _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
             return;
          }
+         if (ctx->API != API_OPENGL
+             && (bit & (TEXGEN_REFLECTION_MAP_NV | TEXGEN_NORMAL_MAP_NV)) == 0) {
+            _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
+            return;
+         }
+
          FLUSH_VERTICES(ctx, _NEW_TEXTURE);
          texgen->Mode = mode;
          texgen->_ModeBit = bit;
@@ -134,6 +146,10 @@ _mesa_TexGenfv( GLenum coord, GLenum pname, const GLfloat *params )
 
    case GL_OBJECT_PLANE:
       {
+         if (ctx->API != API_OPENGL) {
+            _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
+            return;
+         }
          if (TEST_EQ_4V(texgen->ObjectPlane, params))
             return;
          FLUSH_VERTICES(ctx, _NEW_TEXTURE);
@@ -144,6 +160,12 @@ _mesa_TexGenfv( GLenum coord, GLenum pname, const GLfloat *params )
    case GL_EYE_PLANE:
       {
          GLfloat tmp[4];
+
+         if (ctx->API != API_OPENGL) {
+            _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
+            return;
+         }
+
          /* Transform plane equation by the inverse modelview matrix */
          if (_math_matrix_is_dirty(ctx->ModelviewMatrixStack.Top)) {
             _math_matrix_analyse(ctx->ModelviewMatrixStack.Top);
@@ -198,7 +220,6 @@ _mesa_TexGend(GLenum coord, GLenum pname, GLdouble param )
 void GLAPIENTRY
 _es_GetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
 {
-   ASSERT(coord == GL_TEXTURE_GEN_STR_OES);
    _mesa_GetTexGenfv(GL_S, pname, params);
 }
 
@@ -206,7 +227,11 @@ _es_GetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
 void GLAPIENTRY
 _es_TexGenf(GLenum coord, GLenum pname, GLfloat param)
 {
-   ASSERT(coord == GL_TEXTURE_GEN_STR_OES);
+   if (coord != GL_TEXTURE_GEN_STR_OES) {
+      GET_CURRENT_CONTEXT(ctx);
+      _mesa_error( ctx, GL_INVALID_ENUM, "glTexGen[fx](pname)" );
+      return;
+   }
    /* set S, T, and R at the same time */
    _mesa_TexGenf(GL_S, pname, param);
    _mesa_TexGenf(GL_T, pname, param);
@@ -217,7 +242,11 @@ _es_TexGenf(GLenum coord, GLenum pname, GLfloat param)
 void GLAPIENTRY
 _es_TexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
 {
-   ASSERT(coord == GL_TEXTURE_GEN_STR_OES);
+   if (coord != GL_TEXTURE_GEN_STR_OES) {
+      GET_CURRENT_CONTEXT(ctx);
+      _mesa_error( ctx, GL_INVALID_ENUM, "glTexGen[fx]v(pname)" );
+      return;
+   }
    /* set S, T, and R at the same time */
    _mesa_TexGenfv(GL_S, pname, params);
    _mesa_TexGenfv(GL_T, pname, params);
@@ -279,7 +308,7 @@ _mesa_GetTexGendv( GLenum coord, GLenum pname, GLdouble *params )
 
    texUnit = _mesa_get_current_tex_unit(ctx);
 
-   texgen = get_texgen(texUnit, coord);
+   texgen = get_texgen(ctx, texUnit, coord);
    if (!texgen) {
       _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexGendv(coord)");
       return;
@@ -317,7 +346,7 @@ _mesa_GetTexGenfv( GLenum coord, GLenum pname, GLfloat *params )
 
    texUnit = _mesa_get_current_tex_unit(ctx);
 
-   texgen = get_texgen(texUnit, coord);
+   texgen = get_texgen(ctx, texUnit, coord);
    if (!texgen) {
       _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexGenfv(coord)");
       return;
@@ -328,9 +357,17 @@ _mesa_GetTexGenfv( GLenum coord, GLenum pname, GLfloat *params )
       params[0] = ENUM_TO_FLOAT(texgen->Mode);
       break;
    case GL_OBJECT_PLANE:
+      if (ctx->API != API_OPENGL) {
+         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(param)" );
+         return;
+      }
       COPY_4V(params, texgen->ObjectPlane);
       break;
    case GL_EYE_PLANE:
+      if (ctx->API != API_OPENGL) {
+         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(param)" );
+         return;
+      }
       COPY_4V(params, texgen->EyePlane);
       break;
    default:
@@ -340,7 +377,7 @@ _mesa_GetTexGenfv( GLenum coord, GLenum pname, GLfloat *params )
 
 
 
-static void GLAPIENTRY
+void GLAPIENTRY
 _mesa_GetTexGeniv( GLenum coord, GLenum pname, GLint *params )
 {
    struct gl_texture_unit *texUnit;
@@ -355,7 +392,7 @@ _mesa_GetTexGeniv( GLenum coord, GLenum pname, GLint *params )
 
    texUnit = _mesa_get_current_tex_unit(ctx);
 
-   texgen = get_texgen(texUnit, coord);
+   texgen = get_texgen(ctx, texUnit, coord);
    if (!texgen) {
       _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexGeniv(coord)");
       return;
@@ -366,12 +403,20 @@ _mesa_GetTexGeniv( GLenum coord, GLenum pname, GLint *params )
       params[0] = texgen->Mode;
       break;
    case GL_OBJECT_PLANE:
+      if (ctx->API != API_OPENGL) {
+         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(param)" );
+         return;
+      }
       params[0] = (GLint) texgen->ObjectPlane[0];
       params[1] = (GLint) texgen->ObjectPlane[1];
       params[2] = (GLint) texgen->ObjectPlane[2];
       params[3] = (GLint) texgen->ObjectPlane[3];
       break;
    case GL_EYE_PLANE:
+      if (ctx->API != API_OPENGL) {
+         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(param)" );
+         return;
+      }
       params[0] = (GLint) texgen->EyePlane[0];
       params[1] = (GLint) texgen->EyePlane[1];
       params[2] = (GLint) texgen->EyePlane[2];
diff --git a/src/mesa/main/texgen.h b/src/mesa/main/texgen.h
index 60a9522..1d13422 100644
--- a/src/mesa/main/texgen.h
+++ b/src/mesa/main/texgen.h
@@ -48,6 +48,9 @@ _mesa_TexGeni( GLenum coord, GLenum pname, GLint param );
 extern void GLAPIENTRY
 _mesa_GetTexGenfv( GLenum coord, GLenum pname, GLfloat *params );
 
+extern void GLAPIENTRY
+_mesa_GetTexGeniv( GLenum coord, GLenum pname, GLint *params );
+
 extern void
 _mesa_init_texgen_dispatch(struct _glapi_table *disp);
 
diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index 569adc1..589cbe5 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -28,7 +28,7 @@
  * Texture image-related functions.
  */
 
-
+#include <stdbool.h>
 #include "glheader.h"
 #include "bufferobj.h"
 #include "context.h"
@@ -50,6 +50,12 @@
 #include "glformats.h"
 
 
+/* Inexplicably, GL_HALF_FLOAT_OES has a different value than GL_HALF_FLOAT.
+ */
+#ifndef GL_HALF_FLOAT_OES
+#define GL_HALF_FLOAT_OES 0x8D61
+#endif
+
 /**
  * State changes which we care about for glCopyTex[Sub]Image() calls.
  * In particular, we care about pixel transfer state and buffer state
@@ -1397,6 +1403,16 @@ compressedteximage_only_format(const struct gl_context *ctx, GLenum format)
 {
    switch (format) {
    case GL_ETC1_RGB8_OES:
+   case GL_PALETTE4_RGB8_OES:
+   case GL_PALETTE4_RGBA8_OES:
+   case GL_PALETTE4_R5_G6_B5_OES:
+   case GL_PALETTE4_RGBA4_OES:
+   case GL_PALETTE4_RGB5_A1_OES:
+   case GL_PALETTE8_RGB8_OES:
+   case GL_PALETTE8_RGBA8_OES:
+   case GL_PALETTE8_R5_G6_B5_OES:
+   case GL_PALETTE8_RGBA4_OES:
+   case GL_PALETTE8_RGB5_A1_OES:
       return GL_TRUE;
    default:
       return GL_FALSE;
@@ -1448,16 +1464,18 @@ legal_teximage_target(struct gl_context *ctx, GLuint dims, GLenum target)
       switch (target) {
       case GL_TEXTURE_1D:
       case GL_PROXY_TEXTURE_1D:
-         return GL_TRUE;
+         return ctx->API == API_OPENGL;
       default:
          return GL_FALSE;
       }
    case 2:
       switch (target) {
       case GL_TEXTURE_2D:
-      case GL_PROXY_TEXTURE_2D:
          return GL_TRUE;
+      case GL_PROXY_TEXTURE_2D:
+         return ctx->API == API_OPENGL;
       case GL_PROXY_TEXTURE_CUBE_MAP:
+         return ctx->API == API_OPENGL && ctx->Extensions.ARB_texture_cube_map;
       case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
       case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
       case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
@@ -1467,23 +1485,26 @@ legal_teximage_target(struct gl_context *ctx, GLuint dims, GLenum target)
          return ctx->Extensions.ARB_texture_cube_map;
       case GL_TEXTURE_RECTANGLE_NV:
       case GL_PROXY_TEXTURE_RECTANGLE_NV:
-         return ctx->Extensions.NV_texture_rectangle;
+         return ctx->API == API_OPENGL && ctx->Extensions.NV_texture_rectangle;
       case GL_TEXTURE_1D_ARRAY_EXT:
       case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
-         return (ctx->Extensions.MESA_texture_array ||
-                 ctx->Extensions.EXT_texture_array);
+         return ctx->API == API_OPENGL
+            && (ctx->Extensions.MESA_texture_array ||
+                ctx->Extensions.EXT_texture_array);
       default:
          return GL_FALSE;
       }
    case 3:
       switch (target) {
       case GL_TEXTURE_3D:
-      case GL_PROXY_TEXTURE_3D:
          return GL_TRUE;
+      case GL_PROXY_TEXTURE_3D:
+         return ctx->API == API_OPENGL;
       case GL_TEXTURE_2D_ARRAY_EXT:
       case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
-         return (ctx->Extensions.MESA_texture_array ||
-                 ctx->Extensions.EXT_texture_array);
+         return ctx->API == API_OPENGL
+            && (ctx->Extensions.MESA_texture_array ||
+                ctx->Extensions.EXT_texture_array);
       default:
          return GL_FALSE;
       }
@@ -1505,7 +1526,7 @@ legal_texsubimage_target(struct gl_context *ctx, GLuint dims, GLenum target)
 {
    switch (dims) {
    case 1:
-      return target == GL_TEXTURE_1D;
+      return ctx->API == API_OPENGL && target == GL_TEXTURE_1D;
    case 2:
       switch (target) {
       case GL_TEXTURE_2D:
@@ -1518,10 +1539,11 @@ legal_texsubimage_target(struct gl_context *ctx, GLuint dims, GLenum target)
       case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
          return ctx->Extensions.ARB_texture_cube_map;
       case GL_TEXTURE_RECTANGLE_NV:
-         return ctx->Extensions.NV_texture_rectangle;
+         return ctx->API == API_OPENGL && ctx->Extensions.NV_texture_rectangle;
       case GL_TEXTURE_1D_ARRAY_EXT:
-         return (ctx->Extensions.MESA_texture_array ||
-                 ctx->Extensions.EXT_texture_array);
+         return ctx->API == API_OPENGL
+            && (ctx->Extensions.MESA_texture_array ||
+                ctx->Extensions.EXT_texture_array);
       default:
          return GL_FALSE;
       }
@@ -1530,8 +1552,9 @@ legal_texsubimage_target(struct gl_context *ctx, GLuint dims, GLenum target)
       case GL_TEXTURE_3D:
          return GL_TRUE;
       case GL_TEXTURE_2D_ARRAY_EXT:
-         return (ctx->Extensions.MESA_texture_array ||
-                 ctx->Extensions.EXT_texture_array);
+         return ctx->API == API_OPENGL
+            && (ctx->Extensions.MESA_texture_array ||
+                ctx->Extensions.EXT_texture_array);
       default:
          return GL_FALSE;
       }
@@ -1559,6 +1582,78 @@ mutable_tex_object(struct gl_context *ctx, GLenum target)
 }
 
 
+GLenum
+_mesa_es_error_check_format_and_type(GLenum format, GLenum type,
+                                     unsigned dimensions)
+{
+   bool type_valid = true;
+
+   switch (format) {
+   case GL_ALPHA:
+      type_valid = (type == GL_UNSIGNED_BYTE
+                    || type == GL_FLOAT
+                    || type == GL_HALF_FLOAT_OES);
+      break;
+
+   case GL_RGB:
+      type_valid = (type == GL_UNSIGNED_BYTE
+                    || type == GL_UNSIGNED_SHORT_5_6_5
+                    || type == GL_FLOAT
+                    || type == GL_HALF_FLOAT_OES);
+      break;
+
+   case GL_RGBA:
+      type_valid = (type == GL_UNSIGNED_BYTE
+                    || type == GL_UNSIGNED_SHORT_4_4_4_4
+                    || type == GL_UNSIGNED_SHORT_5_5_5_1
+                    || type == GL_FLOAT
+                    || type == GL_HALF_FLOAT_OES
+                    || type == GL_UNSIGNED_INT_2_10_10_10_REV);
+      break;
+
+   case GL_LUMINANCE:
+      type_valid = (type == GL_UNSIGNED_BYTE
+                    || type == GL_FLOAT
+                    || type == GL_HALF_FLOAT_OES);
+      break;
+
+   case GL_LUMINANCE_ALPHA:
+      type_valid = (type == GL_UNSIGNED_BYTE
+                    || type == GL_FLOAT
+                    || type == GL_HALF_FLOAT_OES);
+      break;
+
+   case GL_DEPTH_COMPONENT:
+      /* This format is filtered against invalid dimensionalities elsewhere.
+       */
+      type_valid = (type == GL_UNSIGNED_SHORT
+                    || type == GL_UNSIGNED_INT);
+      break;
+
+   case GL_DEPTH_STENCIL:
+      /* This format is filtered against invalid dimensionalities elsewhere.
+       */
+      type_valid = (type == GL_UNSIGNED_INT_24_8);
+      break;
+
+   case GL_BGRA_EXT:
+      type_valid = (type == GL_UNSIGNED_BYTE);
+
+      /* This feels like a bug in the EXT_texture_format_BGRA8888 spec, but
+       * the format does not appear to be allowed for 3D textures in OpenGL
+       * ES.
+       */
+      if (dimensions != 2)
+         return GL_INVALID_VALUE;
+
+      break;
+
+   default:
+      return GL_INVALID_VALUE;
+   }
+
+   return type_valid ? GL_NO_ERROR : GL_INVALID_OPERATION;
+}
 
 /**
  * Test the glTexImage[123]D() parameters for errors.
@@ -1612,7 +1707,8 @@ texture_error_check( struct gl_context *ctx,
 
    /* Check border */
    if (border < 0 || border > 1 ||
-       ((target == GL_TEXTURE_RECTANGLE_NV ||
+       ((ctx->API != API_OPENGL ||
+         target == GL_TEXTURE_RECTANGLE_NV ||
          target == GL_PROXY_TEXTURE_RECTANGLE_NV) && border != 0)) {
       if (!isProxy) {
          _mesa_error(ctx, GL_INVALID_VALUE,
@@ -1629,6 +1725,33 @@ texture_error_check( struct gl_context *ctx,
       return GL_TRUE;
    }
 
+   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
+    * combinations of format, internalFormat, and type that can be used.
+    * Formats and types that require additional extensions (e.g., GL_FLOAT
+    * requires GL_OES_texture_float) are filtered elsewhere.
+    */
+   if (ctx->API == API_OPENGLES
+       || (ctx->API == API_OPENGLES2 && ctx->Version < 30)) {
+      if (format != internalFormat) {
+         _mesa_error(ctx, GL_INVALID_OPERATION,
+                     "glTexImage%dD(format = %s, internalFormat = %s)",
+                     dimensions,
+                     _mesa_lookup_enum_by_nr(format),
+                     _mesa_lookup_enum_by_nr(internalFormat));
+         return GL_TRUE;
+      }
+
+      err = _mesa_es_error_check_format_and_type(format, type, dimensions);
+      if (err != GL_NO_ERROR) {
+         _mesa_error(ctx, err,
+                     "glTexImage%dD(format = %s, type = %s)",
+                     dimensions,
+                     _mesa_lookup_enum_by_nr(format),
+                     _mesa_lookup_enum_by_nr(type));
+         return GL_TRUE;
+      }
+   }
+
    /* Do this simple check before calling the TestProxyTexImage() function */
    if (proxyTarget == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
       sizeOK = (width == height);
@@ -1840,6 +1963,23 @@ subtexture_error_check( struct gl_context *ctx, GLuint dimensions,
       return GL_TRUE;
    }
 
+   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
+    * combinations of format and type that can be used.  Formats and types
+    * that require additional extensions (e.g., GL_FLOAT requires
+    * GL_OES_texture_float) are filtered elsewhere.
+    */
+   if (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2) {
+      err = _mesa_es_error_check_format_and_type(format, type, dimensions);
+      if (err != GL_NO_ERROR) {
+         _mesa_error(ctx, err,
+                     "glTexSubImage%dD(format = %s, type = %s)",
+                     dimensions,
+                     _mesa_lookup_enum_by_nr(format),
+                     _mesa_lookup_enum_by_nr(type));
+         return GL_TRUE;
+      }
+   }
+
    err = _mesa_error_check_format_and_type(ctx, format, type);
    if (err != GL_NO_ERROR) {
       _mesa_error(ctx, err,
@@ -2015,11 +2155,32 @@ copytexture_error_check( struct gl_context *ctx, GLuint dimensions,
 
    /* Check border */
    if (border < 0 || border > 1 ||
-       ((target == GL_TEXTURE_RECTANGLE_NV ||
+       ((ctx->API != API_OPENGL ||
+         target == GL_TEXTURE_RECTANGLE_NV ||
          target == GL_PROXY_TEXTURE_RECTANGLE_NV) && border != 0)) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glCopyTexImage%dD(border=%d)", dimensions, border);
       return GL_TRUE;
    }
 
+   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
+    * internalFormat.
+    */
+   if (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2) {
+      switch (internalFormat) {
+      case GL_ALPHA:
+      case GL_RGB:
+      case GL_RGBA:
+      case GL_LUMINANCE:
+      case GL_LUMINANCE_ALPHA:
+         break;
+      default:
+         _mesa_error(ctx, GL_INVALID_VALUE,
+                     "glCopyTexImage%dD(internalFormat)", dimensions);
+         return GL_TRUE;
+      }
+   }
+
    baseFormat = _mesa_base_tex_format(ctx, internalFormat);
    if (baseFormat < 0) {
       _mesa_error(ctx, GL_INVALID_VALUE,
@@ -2694,13 +2855,23 @@ _mesa_EGLImageTargetTexture2DOES (GLenum target, GLeglImageOES image)
 {
    struct gl_texture_object *texObj;
    struct gl_texture_image *texImage;
+   bool valid_target;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if ((target == GL_TEXTURE_2D &&
-        !ctx->Extensions.OES_EGL_image) ||
-       (target == GL_TEXTURE_EXTERNAL_OES &&
-        !ctx->Extensions.OES_EGL_image_external)) {
+   switch (target) {
+   case GL_TEXTURE_2D:
+      valid_target = ctx->Extensions.OES_EGL_image;
+      break;
+   case GL_TEXTURE_EXTERNAL_OES:
+      valid_target = ctx->Extensions.OES_EGL_image_external;
+      break;
+   default:
+      valid_target = false;
+      break;
+   }
+
+   if (!valid_target) {
       _mesa_error(ctx, GL_INVALID_ENUM,
 		  "glEGLImageTargetTexture2D(target=%d)", target);
       return;
diff --git a/src/mesa/main/teximage.h b/src/mesa/main/teximage.h
index 66a0c88..739c5dd 100644
--- a/src/mesa/main/teximage.h
+++ b/src/mesa/main/teximage.h
@@ -140,6 +140,10 @@ _mesa_tex_target_to_face(GLenum target);
 extern GLint
 _mesa_get_texture_dimensions(GLenum target);
 
+extern GLenum
+_mesa_es_error_check_format_and_type(GLenum format, GLenum type,
+                                     unsigned dimensions);
+
 /**
  * Lock a texture for updating.  See also _mesa_lock_context_textures().
  */
diff --git a/src/mesa/main/texobj.c b/src/mesa/main/texobj.c
index f70da4f..58e6980 100644
--- a/src/mesa/main/texobj.c
+++ b/src/mesa/main/texobj.c
@@ -1069,27 +1069,39 @@ _mesa_DeleteTextures( GLsizei n, const GLuint *textures)
  * \return TEXTURE_x_INDEX or -1 if target is invalid
  */
 static GLint
-target_enum_to_index(GLenum target)
+target_enum_to_index(struct gl_context *ctx, GLenum target)
 {
    switch (target) {
    case GL_TEXTURE_1D:
-      return TEXTURE_1D_INDEX;
+      return ctx->API == API_OPENGL
+         ? TEXTURE_1D_INDEX : -1;
    case GL_TEXTURE_2D:
       return TEXTURE_2D_INDEX;
    case GL_TEXTURE_3D:
       return TEXTURE_3D_INDEX;
    case GL_TEXTURE_CUBE_MAP_ARB:
-      return TEXTURE_CUBE_INDEX;
+      return ctx->Extensions.ARB_texture_cube_map
+         ? TEXTURE_CUBE_INDEX : -1;
    case GL_TEXTURE_RECTANGLE_NV:
-      return TEXTURE_RECT_INDEX;
+      return ctx->API == API_OPENGL && ctx->Extensions.NV_texture_rectangle
+         ? TEXTURE_RECT_INDEX : -1;
    case GL_TEXTURE_1D_ARRAY_EXT:
-      return TEXTURE_1D_ARRAY_INDEX;
+      return ctx->API == API_OPENGL
+         && (ctx->Extensions.EXT_texture_array
+             || ctx->Extensions.MESA_texture_array)
+         ? TEXTURE_1D_ARRAY_INDEX : -1;
    case GL_TEXTURE_2D_ARRAY_EXT:
-      return TEXTURE_2D_ARRAY_INDEX;
+      return ctx->API == API_OPENGL
+         && (ctx->Extensions.EXT_texture_array
+             || ctx->Extensions.MESA_texture_array)
+         ? TEXTURE_2D_ARRAY_INDEX : -1;
    case GL_TEXTURE_BUFFER_ARB:
-      return TEXTURE_BUFFER_INDEX;
+      return ctx->API == API_OPENGL && ctx->Extensions.ARB_texture_buffer_object
+         ? TEXTURE_BUFFER_INDEX : -1;
    case GL_TEXTURE_EXTERNAL_OES:
-      return TEXTURE_EXTERNAL_INDEX;
+      return (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2)
+         && ctx->Extensions.OES_EGL_image_external
+         ? TEXTURE_EXTERNAL_INDEX : -1;
    default:
       return -1;
    }
@@ -1124,7 +1136,7 @@ _mesa_BindTexture( GLenum target, GLuint texName )
       _mesa_debug(ctx, "glBindTexture %s %d\n",
                   _mesa_lookup_enum_by_nr(target), (GLint) texName);
 
-   targetIndex = target_enum_to_index(target);
+   targetIndex = target_enum_to_index(ctx, target);
    if (targetIndex < 0) {
       _mesa_error(ctx, GL_INVALID_ENUM, "glBindTexture(target)");
       return;
diff --git a/src/mesa/main/texparam.c b/src/mesa/main/texparam.c
index 9e7c3e4..c50390e 100644
--- a/src/mesa/main/texparam.c
+++ b/src/mesa/main/texparam.c
@@ -29,7 +29,7 @@
  * glTexParameter-related functions
  */
 
-
+#include <stdbool.h>
 #include "main/glheader.h"
 #include "main/colormac.h"
 #include "main/context.h"
@@ -56,43 +56,52 @@ static GLboolean
 validate_texture_wrap_mode(struct gl_context * ctx, GLenum target, GLenum wrap)
 {
    const struct gl_extensions * const e = & ctx->Extensions;
+   const bool is_desktop_gl = ctx->API == API_OPENGL;
+   bool supported;
 
-   if (target == GL_TEXTURE_RECTANGLE_NV) {
-      if (wrap == GL_CLAMP || wrap == GL_CLAMP_TO_EDGE ||
-          (wrap == GL_CLAMP_TO_BORDER && e->ARB_texture_border_clamp))
-         return GL_TRUE;
-   }
-   else if (target == GL_TEXTURE_EXTERNAL_OES) {
-      if (wrap == GL_CLAMP_TO_EDGE)
-         return GL_TRUE;
-   }
-   else {
-      switch (wrap) {
-      case GL_CLAMP:
-      case GL_REPEAT:
-      case GL_CLAMP_TO_EDGE:
-      case GL_MIRRORED_REPEAT:
-         return GL_TRUE;
-      case GL_CLAMP_TO_BORDER:
-         if (e->ARB_texture_border_clamp)
-            return GL_TRUE;
-         break;
-      case GL_MIRROR_CLAMP_EXT:
-      case GL_MIRROR_CLAMP_TO_EDGE_EXT:
-         if (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp)
-            return GL_TRUE;
-         break;
-      case GL_MIRROR_CLAMP_TO_BORDER_EXT:
-         if (e->EXT_texture_mirror_clamp)
-            return GL_TRUE;
-         break;
-      default:
-         break;
-      }
+   switch (wrap) {
+   case GL_CLAMP:
+      supported = is_desktop_gl && (target != GL_TEXTURE_EXTERNAL_OES);
+      break;
+
+   case GL_CLAMP_TO_EDGE:
+      supported = true;
+      break;
+
+   case GL_CLAMP_TO_BORDER:
+      supported = is_desktop_gl && e->ARB_texture_border_clamp
+         && (target != GL_TEXTURE_EXTERNAL_OES);
+      break;
+
+   case GL_REPEAT:
+   case GL_MIRRORED_REPEAT:
+      supported = (target != GL_TEXTURE_RECTANGLE_NV)
+         && (target != GL_TEXTURE_EXTERNAL_OES);
+      break;
+
+   case GL_MIRROR_CLAMP_EXT:
+   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
+      supported = is_desktop_gl 
+         && (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp)
+	 && (target != GL_TEXTURE_RECTANGLE_NV)
+         && (target != GL_TEXTURE_EXTERNAL_OES);
+      break;
+
+   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
+      supported = is_desktop_gl && e->EXT_texture_mirror_clamp
+	 && (target != GL_TEXTURE_RECTANGLE_NV)
+         && (target != GL_TEXTURE_EXTERNAL_OES);
+      break;
+
+   default:
+      supported = false;
+      break;
    }
 
-   _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)", wrap );
-   return GL_FALSE;
+   if (!supported)
+      _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)", wrap );
+
+   return supported;
 }
 
 
@@ -118,35 +127,43 @@ get_texobj(struct gl_context *ctx, GLenum target, GLboolean get)
 
    switch (target) {
    case GL_TEXTURE_1D:
-      return texUnit->CurrentTex[TEXTURE_1D_INDEX];
+      if (ctx->API == API_OPENGL)
+         return texUnit->CurrentTex[TEXTURE_1D_INDEX];
+      break;
    case GL_TEXTURE_2D:
       return texUnit->CurrentTex[TEXTURE_2D_INDEX];
    case GL_TEXTURE_3D:
-      return texUnit->CurrentTex[TEXTURE_3D_INDEX];
+      if (ctx->API != API_OPENGLES)
+         return texUnit->CurrentTex[TEXTURE_3D_INDEX];
+      break;
    case GL_TEXTURE_CUBE_MAP:
       if (ctx->Extensions.ARB_texture_cube_map) {
          return texUnit->CurrentTex[TEXTURE_CUBE_INDEX];
       }
       break;
    case GL_TEXTURE_RECTANGLE_NV:
-      if (ctx->Extensions.NV_texture_rectangle) {
+      if (ctx->API == API_OPENGL
+          && ctx->Extensions.NV_texture_rectangle) {
          return texUnit->CurrentTex[TEXTURE_RECT_INDEX];
       }
       break;
    case GL_TEXTURE_1D_ARRAY_EXT:
-      if (ctx->Extensions.MESA_texture_array ||
-          ctx->Extensions.EXT_texture_array) {
+      if (ctx->API == API_OPENGL
+          && (ctx->Extensions.MESA_texture_array ||
+              ctx->Extensions.EXT_texture_array)) {
          return texUnit->CurrentTex[TEXTURE_1D_ARRAY_INDEX];
       }
       break;
    case GL_TEXTURE_2D_ARRAY_EXT:
-      if (ctx->Extensions.MESA_texture_array ||
-          ctx->Extensions.EXT_texture_array) {
+      if (ctx->API == API_OPENGL
+          && (ctx->Extensions.MESA_texture_array ||
+              ctx->Extensions.EXT_texture_array)) {
          return texUnit->CurrentTex[TEXTURE_2D_ARRAY_INDEX];
       }
       break;
    case GL_TEXTURE_EXTERNAL_OES:
-      if (ctx->Extensions.OES_EGL_image_external) {
+      if ((ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2)
+          && ctx->Extensions.OES_EGL_image_external) {
          return texUnit->CurrentTex[TEXTURE_EXTERNAL_INDEX];
       }
       break;
@@ -305,6 +322,9 @@ set_tex_parameteri(struct gl_context *ctx,
       return GL_FALSE;
 
    case GL_TEXTURE_BASE_LEVEL:
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       if (texObj->BaseLevel == params[0])
          return GL_FALSE;
       if (params[0] < 0 ||
@@ -318,6 +338,9 @@ set_tex_parameteri(struct gl_context *ctx,
       return GL_TRUE;
 
    case GL_TEXTURE_MAX_LEVEL:
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       if (texObj->MaxLevel == params[0])
          return GL_FALSE;
       if (params[0] < 0 || texObj->Target == GL_TEXTURE_RECTANGLE_ARB) {
@@ -330,6 +353,9 @@ set_tex_parameteri(struct gl_context *ctx,
       return GL_TRUE;
 
    case GL_GENERATE_MIPMAP_SGIS:
+      if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+         goto invalid_pname;
+
       if (params[0] && texObj->Target == GL_TEXTURE_EXTERNAL_OES)
          goto invalid_param;
       if (texObj->GenerateMipmap != params[0]) {
@@ -340,6 +366,9 @@ set_tex_parameteri(struct gl_context *ctx,
       return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_MODE_ARB:
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       if (ctx->Extensions.ARB_shadow) {
          if (texObj->Sampler.CompareMode == params[0])
             return GL_FALSE;
@@ -354,7 +383,7 @@ set_tex_parameteri(struct gl_context *ctx,
       goto invalid_pname;
 
    case GL_TEXTURE_COMPARE_FUNC_ARB:
-      if (ctx->Extensions.ARB_shadow) {
+      if (ctx->API != API_OPENGL && ctx->Extensions.ARB_shadow) {
          if (texObj->Sampler.CompareFunc == params[0])
             return GL_FALSE;
          switch (params[0]) {
@@ -382,7 +411,7 @@ set_tex_parameteri(struct gl_context *ctx,
       goto invalid_pname;
 
    case GL_DEPTH_TEXTURE_MODE_ARB:
-      if (ctx->Extensions.ARB_depth_texture) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ARB_depth_texture) {
          if (texObj->DepthMode == params[0])
             return GL_FALSE;
          if (params[0] == GL_LUMINANCE ||
@@ -399,6 +428,9 @@ set_tex_parameteri(struct gl_context *ctx,
 
 #if FEATURE_OES_draw_texture
    case GL_TEXTURE_CROP_RECT_OES:
+      if (ctx->API == API_OPENGLES && ctx->Extensions.OES_draw_texture)
+         goto invalid_pname;
+
       texObj->CropRect[0] = params[0];
       texObj->CropRect[1] = params[1];
       texObj->CropRect[2] = params[2];
@@ -410,7 +442,7 @@ set_tex_parameteri(struct gl_context *ctx,
    case GL_TEXTURE_SWIZZLE_G_EXT:
    case GL_TEXTURE_SWIZZLE_B_EXT:
    case GL_TEXTURE_SWIZZLE_A_EXT:
-      if (ctx->Extensions.EXT_texture_swizzle) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.EXT_texture_swizzle) {
          const GLuint comp = pname - GL_TEXTURE_SWIZZLE_R_EXT;
          const GLint swz = comp_to_swizzle(params[0]);
          if (swz < 0) {
@@ -428,7 +460,7 @@ set_tex_parameteri(struct gl_context *ctx,
       goto invalid_pname;
 
    case GL_TEXTURE_SWIZZLE_RGBA_EXT:
-      if (ctx->Extensions.EXT_texture_swizzle) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.EXT_texture_swizzle) {
          GLuint comp;
          flush(ctx);
          for (comp = 0; comp < 4; comp++) {
@@ -448,7 +480,7 @@ set_tex_parameteri(struct gl_context *ctx,
       goto invalid_pname;
 
    case GL_TEXTURE_SRGB_DECODE_EXT:
-      if (ctx->Extensions.EXT_texture_sRGB_decode) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.EXT_texture_sRGB_decode) {
 	 GLenum decode = params[0];
 	 if (decode == GL_DECODE_EXT || decode == GL_SKIP_DECODE_EXT) {
 	    if (texObj->Sampler.sRGBDecode != decode) {
@@ -461,7 +493,8 @@ set_tex_parameteri(struct gl_context *ctx,
       goto invalid_pname;
 
    case GL_TEXTURE_CUBE_MAP_SEAMLESS:
-      if (ctx->Extensions.AMD_seamless_cubemap_per_texture) {
+      if (ctx->API == API_OPENGL
+          && ctx->Extensions.AMD_seamless_cubemap_per_texture) {
          GLenum param = params[0];
          if (param != GL_TRUE && param != GL_FALSE) {
             goto invalid_param;
@@ -501,6 +534,9 @@ set_tex_parameterf(struct gl_context *ctx,
 {
    switch (pname) {
    case GL_TEXTURE_MIN_LOD:
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       if (texObj->Sampler.MinLod == params[0])
          return GL_FALSE;
       flush(ctx);
@@ -508,6 +544,9 @@ set_tex_parameterf(struct gl_context *ctx,
       return GL_TRUE;
 
    case GL_TEXTURE_MAX_LOD:
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       if (texObj->Sampler.MaxLod == params[0])
          return GL_FALSE;
       flush(ctx);
@@ -515,6 +554,9 @@ set_tex_parameterf(struct gl_context *ctx,
       return GL_TRUE;
 
    case GL_TEXTURE_PRIORITY:
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       flush(ctx);
       texObj->Priority = CLAMP(params[0], 0.0F, 1.0F);
       return GL_TRUE;
@@ -536,13 +578,12 @@ set_tex_parameterf(struct gl_context *ctx,
       else {
          static GLuint count = 0;
          if (count++ < 10)
-            _mesa_error(ctx, GL_INVALID_ENUM,
-                        "glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)");
+            goto invalid_pname;
       }
       return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
-      if (ctx->Extensions.ARB_shadow_ambient) {
+      if (ctx->API == API_OPENGL && ctx->Extensions.ARB_shadow_ambient) {
          if (texObj->Sampler.CompareFailValue != params[0]) {
             flush(ctx);
             texObj->Sampler.CompareFailValue = CLAMP(params[0], 0.0F, 1.0F);
@@ -550,13 +591,15 @@ set_tex_parameterf(struct gl_context *ctx,
          }
       }
       else {
-         _mesa_error(ctx, GL_INVALID_ENUM,
-                    "glTexParameter(pname=GL_TEXTURE_COMPARE_FAIL_VALUE_ARB)");
+            goto invalid_pname;
       }
       return GL_FALSE;
 
    case GL_TEXTURE_LOD_BIAS:
       /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias */
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       if (texObj->Sampler.LodBias != params[0]) {
 	 flush(ctx);
 	 texObj->Sampler.LodBias = params[0];
@@ -565,6 +608,9 @@ set_tex_parameterf(struct gl_context *ctx,
       break;
 
    case GL_TEXTURE_BORDER_COLOR:
+      if (ctx->API != API_OPENGL)
+         goto invalid_pname;
+
       flush(ctx);
       /* ARB_texture_float disables clamping */
       if (ctx->Extensions.ARB_texture_float) {
@@ -581,9 +627,14 @@ set_tex_parameterf(struct gl_context *ctx,
       return GL_TRUE;
 
    default:
-      _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
+      goto invalid_pname;
    }
    return GL_FALSE;
+
+invalid_pname:
+   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=%s)",
+               _mesa_lookup_enum_by_nr(pname));
+   return GL_FALSE;
 }
 
 
@@ -1098,6 +1149,9 @@ _mesa_GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
          *params = ENUM_TO_FLOAT(obj->Sampler.WrapR);
          break;
       case GL_TEXTURE_BORDER_COLOR:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          if (ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
             _mesa_update_state_locked(ctx);
          if (ctx->Color._ClampFragmentColor) {
@@ -1114,21 +1168,39 @@ _mesa_GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
          }
          break;
       case GL_TEXTURE_RESIDENT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = 1.0F;
          break;
       case GL_TEXTURE_PRIORITY:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = obj->Priority;
          break;
       case GL_TEXTURE_MIN_LOD:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = obj->Sampler.MinLod;
          break;
       case GL_TEXTURE_MAX_LOD:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = obj->Sampler.MaxLod;
          break;
       case GL_TEXTURE_BASE_LEVEL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = (GLfloat) obj->BaseLevel;
          break;
       case GL_TEXTURE_MAX_LEVEL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = (GLfloat) obj->MaxLevel;
          break;
       case GL_TEXTURE_MAX_ANISOTROPY_EXT:
@@ -1137,33 +1209,43 @@ _mesa_GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
          *params = obj->Sampler.MaxAnisotropy;
          break;
       case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
-         if (!ctx->Extensions.ARB_shadow_ambient)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_shadow_ambient)
             goto invalid_pname;
          *params = obj->Sampler.CompareFailValue;
          break;
       case GL_GENERATE_MIPMAP_SGIS:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_pname;
+
 	 *params = (GLfloat) obj->GenerateMipmap;
          break;
       case GL_TEXTURE_COMPARE_MODE_ARB:
-         if (!ctx->Extensions.ARB_shadow)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_shadow)
             goto invalid_pname;
          *params = (GLfloat) obj->Sampler.CompareMode;
          break;
       case GL_TEXTURE_COMPARE_FUNC_ARB:
-         if (!ctx->Extensions.ARB_shadow)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_shadow)
             goto invalid_pname;
          *params = (GLfloat) obj->Sampler.CompareFunc;
          break;
       case GL_DEPTH_TEXTURE_MODE_ARB:
-         if (!ctx->Extensions.ARB_depth_texture)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_depth_texture)
             goto invalid_pname;
          *params = (GLfloat) obj->DepthMode;
          break;
       case GL_TEXTURE_LOD_BIAS:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = obj->Sampler.LodBias;
          break;
 #if FEATURE_OES_draw_texture
       case GL_TEXTURE_CROP_RECT_OES:
+         if ((ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2)
+            || !ctx->Extensions.OES_draw_texture)
+            goto invalid_pname;
+
          params[0] = obj->CropRect[0];
          params[1] = obj->CropRect[1];
          params[2] = obj->CropRect[2];
@@ -1175,13 +1257,13 @@ _mesa_GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
       case GL_TEXTURE_SWIZZLE_G_EXT:
       case GL_TEXTURE_SWIZZLE_B_EXT:
       case GL_TEXTURE_SWIZZLE_A_EXT:
-         if (!ctx->Extensions.EXT_texture_swizzle)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.EXT_texture_swizzle)
             goto invalid_pname;
          *params = (GLfloat) obj->Swizzle[pname - GL_TEXTURE_SWIZZLE_R_EXT];
          break;
 
       case GL_TEXTURE_SWIZZLE_RGBA_EXT:
-         if (!ctx->Extensions.EXT_texture_swizzle) {
+         if (ctx->API != API_OPENGL || !ctx->Extensions.EXT_texture_swizzle) {
             goto invalid_pname;
          }
          else {
@@ -1193,7 +1275,8 @@ _mesa_GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
          break;
 
       case GL_TEXTURE_CUBE_MAP_SEAMLESS:
-         if (!ctx->Extensions.AMD_seamless_cubemap_per_texture)
+         if (ctx->API != API_OPENGL
+             || !ctx->Extensions.AMD_seamless_cubemap_per_texture)
             goto invalid_pname;
          *params = (GLfloat) obj->Sampler.CubeMapSeamless;
          break;
@@ -1247,6 +1330,9 @@ _mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
          *params = (GLint) obj->Sampler.WrapR;
          break;
       case GL_TEXTURE_BORDER_COLOR:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          {
             GLfloat b[4];
             b[0] = CLAMP(obj->Sampler.BorderColor.f[0], 0.0F, 1.0F);
@@ -1260,21 +1346,39 @@ _mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
          }
          break;
       case GL_TEXTURE_RESIDENT:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = 1;
          break;
       case GL_TEXTURE_PRIORITY:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = FLOAT_TO_INT(obj->Priority);
          break;
       case GL_TEXTURE_MIN_LOD:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = (GLint) obj->Sampler.MinLod;
          break;
       case GL_TEXTURE_MAX_LOD:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = (GLint) obj->Sampler.MaxLod;
          break;
       case GL_TEXTURE_BASE_LEVEL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = obj->BaseLevel;
          break;
       case GL_TEXTURE_MAX_LEVEL:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = obj->MaxLevel;
          break;
       case GL_TEXTURE_MAX_ANISOTROPY_EXT:
@@ -1283,33 +1387,43 @@ _mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
          *params = (GLint) obj->Sampler.MaxAnisotropy;
          break;
       case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
-         if (!ctx->Extensions.ARB_shadow_ambient)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_shadow_ambient)
             goto invalid_pname;
          *params = (GLint) FLOAT_TO_INT(obj->Sampler.CompareFailValue);
          break;
       case GL_GENERATE_MIPMAP_SGIS:
+         if (ctx->API != API_OPENGL && ctx->API != API_OPENGLES)
+            goto invalid_pname;
+
 	 *params = (GLint) obj->GenerateMipmap;
          break;
       case GL_TEXTURE_COMPARE_MODE_ARB:
-         if (!ctx->Extensions.ARB_shadow)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_shadow)
             goto invalid_pname;
          *params = (GLint) obj->Sampler.CompareMode;
          break;
       case GL_TEXTURE_COMPARE_FUNC_ARB:
-         if (!ctx->Extensions.ARB_shadow)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_shadow)
             goto invalid_pname;
          *params = (GLint) obj->Sampler.CompareFunc;
          break;
       case GL_DEPTH_TEXTURE_MODE_ARB:
-         if (!ctx->Extensions.ARB_depth_texture)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.ARB_depth_texture)
             goto invalid_pname;
          *params = (GLint) obj->DepthMode;
          break;
       case GL_TEXTURE_LOD_BIAS:
+         if (ctx->API != API_OPENGL)
+            goto invalid_pname;
+
          *params = (GLint) obj->Sampler.LodBias;
          break;
 #if FEATURE_OES_draw_texture
       case GL_TEXTURE_CROP_RECT_OES:
+         if ((ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2)
+             || !ctx->Extensions.OES_draw_texture)
+            goto invalid_pname;
+
          params[0] = obj->CropRect[0];
          params[1] = obj->CropRect[1];
          params[2] = obj->CropRect[2];
@@ -1320,19 +1434,20 @@ _mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
       case GL_TEXTURE_SWIZZLE_G_EXT:
       case GL_TEXTURE_SWIZZLE_B_EXT:
       case GL_TEXTURE_SWIZZLE_A_EXT:
-         if (!ctx->Extensions.EXT_texture_swizzle)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.EXT_texture_swizzle)
             goto invalid_pname;
          *params = obj->Swizzle[pname - GL_TEXTURE_SWIZZLE_R_EXT];
          break;
 
       case GL_TEXTURE_SWIZZLE_RGBA_EXT:
-         if (!ctx->Extensions.EXT_texture_swizzle)
+         if (ctx->API != API_OPENGL || !ctx->Extensions.EXT_texture_swizzle)
             goto invalid_pname;
          COPY_4V(params, obj->Swizzle);
          break;
 
       case GL_TEXTURE_CUBE_MAP_SEAMLESS:
-         if (!ctx->Extensions.AMD_seamless_cubemap_per_texture)
+         if (ctx->API != API_OPENGL
+             || !ctx->Extensions.AMD_seamless_cubemap_per_texture)
             goto invalid_pname;
          *params = (GLint) obj->Sampler.CubeMapSeamless;
          break;
@@ -1344,7 +1459,8 @@ _mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
          break;
 
       case GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES:
-         if (!ctx->Extensions.OES_EGL_image_external)
+         if ((ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2)
+             || !ctx->Extensions.OES_EGL_image_external)
             goto invalid_pname;
          *params = obj->RequiredTextureImageUnits;
          break;
diff --git a/src/mesa/main/uniform_query.cpp b/src/mesa/main/uniform_query.cpp
index 816c277..48b9dda 100644
--- a/src/mesa/main/uniform_query.cpp
+++ b/src/mesa/main/uniform_query.cpp
@@ -859,7 +859,8 @@ _mesa_uniform_matrix(struct gl_context *ctx, struct gl_shader_program *shProg,
 
    /* GL_INVALID_VALUE is generated if `transpose' is not GL_FALSE.
     * http://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml */
-   if (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2) {
+   if (ctx->API == API_OPENGLES
+       || (ctx->API == API_OPENGLES2 && ctx->Version < 30)) {
       if (transpose) {
 	 _mesa_error(ctx, GL_INVALID_VALUE,
 		     "glUniformMatrix(matrix transpose is not GL_FALSE)");
diff --git a/src/mesa/main/varray.c b/src/mesa/main/varray.c
index 327fabb..356b44a 100644
--- a/src/mesa/main/varray.c
+++ b/src/mesa/main/varray.c
@@ -133,16 +133,31 @@ update_array(struct gl_context *ctx,
    GLsizei elementSize;
    GLenum format = GL_RGBA;
 
-   if (ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2) {
-      /* fixed point arrays / data is only allowed with OpenGL ES 1.x/2.0 */
+   if (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2) {
+      /* Once Mesa gets support for GL_OES_vertex_half_float this mask will
+       * change.  Adding support for this extension isn't quite as trivial as
+       * we'd like because ES uses a different enum value for GL_HALF_FLOAT.
+       */
+      legalTypesMask &= ~(FIXED_GL_BIT
+                          | UNSIGNED_INT_2_10_10_10_REV_BIT
+                          | INT_2_10_10_10_REV_BIT
+                          | HALF_BIT | DOUBLE_BIT);
+
+      /* BGRA ordering is not supported in ES contexts.
+       */
+      if (sizeMax == BGRA_OR_4)
+         sizeMax = 4;
+   } else {
+      assert(ctx->API == API_OPENGL);
+
       legalTypesMask &= ~FIXED_ES_BIT;
-   }
-   if (!ctx->Extensions.ARB_ES2_compatibility) {
-      legalTypesMask &= ~FIXED_GL_BIT;
-   }
-   if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev) {
-      legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
-                          INT_2_10_10_10_REV_BIT);
+
+      if (!ctx->Extensions.ARB_ES2_compatibility)
+         legalTypesMask &= ~FIXED_GL_BIT;
+
+      if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
+         legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
+                             INT_2_10_10_10_REV_BIT);
    }
 
    typeBit = type_to_bit(ctx, type);
@@ -228,16 +243,15 @@ update_array(struct gl_context *ctx,
 void GLAPIENTRY
 _mesa_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
 {
-   GLbitfield legalTypes = (SHORT_BIT | INT_BIT | FLOAT_BIT |
-                            DOUBLE_BIT | HALF_BIT | FIXED_ES_BIT |
-                            UNSIGNED_INT_2_10_10_10_REV_BIT |
-                            INT_2_10_10_10_REV_BIT);
    GET_CURRENT_CONTEXT(ctx);
+   GLbitfield legalTypes = (ctx->API == API_OPENGLES)
+      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
+      : (SHORT_BIT | INT_BIT | FLOAT_BIT |
+         DOUBLE_BIT | HALF_BIT |
+         UNSIGNED_INT_2_10_10_10_REV_BIT |
+         INT_2_10_10_10_REV_BIT);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if (ctx->API == API_OPENGLES)
-      legalTypes |= BYTE_BIT;
-
    update_array(ctx, "glVertexPointer", VERT_ATTRIB_POS,
                 legalTypes, 2, 4,
                 size, type, stride, GL_FALSE, GL_FALSE, ptr);
@@ -247,12 +261,13 @@ _mesa_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
 void GLAPIENTRY
 _mesa_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr )
 {
-   const GLbitfield legalTypes = (BYTE_BIT | SHORT_BIT | INT_BIT |
-                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
-                                  FIXED_ES_BIT |
-                                  UNSIGNED_INT_2_10_10_10_REV_BIT |
-                                  INT_2_10_10_10_REV_BIT);
    GET_CURRENT_CONTEXT(ctx);
+   const GLbitfield legalTypes = (ctx->API == API_OPENGLES)
+      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
+      : (BYTE_BIT | SHORT_BIT | INT_BIT |
+         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
+         UNSIGNED_INT_2_10_10_10_REV_BIT |
+         INT_2_10_10_10_REV_BIT);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
    update_array(ctx, "glNormalPointer", VERT_ATTRIB_NORMAL,
@@ -264,18 +279,20 @@ _mesa_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr )
 void GLAPIENTRY
 _mesa_ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
 {
-   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
-                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
-                                  INT_BIT | UNSIGNED_INT_BIT |
-                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
-                                  FIXED_ES_BIT |
-                                  UNSIGNED_INT_2_10_10_10_REV_BIT |
-                                  INT_2_10_10_10_REV_BIT);
    GET_CURRENT_CONTEXT(ctx);
+   const GLbitfield legalTypes = (ctx->API == API_OPENGLES)
+      ? (UNSIGNED_BYTE_BIT | HALF_BIT | FLOAT_BIT | FIXED_ES_BIT)
+      : (BYTE_BIT | UNSIGNED_BYTE_BIT |
+         SHORT_BIT | UNSIGNED_SHORT_BIT |
+         INT_BIT | UNSIGNED_INT_BIT |
+         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
+         UNSIGNED_INT_2_10_10_10_REV_BIT |
+         INT_2_10_10_10_REV_BIT);
+   const GLint sizeMin = (ctx->API == API_OPENGLES) ? 4 : 3;
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
    update_array(ctx, "glColorPointer", VERT_ATTRIB_COLOR0,
-                legalTypes, 3, BGRA_OR_4,
+                legalTypes, sizeMin, BGRA_OR_4,
                 size, type, stride, GL_TRUE, GL_FALSE, ptr);
 }
 
@@ -330,20 +347,19 @@ void GLAPIENTRY
 _mesa_TexCoordPointer(GLint size, GLenum type, GLsizei stride,
                       const GLvoid *ptr)
 {
-   GLbitfield legalTypes = (SHORT_BIT | INT_BIT |
-                            HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
-                            FIXED_ES_BIT |
-                            UNSIGNED_INT_2_10_10_10_REV_BIT |
-                            INT_2_10_10_10_REV_BIT);
    GET_CURRENT_CONTEXT(ctx);
+   GLbitfield legalTypes = (ctx->API == API_OPENGLES)
+      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
+      : (SHORT_BIT | INT_BIT |
+         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
+         UNSIGNED_INT_2_10_10_10_REV_BIT |
+         INT_2_10_10_10_REV_BIT);
+   const GLint sizeMin = (ctx->API == API_OPENGLES) ? 2 : 1;
    const GLuint unit = ctx->Array.ActiveTexture;
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if (ctx->API == API_OPENGLES)
-      legalTypes |= BYTE_BIT;
-
    update_array(ctx, "glTexCoordPointer", VERT_ATTRIB_TEX(unit),
-                legalTypes, 1, 4,
+                legalTypes, sizeMin, 4,
                 size, type, stride, GL_FALSE, GL_FALSE,
                 ptr);
 }
@@ -568,12 +584,14 @@ get_vertex_array_attrib(struct gl_context *ctx, GLuint index, GLenum pname,
    case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB:
       return array->BufferObj->Name;
    case GL_VERTEX_ATTRIB_ARRAY_INTEGER:
-      if (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4) {
+      if (ctx->API == API_OPENGL
+          && (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4)) {
          return array->Integer;
       }
       goto error;
    case GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB:
-      if (ctx->Extensions.ARB_instanced_arrays) {
+      if (ctx->API == API_OPENGL
+          && ctx->Extensions.ARB_instanced_arrays) {
          return array->InstanceDivisor;
       }
       goto error;
diff --git a/src/mesa/main/version.c b/src/mesa/main/version.c
index 59c81ae..00011f3 100644
--- a/src/mesa/main/version.c
+++ b/src/mesa/main/version.c
@@ -284,7 +284,30 @@ compute_version_es2(struct gl_context *ctx)
                               ctx->Extensions.ARB_fragment_shader &&
                               ctx->Extensions.ARB_texture_non_power_of_two &&
                               ctx->Extensions.EXT_blend_equation_separate);
-   if (ver_2_0) {
+   /* FINISHME: This list isn't quite right. */
+   const GLboolean ver_3_0 = (ctx->Extensions.ARB_half_float_vertex &&
+                              ctx->Extensions.ARB_map_buffer_range &&
+                              ctx->Extensions.ARB_shader_texture_lod &&
+                              ctx->Extensions.ARB_texture_float &&
+                              ctx->Extensions.ARB_texture_rg &&
+                              ctx->Extensions.ARB_texture_compression_rgtc &&
+                              ctx->Extensions.APPLE_vertex_array_object &&
+                              ctx->Extensions.EXT_draw_buffers2 &&
+                              /* ctx->Extensions.ARB_framebuffer_object && */
+                              ctx->Extensions.EXT_framebuffer_sRGB &&
+                              ctx->Extensions.EXT_packed_float &&
+                              ctx->Extensions.EXT_texture_array &&
+                              ctx->Extensions.EXT_texture_shared_exponent &&
+                              ctx->Extensions.EXT_transform_feedback &&
+                              ctx->Extensions.NV_conditional_render &&
+                              ctx->Extensions.ARB_copy_buffer &&
+                              ctx->Extensions.ARB_draw_instanced &&
+                              ctx->Extensions.ARB_uniform_buffer_object &&
+                              ctx->Extensions.EXT_texture_snorm &&
+                              ctx->Extensions.NV_primitive_restart);
+   if (ver_3_0) {
+      ctx->Version = 30;
+   } else if (ver_2_0) {
       ctx->Version = 20;
    } else {
       _mesa_problem(ctx, "Incomplete OpenGL ES 2.0 support.");
@@ -293,11 +316,11 @@ compute_version_es2(struct gl_context *ctx)
    ctx->VersionString = (char *) malloc(max);
    if (ctx->VersionString) {
       _mesa_snprintf(ctx->VersionString, max,
-		     "OpenGL ES 2.0 Mesa " MESA_VERSION_STRING
+		     "OpenGL ES %d.%d Mesa " MESA_VERSION_STRING
 #ifdef MESA_GIT_SHA1
 		     " (" MESA_GIT_SHA1 ")"
 #endif
-		     );
+                     , ctx->Version / 10, ctx->Version % 10);
    }
 }
 
diff --git a/src/mesa/main/vtxfmt.c b/src/mesa/main/vtxfmt.c
index ce490ed..c73cfbb 100644
--- a/src/mesa/main/vtxfmt.c
+++ b/src/mesa/main/vtxfmt.c
@@ -218,8 +218,7 @@ install_vtxfmt(struct gl_context *ctx, struct _glapi_table *tab,
 void
 _mesa_install_exec_vtxfmt(struct gl_context *ctx, const GLvertexformat *vfmt)
 {
-   if (_mesa_is_desktop_gl(ctx))
-      install_vtxfmt( ctx, ctx->Exec, vfmt );
+   install_vtxfmt( ctx, ctx->Exec, vfmt );
 }
 
 
diff --git a/src/mesa/sources.mak b/src/mesa/sources.mak
index 74744c4..85a9456 100644
--- a/src/mesa/sources.mak
+++ b/src/mesa/sources.mak
@@ -6,7 +6,7 @@
 # this is part of MAIN_FILES
 MAIN_ES_FILES = \
 	$(BUILDDIR)main/api_exec_es1.c \
-	$(BUILDDIR)main/api_exec_es2.c
+	$(BUILDDIR)main/es1_conversion.c
 
 MAIN_FILES = \
 	$(SRCDIR)main/api_arrayelt.c \
diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index fc7e406..a97f8d7 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -457,10 +457,10 @@ vbo_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
       updateMats = ALL_MATERIAL_BITS;
    }
 
-   if (face == GL_FRONT) {
+   if (ctx->API == API_OPENGL && face == GL_FRONT) {
       updateMats &= FRONT_MATERIAL_BITS;
    }
-   else if (face == GL_BACK) {
+   else if (ctx->API == API_OPENGL && face == GL_BACK) {
       updateMats &= BACK_MATERIAL_BITS;
    }
    else if (face != GL_FRONT_AND_BACK) {
@@ -506,6 +506,10 @@ vbo_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
          MAT_ATTR(VBO_ATTRIB_MAT_BACK_SHININESS, 1, params);
       break;
    case GL_COLOR_INDEXES:
+      if (ctx->API != API_OPENGL) {
+         _mesa_error(ctx, GL_INVALID_ENUM, "glMaterialfv(pname)");
+         return;
+      }
       if (updateMats & MAT_BIT_FRONT_INDEXES)
          MAT_ATTR(VBO_ATTRIB_MAT_FRONT_INDEXES, 3, params);
       if (updateMats & MAT_BIT_BACK_INDEXES)
