diff --git a/dlls/xinput1_3/xinput1_3_main.c b/dlls/xinput1_3/xinput1_3_main.c
index f4386b8..13bd09d 100644
--- a/dlls/xinput1_3/xinput1_3_main.c
+++ b/dlls/xinput1_3/xinput1_3_main.c
@@ -19,9 +19,26 @@
 
 #include "config.h"
 #include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
 #include <stdarg.h>
+#include <stdio.h>
 #include <string.h>
 
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SYS_IOCTL_H
+# include <sys/ioctl.h>
+#endif
+#ifdef HAVE_LINUX_INPUT_H
+# include <linux/input.h>
+# undef SW_MAX
+# if defined(EVIOCGBIT) && defined(EV_ABS) && defined(BTN_PINKIE)
+#  define HAVE_CORRECT_LINUXINPUT_H
+# endif
+#endif
+
 #include "wine/debug.h"
 #include "windef.h"
 #include "winbase.h"
@@ -31,6 +48,133 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(xinput);
 
+#ifdef HAVE_CORRECT_LINUXINPUT_H
+
+#define test_bit(arr,bit)   (((BYTE*)(arr))[(bit)>>3]&(1<<((bit)&7)))
+#define set_bit(arr,bit)    (((BYTE*)(arr))[(bit)>>3]|=(1<<((bit)&7)))
+#define EVDEVPREFIX         "/dev/input/event"
+#define EVDEVPREFIX_LEN     16
+#define MAX_JOYDEV          64
+#define WINE_XINPUT_AXES     8
+#define WINE_XINPUT_BUTTONS 10
+
+static const unsigned int axes[WINE_XINPUT_AXES]        = {ABS_X, ABS_Y, ABS_Z, ABS_RX, ABS_RY, ABS_RZ, ABS_HAT0X, ABS_HAT0Y};
+static const unsigned int jbuttons[WINE_XINPUT_BUTTONS] = {BTN_START, BTN_SELECT, BTN_THUMBL, BTN_THUMBR, BTN_TL, BTN_TR, BTN_A, BTN_B, BTN_X, BTN_Y};
+static const unsigned int xbuttons[WINE_XINPUT_BUTTONS] = {XINPUT_GAMEPAD_START, XINPUT_GAMEPAD_BACK, XINPUT_GAMEPAD_LEFT_THUMB, XINPUT_GAMEPAD_RIGHT_THUMB, XINPUT_GAMEPAD_LEFT_SHOULDER, XINPUT_GAMEPAD_RIGHT_SHOULDER, XINPUT_GAMEPAD_A, XINPUT_GAMEPAD_B, XINPUT_GAMEPAD_X, XINPUT_GAMEPAD_Y};
+
+static struct xpad {
+    char             device[EVDEVPREFIX_LEN + 4];
+    int              fd;
+    XINPUT_STATE     state;
+} xpads[XUSER_MAX_COUNT];
+
+static inline BOOL different_states(const PXINPUT_STATE const a, const PXINPUT_STATE const b)
+{
+    return a->Gamepad.sThumbLX      != b->Gamepad.sThumbLX
+        || a->Gamepad.sThumbLY      != b->Gamepad.sThumbLY
+        || a->Gamepad.sThumbRX      != b->Gamepad.sThumbRX
+        || a->Gamepad.sThumbRY      != b->Gamepad.sThumbRY
+        || a->Gamepad.bLeftTrigger  != b->Gamepad.bLeftTrigger
+        || a->Gamepad.bRightTrigger != b->Gamepad.bRightTrigger
+        || a->Gamepad.wButtons      != b->Gamepad.wButtons;
+}
+
+static void xinput_find_joydevs(void)
+{
+    int  fd, i, j;
+    char buf[MAX_PATH];
+
+    static BOOL init;
+    static BYTE absreq[(ABS_MAX+7)/8];
+    static BYTE keyreq[(KEY_MAX+7)/8];
+
+    /* Initialize required axes/button bits. These are used to detect which devices are Xbox360 Controllers */
+    if(!init) {
+        for(i=0; i<XUSER_MAX_COUNT; i++)
+            xpads[i].fd = -1;
+        for(i=0; i<WINE_XINPUT_AXES; i++)
+            set_bit(absreq,axes[i]);
+        for(i=0; i<WINE_XINPUT_BUTTONS; i++)
+            set_bit(keyreq,jbuttons[i]);
+        set_bit(keyreq,BTN_MODE); /* The globe button is reported by the xpad driver but not used by XInput */
+        init = TRUE;
+    }
+
+    /* Check whether any opened devices have become unavailable */
+    for(i=0,j=0; i<XUSER_MAX_COUNT; i++)
+        if(xpads[i].fd != -1) {
+           if(ioctl(xpads[i].fd, EVIOCGNAME(sizeof(buf)), buf) == -1) {
+               TRACE("Xbox360 Controller %d disconnected\n", i);
+               close(xpads[i].fd);
+               ZeroMemory(&xpads[i], sizeof(struct xpad));
+               xpads[i].fd = -1;
+           } else
+               j++;
+        }
+    /* If there are enough connected devices we need not check for new ones */
+    if(j>=XUSER_MAX_COUNT)
+        return;
+
+    /* Loop through all devices and test whether they are Xbox360 Controllers */
+    for(j=0; j<MAX_JOYDEV; j++) {
+        BYTE absbits[(ABS_MAX+7)/8];
+        BYTE keybits[(KEY_MAX+7)/8];
+        ZeroMemory(absbits, sizeof(absbits));
+        ZeroMemory(keybits, sizeof(keybits));
+
+        snprintf(buf, MAX_PATH, EVDEVPREFIX"%d", j);
+
+        /* Test if this device is already opened */
+        for(i=0; i<XUSER_MAX_COUNT; i++)
+            if(!strcmp(buf, xpads[i].device) && xpads[i].fd != -1)
+                break;
+        if(i<XUSER_MAX_COUNT)
+            continue;
+
+        if((fd = open(buf, O_RDONLY)) == -1)
+            continue;
+
+        /* Get device name */
+        buf[MAX_PATH - 1] = 0;
+        if (ioctl(fd, EVIOCGNAME(MAX_PATH-1), buf) == -1) {
+            WARN("ioct(EVIOCGNAME) failed: %d %s\n", errno, strerror(errno));
+            goto fail;
+        }
+
+        /* Get device axes and check whether they match those of a Xbox360 Controller */
+        if(ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits) == -1) {
+            WARN("ioct(EVIOCGBIT, EV_ABS) failed: %d %s\n", errno, strerror(errno));
+            goto fail;
+        }
+        if(memcmp(absbits, absreq, sizeof(absbits)))
+            goto fail;
+
+        /* Get device buttons and check whether they match those of a Xbox360 Controller */
+        if(ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits) == -1) {
+            WARN("ioct(EVIOCGBIT, EV_KEY) failed: %d %s\n", errno, strerror(errno));
+            goto fail;
+        }
+        /* disable compare, because it seems to fail everytime: if(memcmp(keybits, keyreq, sizeof(keybits)))
+            goto fail;*/
+
+        /* Find the next free XInput slot */
+        for(i=0; i<XUSER_MAX_COUNT; i++)
+            if(xpads[i].fd == -1)
+                break;
+        if(i>=XUSER_MAX_COUNT)
+            goto fail;
+
+        /* Add the device */
+        snprintf(xpads[i].device, sizeof(xpads[i].device), EVDEVPREFIX"%d", j);
+        xpads[i].fd = fd;
+        TRACE("Added device %s as Xbox360 Controller %d: %s\n", xpads[i].device, i, buf);
+        continue;
+
+fail:   close(fd);
+    }
+}
+#endif  /* HAVE_CORRECT_LINUXINPUT_H */
+
 BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, LPVOID reserved)
 {
     switch(reason)
@@ -69,6 +213,56 @@ DWORD WINAPI XInputSetState(DWORD dwUserIndex, XINPUT_VIBRATION* pVibration)
 
 DWORD WINAPI XInputGetState(DWORD dwUserIndex, XINPUT_STATE* pState)
 {
+#ifdef HAVE_CORRECT_LINUXINPUT_H
+    int i;
+    BYTE key[(KEY_MAX+7)/8];
+    struct input_absinfo abs[WINE_XINPUT_AXES];
+
+    TRACE("(%u %p)\n", dwUserIndex, pState);
+
+    if (!pState || dwUserIndex >= XUSER_MAX_COUNT)
+        return ERROR_BAD_ARGUMENTS;
+
+    xinput_find_joydevs();
+    if(xpads[dwUserIndex].fd == -1)
+        return ERROR_DEVICE_NOT_CONNECTED;
+
+    /* Get joystick axes and map them to XInput axes */
+    for(i=0; i<WINE_XINPUT_AXES; i++)
+        if(ioctl(xpads[dwUserIndex].fd, EVIOCGABS(axes[i]), &abs[i]) == -1) {
+            WARN("ioct(EVIOCGABS, %u) failed: %d %s\n", axes[i], errno, strerror(errno));
+            return ERROR_DEVICE_NOT_CONNECTED;
+        }
+    pState->Gamepad.sThumbLX      =  abs[0].value;
+    pState->Gamepad.sThumbLY      = ~abs[1].value;  /* On Linux a positive value means down */
+    pState->Gamepad.sThumbRX      =  abs[3].value;  /* On Windows a positive value means up */
+    pState->Gamepad.sThumbRY      = ~abs[4].value;  /* Thus we need to invert both Y-axes   */
+    pState->Gamepad.bLeftTrigger  =  abs[2].value;
+    pState->Gamepad.bRightTrigger =  abs[5].value;
+    pState->Gamepad.wButtons      = (abs[7].value<0) *XINPUT_GAMEPAD_DPAD_UP
+                                  | (abs[7].value>0) *XINPUT_GAMEPAD_DPAD_DOWN
+                                  | (abs[6].value<0) *XINPUT_GAMEPAD_DPAD_LEFT
+                                  | (abs[6].value>0) *XINPUT_GAMEPAD_DPAD_RIGHT;
+
+    /* Get joystick keystate and map it to XInput buttons */
+    ZeroMemory(key, sizeof(key));
+    if(ioctl(xpads[dwUserIndex].fd, EVIOCGKEY(sizeof(key)), key) == -1) {
+        WARN("ioct(EVIOCGKEY) failed: %d %s\n", errno, strerror(errno));
+        return ERROR_DEVICE_NOT_CONNECTED;
+    }
+    for(i=0; i<WINE_XINPUT_BUTTONS; i++)
+        if(test_bit(key,jbuttons[i])) pState->Gamepad.wButtons |= xbuttons[i];
+
+    /* Increment PacketNumber only if state has changed */
+    pState->dwPacketNumber = xpads[dwUserIndex].state.dwPacketNumber;
+    if(different_states(pState, &xpads[dwUserIndex].state)) {
+        pState->dwPacketNumber++;
+        xpads[dwUserIndex].state = *pState;
+    }
+
+    return ERROR_SUCCESS;
+
+#else  /* HAVE_CORRECT_LINUXINPUT_H */
     static int warn_once;
 
     if (!warn_once++)
@@ -80,6 +274,7 @@ DWORD WINAPI XInputGetState(DWORD dwUserIndex, XINPUT_STATE* pState)
         /* If controller exists then return ERROR_SUCCESS */
     }
     return ERROR_BAD_ARGUMENTS;
+#endif  /* HAVE_CORRECT_LINUXINPUT_H */
 }
 
 DWORD WINAPI XInputGetKeystroke(DWORD dwUserIndex, DWORD dwReserve, PXINPUT_KEYSTROKE pKeystroke)
